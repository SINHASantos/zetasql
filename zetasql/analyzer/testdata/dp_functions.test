# Valid function calls

[default language_features=MAXIMUM]
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => (0, 1)), COUNT(*, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
| +-$aggregate.$agg2#21 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#20, $agg2#21]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#20, $agg2#21]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#21 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# Invalid function call with extra argument
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, 1.0, contribution_bounds_per_group => (0, 1)), COUNT(*, 1.0, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--


ERROR: No matching signature for aggregate operator COUNT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, DOUBLE, STRUCT<INT64, INT64>
  Signature: COUNT(T2, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Signature accepts at most 2 arguments, found 3 arguments [at 1:34]
select with differential_privacy COUNT(string, 1.0, contribution_bounds_per_g...
                                 ^
==

# Invalid function call with extra arguments
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, 1.0, string, contriubtion_bounds_per_group => (0, 1)), COUNT(*, 1.0, string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--

ERROR: No matching signature for aggregate operator COUNT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, DOUBLE, STRING, STRUCT<INT64, INT64>
  Signature: COUNT(T2, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `contriubtion_bounds_per_group` does not exist in signature [at 1:34]
select with differential_privacy COUNT(string, 1.0, string, contriubtion_boun...
                                 ^
==

# contriubtion_bounds_per_group is mandatory
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, (0, 1)) from SimpleTypes
--

ERROR: No matching signature for aggregate operator COUNT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>
  Signature: COUNT(T2, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Positional argument at 2 is invalid because argument `contribution_bounds_per_group` can only be referred to by name [at 1:34]
select with differential_privacy COUNT(string, (0, 1)) from SimpleTypes
                                 ^
==

# Reject COUNT() with no arguments
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT() from SimpleTypes
--

ERROR: No matching signature for aggregate operator COUNT in SELECT WITH DIFFERENTIAL_PRIVACY context with no arguments
  Signature: COUNT(T2, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Signature requires at least 1 argument, found 0 arguments [at 1:34]
select with differential_privacy COUNT() from SimpleTypes
                                 ^
==

# DISTINCT is not supported for COUNT()
[language_features=NONE,+DISALLOW_GROUP_BY_FLOAT,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(DISTINCT string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--

ERROR: Aggregate operator COUNT does not support DISTINCT in arguments [at 1:34]
select with differential_privacy COUNT(DISTINCT string, contribution_bounds_p...
                                 ^
==

# Calling COUNT(*) without any optional arguments works.
[language_features=NONE,+DISALLOW_GROUP_BY_FLOAT,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(*) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
==

# Specify a non-constant expression for clamped bounds
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => ({{0|int64}}, {{1|int64}})) from SimpleTypes
--
ALTERNATION GROUP: 0,1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
--
ALTERNATION GROUPS:
    0,int64
    int64,1
    int64,int64
--


ERROR: Argument 'contribution_bounds_per_group' to COUNT must be a literal or query parameter [at 1:48]
select with differential_privacy COUNT(string, contribution_bounds_per_group ...
                                               ^
# COMMENT FROM MISSING PART


# COMMENT FROM MISSING PART


==

# Non-INT64 argument for clamp bounds.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ({{0|"abc"}}, {{1|"def"}})) from SimpleTypes
--
ALTERNATION GROUP: 0,1
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
--
ALTERNATION GROUP: 0,"def"
--


ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<INT64, STRING>
  Signature: COUNT(*, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `contribution_bounds_per_group`: Unable to coerce type STRUCT<INT64, STRING> to expected type STRUCT<INT64, INT64> [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (0...
                                 ^
--
ALTERNATION GROUP: "abc",1
--

ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<STRING, INT64>
  Signature: COUNT(*, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `contribution_bounds_per_group`: Unable to coerce type STRUCT<STRING, INT64> to expected type STRUCT<INT64, INT64> [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ("...
                                 ^
--
ALTERNATION GROUP: "abc","def"
--

ERROR: No matching signature for aggregate operator COUNT(*) in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRUCT<STRING, STRING>
  Signature: COUNT(*, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `contribution_bounds_per_group`: Unable to coerce type STRUCT<STRING, STRING> to expected type STRUCT<INT64, INT64> [at 1:34]
select with differential_privacy COUNT(*, contribution_bounds_per_group => ("...
                                 ^
==

# Accept const parameter bounds
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (@test_param_int64, 6)) from SimpleTypes
--
ERROR: Argument 'contribution_bounds_per_group' to COUNT(*) must be a literal or query parameter [at 1:43]
select with differential_privacy COUNT(*, contribution_bounds_per_group => (@...
                                          ^
==

# Accept const parameter bounds
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(*, contribution_bounds_per_group => @test_param_struct_two_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Parameter(type=STRUCT<INT64, INT64>, name="test_param_struct_two_int64")
==

# Support GROUP BY
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy COUNT(string, contribution_bounds_per_group => (0, 1)), COUNT(*, contribution_bounds_per_group => (0, 1)) from SimpleTypes
group by int64
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
| +-$aggregate.$agg2#21 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#20, $agg2#21]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#20, $agg2#21]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-group_by_list=
        | +-int64#22 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
        +-aggregate_list=
          +-$agg1#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#21 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# SUM should reject exprs other than int64, uint64, double & numeric
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy SUM(string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>
  Signature: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Argument 1: Unable to coerce type STRING to expected type INT64
  Signature: SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> UINT64
    Argument 1: Unable to coerce type STRING to expected type UINT64
  Signature: SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Argument 1: Unable to coerce type STRING to expected type DOUBLE [at 1:34]
select with differential_privacy SUM(string, contribution_bounds_per_group =>...
                                 ^
==

# AVG should reject exprs other than int64, uint64, double & numeric
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy AVG(string, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: No matching signature for aggregate operator AVG in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: STRING, STRUCT<INT64, INT64>
  Signature: AVG(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Argument 1: Unable to coerce type STRING to expected type DOUBLE [at 1:34]
select with differential_privacy AVG(string, contribution_bounds_per_group =>...
                                 ^
==

# Valid SUM function call
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy SUM(int64, contribution_bounds_per_group => (0, 1)), SUM(uint64, contribution_bounds_per_group => (0, 1)), SUM(double, contribution_bounds_per_group => (0, 1)),
SUM(numeric, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
| +-$aggregate.$agg2#21 AS `$col2` [UINT64]
| +-$aggregate.$agg3#22 AS `$col3` [DOUBLE]
| +-$aggregate.$agg4#23 AS `$col4` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#20, $agg2#21, $agg3#22, $agg4#23]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#20, $agg2#21, $agg3#22, $agg4#23]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint64#4, double#9, numeric#16], table=SimpleTypes, column_index_list=[1, 3, 8, 15])
        +-aggregate_list=
          +-$agg1#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
          |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
          +-$agg2#21 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(UINT64, optional(1) STRUCT<UINT64, UINT64> contribution_bounds_per_group) -> UINT64)
          |   +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          |   +-Literal(type=STRUCT<UINT64, UINT64>, value={0, 1})
          +-$agg3#22 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg4#23 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(NUMERIC -> DOUBLE)
              | +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# Valid AVG function call
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy AVG(int64, contribution_bounds_per_group => (0, 1)), AVG(uint64, contribution_bounds_per_group => (0, 1)), AVG(double, contribution_bounds_per_group => (0, 1)),
AVG(numeric, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
| +-$aggregate.$agg2#21 AS `$col2` [DOUBLE]
| +-$aggregate.$agg3#22 AS `$col3` [DOUBLE]
| +-$aggregate.$agg4#23 AS `$col4` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#20, $agg2#21, $agg3#22, $agg4#23]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=$aggregate.[$agg1#20, $agg2#21, $agg3#22, $agg4#23]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint64#4, double#9, numeric#16], table=SimpleTypes, column_index_list=[1, 3, 8, 15])
        +-aggregate_list=
          +-$agg1#20 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-Cast(INT64 -> DOUBLE)
          |   | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg2#21 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-Cast(UINT64 -> DOUBLE)
          |   | +-ColumnRef(type=UINT64, column=SimpleTypes.uint64#4)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg3#22 :=
          | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
          |   +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
          |   +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
          +-$agg4#23 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(NUMERIC -> DOUBLE)
              | +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# HAVING modifier is currently disabled for ANON functions, this is because the
# SQL builder will append all present modifiers to the last argument.
# In the case of the contribution_bounds_per_group => (modifier this could potentially produce
# invalid syntax when performing an unparse.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+HAVING_IN_AGGREGATE]
select with differential_privacy SUM(int64 having max 1, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Syntax error: Expected ")" but got "," [at 1:56]
...with differential_privacy SUM(int64 having max 1, contribution_bounds_per_...
                                                   ^
==

# HAVING modifier is currently disabled for ANON functions, this is because the
# SQL builder will append all present modifiers to the last argument.
# In the case of the contribution_bounds_per_group => (modifier this could potentially produce
# invalid syntax when performing an unparse.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+HAVING_IN_AGGREGATE]
select with differential_privacy AVG(int64 having max 1, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Syntax error: Expected ")" but got "," [at 1:56]
...with differential_privacy AVG(int64 having max 1, contribution_bounds_per_...
                                                   ^
==

# Valid safe SUM function call
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY safe.SUM(int64, contribution_bounds_per_group => (0, 1))
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall({SAFE_ERROR_MODE} ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
==

# DISTINCT is not supported for differential privacy aggregate functions
[language_features=NONE,+DISALLOW_GROUP_BY_FLOAT,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy SUM(DISTINCT int32, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Aggregate operator SUM does not support DISTINCT in arguments [at 1:34]
select with differential_privacy SUM(DISTINCT int32, contribution_bounds_per_...
                                 ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric, contribution_bounds_per_group => (1.9, 3.5))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={1.9, 3.5})
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric, contribution_bounds_per_group => (0.999999999, 1.000000001))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={0.999999999, 1.000000001})
==

# Valid safe AVG function call
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY safe.AVG(int64, contribution_bounds_per_group => (0, 1))
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall({SAFE_ERROR_MODE} ZetaSQL:$differential_privacy_avg(DOUBLE, optional(1) STRUCT<DOUBLE, DOUBLE> contribution_bounds_per_group) -> DOUBLE)
              +-Cast(INT64 -> DOUBLE)
              | +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=STRUCT<DOUBLE, DOUBLE>, value={0, 1})
==

# DISTINCT is not supported for differential privacy aggregate functions
[language_features=NONE,+DISALLOW_GROUP_BY_FLOAT,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]
select with differential_privacy AVG(DISTINCT int32, contribution_bounds_per_group => (0, 1)) from SimpleTypes
--
ERROR: Aggregate operator AVG does not support DISTINCT in arguments [at 1:34]
select with differential_privacy AVG(DISTINCT int32, contribution_bounds_per_...
                                 ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
AVG(numeric,  contribution_bounds_per_group => (0.999999999, 1.000000001))
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.numeric#16], table=SimpleTypes, column_index_list=[15])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_avg(NUMERIC, optional(1) STRUCT<NUMERIC, NUMERIC> contribution_bounds_per_group) -> NUMERIC)
              +-ColumnRef(type=NUMERIC, column=SimpleTypes.numeric#16)
              +-Literal(type=STRUCT<NUMERIC, NUMERIC>, value={0.999999999, 1.000000001})
==

# VAR_POP(ARRAY<DOUBLE>) is an internal signature and cannot be used by
# users.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy VAR_POP(double_array)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator VAR_POP in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>
  Signature: VAR_POP(DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Argument 1: Unable to coerce type ARRAY<DOUBLE> to expected type DOUBLE [at 1:34]
select with differential_privacy VAR_POP(double_array)
                                 ^
==

# STDDEV_POP(ARRAY<DOUBLE>) is an internal signature and cannot be used by
# users.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy STDDEV_POP(double_array)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator STDDEV_POP in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>
  Signature: STDDEV_POP(DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Argument 1: Unable to coerce type ARRAY<DOUBLE> to expected type DOUBLE [at 1:34]
select with differential_privacy STDDEV_POP(double_array)
                                 ^
==

# PERCENTILE_CONT(ARRAY<DOUBLE>, DOUBLE) is an internal signature and
# cannot be used by users.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double_array, 0.4)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>, DOUBLE
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Argument 1: Unable to coerce type ARRAY<DOUBLE> to expected type DOUBLE [at 1:34]
select with differential_privacy PERCENTILE_CONT(double_array, 0.4)
                                 ^
==

# PERCENTILE_CONT(DOUBLE) is not supported because that percentile is not
# provided.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Signature requires at least 2 arguments, found 1 argument [at 1:34]
select with differential_privacy PERCENTILE_CONT(double)
                                 ^
==

# More than two arguments are not supported for PERCENTILE_CONT.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, double, double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE, DOUBLE
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Positional argument at 3 is invalid because argument `contribution_bounds_per_row` can only be referred to by name [at 1:34]
select with differential_privacy PERCENTILE_CONT(double, double, double)
                                 ^
==

# percentile must be in the range [0.0, 1.0]
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, 1.5)
from SimpleTypesWithAnonymizationUid;
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:58]
select with differential_privacy PERCENTILE_CONT(double, 1.5)
                                                         ^
==

# percentile must have two arguments.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double, 1.5, 1.5)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE, DOUBLE
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Positional argument at 3 is invalid because argument `contribution_bounds_per_row` can only be referred to by name [at 1:34]
select with differential_privacy PERCENTILE_CONT(double, 1.5, 1.5)
                                 ^
==

# percentile must have two arguments.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy PERCENTILE_CONT(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Signature requires at least 2 arguments, found 1 argument [at 1:34]
select with differential_privacy PERCENTILE_CONT(double)
                                 ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4, 0.4, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, DOUBLE, DOUBLE, STRUCT<INT64, INT64>
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    PERCENTILE_CONT(int64, 0.4, 0.4, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRUCT<INT64, INT64>
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    PERCENTILE_CONT(int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, double, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator PERCENTILE_CONT in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, DOUBLE, STRUCT<INT64, INT64>
  Signature: PERCENTILE_CONT(DOUBLE, DOUBLE, [contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    PERCENTILE_CONT(int64, double, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (double, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: Syntax error: Expected ")" but got identifier "contribution_bounds_per_group" [at 2:32]
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (double, 3))
                               ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (2, double))
from SimpleTypesWithAnonymizationUid;
--

ERROR: Syntax error: Expected ")" but got identifier "contribution_bounds_per_group" [at 2:32]
    PERCENTILE_CONT(int64, 0.4 contribution_bounds_per_group => (2, double))
                               ^
==

# APPROX_QUANTILES(ARRAY<DOUBLE>, INT64) is an internal signature and
# cannot be used by users.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double_array, 4)
from ArrayWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: ARRAY<DOUBLE>, INT64
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Signature requires at least 3 arguments, found 2 arguments [at 1:34]
select with differential_privacy APPROX_QUANTILES(double_array, 4)
                                 ^
==

# APPROX_QUANTILES(DOUBLE) is not supported because APPROX_QUANTILES are not
# provided.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Signature requires at least 3 arguments, found 1 argument [at 1:34]
select with differential_privacy APPROX_QUANTILES(double)
                                 ^
==

# More than two arguments are not supported for APPROX_QUANTILES.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, int64, double)
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, INT64, DOUBLE
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Positional argument at 3 is invalid because argument `contribution_bounds_per_row` can only be referred to by name [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, int64, double)
                                 ^
==

# APPROX_QUANTILES must be an int64
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, double)
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, DOUBLE
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Signature requires at least 3 arguments, found 2 arguments [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, double)
                                 ^
==

# APPROX_QUANTILES requires explicit bounds
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy APPROX_QUANTILES(double, int64)
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: DOUBLE, INT64
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Signature requires at least 3 arguments, found 2 arguments [at 1:34]
select with differential_privacy APPROX_QUANTILES(double, int64)
                                 ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, 0.4, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, DOUBLE, STRUCT<INT64, INT64>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, 4, 0.4, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRUCT<INT64, INT64>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, int64, contribution_bounds_per_group => (2, 3))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<INT64, INT64>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, int64, contribution_bounds_per_group => (2, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (double, 3))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<DOUBLE, INT64>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (double, 3))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (2, double))
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<INT64, DOUBLE>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, 4, contribution_bounds_per_group => (2, double))
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]
select with differential_privacy
    APPROX_QUANTILES(int64, @test_param_int64, contribution_bounds_per_group => (@test_param_double, @test_param_double))
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator APPROX_QUANTILES in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, INT64, STRUCT<DOUBLE, DOUBLE>
  Signature: APPROX_QUANTILES(DOUBLE, INT64, contribution_bounds_per_row => STRUCT<DOUBLE, DOUBLE>) -> ARRAY<DOUBLE>
    Named argument `contribution_bounds_per_group` does not exist in signature [at 2:5]
    APPROX_QUANTILES(int64, @test_param_int64, contribution_bounds_per_group ...
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,+NAMED_ARGUMENTS,+JSON_TYPE]
[no_enable_literal_replacement]
select with differential_privacy
    SUM(int64, report_format => "JSON") as s
from SimpleTypesWithAnonymizationUid;
--
QueryStmt
+-output_column_list=
| +-$aggregate.s#13 AS s [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.s#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.s#13]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-s#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT> report_format, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> JSON)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=ENUM<DIFFERENTIAL_PRIVACY_REPORT_FORMAT>, value=JSON)
              +-Literal(type=STRUCT<INT64, INT64>, value=NULL)
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,+NAMED_ARGUMENTS,+JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => "Invalid") as s
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING
  Signature: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> UINT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `report_format` does not exist in signature
  Signature: SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> JSON
    Invalid enum value: Invalid
  Signature: SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> JSON
    Invalid enum value: Invalid
  Signature: SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> JSON
    Argument 1: Unable to coerce type INT64 to expected type UINT64
  Signature: SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Invalid enum value: Invalid
  Signature: SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Invalid enum value: Invalid
  Signature: SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Argument 1: Unable to coerce type INT64 to expected type UINT64 [at 2:5]
    SUM(int64, report_format => "Invalid") as s
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,+NAMED_ARGUMENTS,+JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => @test_param_string) as s
from SimpleTypesWithAnonymizationUid;
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING
  Signature: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> UINT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `report_format` does not exist in signature
  Signature: SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> JSON
    literal value is required at 2
  Signature: SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> JSON
    literal value is required at 2
  Signature: SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "JSON"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> JSON
    Argument 1: Unable to coerce type INT64 to expected type UINT64
  Signature: SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    literal value is required at 2
  Signature: SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    literal value is required at 2
  Signature: SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Argument 1: Unable to coerce type INT64 to expected type UINT64 [at 2:5]
    SUM(int64, report_format => @test_param_string) as s
    ^
==

[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+JSON_TYPE]
select with differential_privacy
    SUM(int64, report_format => "JSON") as s
from SimpleTypesWithAnonymizationUid;
--
ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: INT64, STRING
  Signature: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> UINT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `report_format` does not exist in signature [at 2:5]
    SUM(int64, report_format => "JSON") as s
    ^
==

# Numeric sum with report is not implemented.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,+NUMERIC_TYPE,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
SUM(numeric,  report_format => "JSON")
FROM SimpleTypes
--

ERROR: No matching signature for aggregate operator SUM in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: NUMERIC, STRING
  Signature: SUM(INT64, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> INT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(UINT64, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> UINT64
    Named argument `report_format` does not exist in signature
  Signature: SUM(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `report_format` does not exist in signature
  Signature: SUM(NUMERIC, [contribution_bounds_per_group => STRUCT<NUMERIC, NUMERIC>]) -> NUMERIC
    Named argument `report_format` does not exist in signature
  Signature: SUM(INT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<INT64, INT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Argument 1: Unable to coerce type NUMERIC to expected type INT64
  Signature: SUM(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Found: JSON expecting: PROTO
  Signature: SUM(UINT64, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<UINT64, UINT64>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Argument 1: Unable to coerce type NUMERIC to expected type UINT64 [at 2:1]
SUM(numeric,  report_format => "JSON")
^
==

# Numeric avg with report is not implemented.
[language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+DIFFERENTIAL_PRIVACY_REPORT_FUNCTIONS,+NUMERIC_TYPE,+SAFE_FUNCTION_CALL]
select WITH DIFFERENTIAL_PRIVACY
AVG(numeric,  report_format => "JSON")
FROM SimpleTypes
--

ERROR: No matching signature for aggregate operator AVG in SELECT WITH DIFFERENTIAL_PRIVACY context for argument types: NUMERIC, STRING
  Signature: AVG(DOUBLE, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> DOUBLE
    Named argument `report_format` does not exist in signature
  Signature: AVG(NUMERIC, [contribution_bounds_per_group => STRUCT<NUMERIC, NUMERIC>]) -> NUMERIC
    Named argument `report_format` does not exist in signature
  Signature: AVG(DOUBLE, report_format => DIFFERENTIAL_PRIVACY_REPORT_FORMAT/*with value "PROTO"*/, [contribution_bounds_per_group => STRUCT<DOUBLE, DOUBLE>]) -> zetasql.functions.DifferentialPrivacyOutputWithReport
    Found: JSON expecting: PROTO [at 2:1]
AVG(numeric,  report_format => "JSON")
^
