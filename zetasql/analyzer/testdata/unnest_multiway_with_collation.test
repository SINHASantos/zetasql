[default language_features=MAXIMUM,+MULTIWAY_UNNEST,+WITH_EXPRESSION,+ANNOTATION_FRAMEWORK,+COLLATION_SUPPORT]
[default enabled_ast_rewrites=DEFAULTS,-WITH_EXPR,+MULTIWAY_UNNEST]
[default no_run_sqlbuilder]

# Zipping 2 literal arrays, with only one collated array
SELECT *
FROM UNNEST([COLLATE('A', 'und:ci'), COLLATE('b', 'und:ci')], [1], mode => {{"STRICT"|"TRUNCATE"|"PAD"}});
--
ALTERNATION GROUP: "STRICT"
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_expr_list=
        | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
        | | +-type_annotation_map=<{Collation:"und:ci"}>
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | | | +-type_annotation_map={Collation:"und:ci"}
        | | | +-Literal(type=STRING, value="A")
        | | | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-Literal(type=STRING, value="b")
        | |   +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | +-Literal(type=ARRAY<INT64>, value=[1])
        +-element_column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_zip_mode=
          +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-expr_list=
        | +-$unnest1#1 :=
        | | +-GetStructField
        | |   +-type=STRING
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        | |   +-field_idx=0
        | +-$unnest2#2 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        |     +-field_idx=1
        +-input_scan=
          +-ArrayScan
            +-column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
            +-array_expr_list=
            | +-WithExpr
            |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |   +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |   +-assignment_list=
            |   | +-arr0#3 :=
            |   | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
            |   | |   +-type_annotation_map=<{Collation:"und:ci"}>
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |   | +-type_annotation_map={Collation:"und:ci"}
            |   | |   | +-Literal(type=STRING, value="A")
            |   | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |     +-type_annotation_map={Collation:"und:ci"}
            |   | |     +-Literal(type=STRING, value="b")
            |   | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | +-arr0_len#4 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | +-arr1#5 := Literal(type=ARRAY<INT64>, value=[1])
            |   | +-arr1_len#6 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | +-mode#7 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
            |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | +-strict_check#8 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
            |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
            |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
            |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
            |   | |   +-Literal(type=INT64, value=NULL)
            |   | +-result_len#9 :=
            |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   +-expr=
            |     +-SubqueryExpr
            |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |       +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |       +-subquery_type=ARRAY
            |       +-parameter_list=
            |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |       | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#9)
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$make_struct.$struct#15<{Collation:"und:ci"},_,_>]
            |           +-is_ordered=TRUE
            |           +-expr_list=
            |           | +-$struct#15 :=
            |           |   +-MakeStruct
            |           |     +-type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>
            |           |     +-type_annotation_map=<{Collation:"und:ci"},_,_>
            |           |     +-field_list=
            |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#10{Collation:"und:ci"})
            |           |       +-ColumnRef(type=INT64, column=$array.arr1#12)
            |           |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |           +-input_scan=
            |             +-OrderByScan
            |               +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               +-is_ordered=TRUE
            |               +-input_scan=
            |               | +-FilterScan
            |               |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   +-input_scan=
            |               |   | +-ProjectScan
            |               |   |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   |   +-expr_list=
            |               |   |   | +-offset#14 :=
            |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   |   +-input_scan=
            |               |   |     +-JoinScan
            |               |   |       +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13]
            |               |   |       +-join_type=FULL
            |               |   |       +-left_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#3<{Collation:"und:ci"}>, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr0#10{Collation:"und:ci"}]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#11)
            |               |   |       +-right_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr1#12, $array_offset.offset#13]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr1#12]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#13)
            |               |   |       +-join_expr=
            |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   +-filter_expr=
            |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |               |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#9, is_correlated=TRUE)
            |               +-order_by_item_list=
            |                 +-OrderByItem
            |                   +-column_ref=
            |                     +-ColumnRef(type=INT64, column=$full_join.offset#14)
            +-element_column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
--
ALTERNATION GROUP: "TRUNCATE"
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_expr_list=
        | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
        | | +-type_annotation_map=<{Collation:"und:ci"}>
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | | | +-type_annotation_map={Collation:"und:ci"}
        | | | +-Literal(type=STRING, value="A")
        | | | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-Literal(type=STRING, value="b")
        | |   +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | +-Literal(type=ARRAY<INT64>, value=[1])
        +-element_column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_zip_mode=
          +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-expr_list=
        | +-$unnest1#1 :=
        | | +-GetStructField
        | |   +-type=STRING
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        | |   +-field_idx=0
        | +-$unnest2#2 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        |     +-field_idx=1
        +-input_scan=
          +-ArrayScan
            +-column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
            +-array_expr_list=
            | +-WithExpr
            |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |   +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |   +-assignment_list=
            |   | +-arr0#3 :=
            |   | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
            |   | |   +-type_annotation_map=<{Collation:"und:ci"}>
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |   | +-type_annotation_map={Collation:"und:ci"}
            |   | |   | +-Literal(type=STRING, value="A")
            |   | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |     +-type_annotation_map={Collation:"und:ci"}
            |   | |     +-Literal(type=STRING, value="b")
            |   | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | +-arr0_len#4 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | +-arr1#5 := Literal(type=ARRAY<INT64>, value=[1])
            |   | +-arr1_len#6 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | +-mode#7 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
            |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   | +-strict_check#8 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
            |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
            |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
            |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
            |   | |   +-Literal(type=INT64, value=NULL)
            |   | +-result_len#9 :=
            |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   +-expr=
            |     +-SubqueryExpr
            |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |       +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |       +-subquery_type=ARRAY
            |       +-parameter_list=
            |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |       | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#9)
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$make_struct.$struct#15<{Collation:"und:ci"},_,_>]
            |           +-is_ordered=TRUE
            |           +-expr_list=
            |           | +-$struct#15 :=
            |           |   +-MakeStruct
            |           |     +-type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>
            |           |     +-type_annotation_map=<{Collation:"und:ci"},_,_>
            |           |     +-field_list=
            |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#10{Collation:"und:ci"})
            |           |       +-ColumnRef(type=INT64, column=$array.arr1#12)
            |           |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |           +-input_scan=
            |             +-OrderByScan
            |               +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               +-is_ordered=TRUE
            |               +-input_scan=
            |               | +-FilterScan
            |               |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   +-input_scan=
            |               |   | +-ProjectScan
            |               |   |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   |   +-expr_list=
            |               |   |   | +-offset#14 :=
            |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   |   +-input_scan=
            |               |   |     +-JoinScan
            |               |   |       +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13]
            |               |   |       +-join_type=FULL
            |               |   |       +-left_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#3<{Collation:"und:ci"}>, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr0#10{Collation:"und:ci"}]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#11)
            |               |   |       +-right_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr1#12, $array_offset.offset#13]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr1#12]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#13)
            |               |   |       +-join_expr=
            |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   +-filter_expr=
            |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |               |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#9, is_correlated=TRUE)
            |               +-order_by_item_list=
            |                 +-OrderByItem
            |                   +-column_ref=
            |                     +-ColumnRef(type=INT64, column=$full_join.offset#14)
            +-element_column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
--
ALTERNATION GROUP: "PAD"
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_expr_list=
        | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
        | | +-type_annotation_map=<{Collation:"und:ci"}>
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | | | +-type_annotation_map={Collation:"und:ci"}
        | | | +-Literal(type=STRING, value="A")
        | | | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-Literal(type=STRING, value="b")
        | |   +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | +-Literal(type=ARRAY<INT64>, value=[1])
        +-element_column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_zip_mode=
          +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2 AS `$unnest2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-expr_list=
        | +-$unnest1#1 :=
        | | +-GetStructField
        | |   +-type=STRING
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        | |   +-field_idx=0
        | +-$unnest2#2 :=
        |   +-GetStructField
        |     +-type=INT64
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>, type_annotation_map=<{Collation:"und:ci"},_,_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},_,_>)
        |     +-field_idx=1
        +-input_scan=
          +-ArrayScan
            +-column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
            +-array_expr_list=
            | +-WithExpr
            |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |   +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |   +-assignment_list=
            |   | +-arr0#3 :=
            |   | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
            |   | |   +-type_annotation_map=<{Collation:"und:ci"}>
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |   | +-type_annotation_map={Collation:"und:ci"}
            |   | |   | +-Literal(type=STRING, value="A")
            |   | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |     +-type_annotation_map={Collation:"und:ci"}
            |   | |     +-Literal(type=STRING, value="b")
            |   | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | +-arr0_len#4 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | +-arr1#5 := Literal(type=ARRAY<INT64>, value=[1])
            |   | +-arr1_len#6 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |   | +-mode#7 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
            |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
            |   | +-strict_check#8 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
            |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
            |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
            |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
            |   | |   +-Literal(type=INT64, value=NULL)
            |   | +-result_len#9 :=
            |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   +-expr=
            |     +-SubqueryExpr
            |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 INT64, offset INT64>>
            |       +-type_annotation_map=<<{Collation:"und:ci"},_,_>>
            |       +-subquery_type=ARRAY
            |       +-parameter_list=
            |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |       | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5)
            |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#9)
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$make_struct.$struct#15<{Collation:"und:ci"},_,_>]
            |           +-is_ordered=TRUE
            |           +-expr_list=
            |           | +-$struct#15 :=
            |           |   +-MakeStruct
            |           |     +-type=STRUCT<arr0 STRING, arr1 INT64, offset INT64>
            |           |     +-type_annotation_map=<{Collation:"und:ci"},_,_>
            |           |     +-field_list=
            |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#10{Collation:"und:ci"})
            |           |       +-ColumnRef(type=INT64, column=$array.arr1#12)
            |           |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |           +-input_scan=
            |             +-OrderByScan
            |               +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               +-is_ordered=TRUE
            |               +-input_scan=
            |               | +-FilterScan
            |               |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   +-input_scan=
            |               |   | +-ProjectScan
            |               |   |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13, $full_join.offset#14]
            |               |   |   +-expr_list=
            |               |   |   | +-offset#14 :=
            |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   |   +-input_scan=
            |               |   |     +-JoinScan
            |               |   |       +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12, $array_offset.offset#13]
            |               |   |       +-join_type=FULL
            |               |   |       +-left_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#3<{Collation:"und:ci"}>, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr0#10{Collation:"und:ci"}]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#11)
            |               |   |       +-right_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr1#12, $array_offset.offset#13]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<INT64>, column=$with_expr.arr1#5, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr1#12]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#13)
            |               |   |       +-join_expr=
            |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   +-filter_expr=
            |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |               |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#9, is_correlated=TRUE)
            |               +-order_by_item_list=
            |                 +-OrderByItem
            |                   +-column_ref=
            |                     +-ColumnRef(type=INT64, column=$full_join.offset#14)
            +-element_column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},_,_>]
==

# Zipping 2 literal arrays, with different collations in different arrays
SELECT *
FROM UNNEST(
  [COLLATE('A', 'und:ci'), COLLATE('b', 'und:ci')],
  [COLLATE('x', 'und:binary'), COLLATE('Y', 'und:binary')]);
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2{Collation:"und:binary"} AS `$unnest2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ArrayScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_expr_list=
        | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
        | | +-type_annotation_map=<{Collation:"und:ci"}>
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | | | +-type_annotation_map={Collation:"und:ci"}
        | | | +-Literal(type=STRING, value="A")
        | | | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | | +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-Literal(type=STRING, value="b")
        | |   +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
        | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
        |   +-type_annotation_map=<{Collation:"und:binary"}>
        |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |   | +-type_annotation_map={Collation:"und:binary"}
        |   | +-Literal(type=STRING, value="x")
        |   | +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
        |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
        |     +-type_annotation_map={Collation:"und:binary"}
        |     +-Literal(type=STRING, value="Y")
        |     +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
        +-element_column_list=$array.[$unnest1#1, $unnest2#2]
        +-array_zip_mode=
          +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1{Collation:"und:ci"} AS `$unnest1` [STRING]
| +-$array.$unnest2#2{Collation:"und:binary"} AS `$unnest2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$array.[$unnest1#1, $unnest2#2]
    +-input_scan=
      +-ProjectScan
        +-column_list=$array.[$unnest1#1, $unnest2#2]
        +-expr_list=
        | +-$unnest1#1 :=
        | | +-GetStructField
        | |   +-type=STRING
        | |   +-type_annotation_map={Collation:"und:ci"}
        | |   +-expr=
        | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},{Collation:"und:binary"},_>)
        | |   +-field_idx=0
        | +-$unnest2#2 :=
        |   +-GetStructField
        |     +-type=STRING
        |     +-type_annotation_map={Collation:"und:binary"}
        |     +-expr=
        |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>, column=$array.$with_expr_element#16<{Collation:"und:ci"},{Collation:"und:binary"},_>)
        |     +-field_idx=1
        +-input_scan=
          +-ArrayScan
            +-column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},{Collation:"und:binary"},_>]
            +-array_expr_list=
            | +-WithExpr
            |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
            |   +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:binary"},_>>
            |   +-assignment_list=
            |   | +-arr0#3 :=
            |   | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
            |   | |   +-type_annotation_map=<{Collation:"und:ci"}>
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |   | +-type_annotation_map={Collation:"und:ci"}
            |   | |   | +-Literal(type=STRING, value="A")
            |   | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |     +-type_annotation_map={Collation:"und:ci"}
            |   | |     +-Literal(type=STRING, value="b")
            |   | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
            |   | +-arr0_len#4 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |   | +-arr1#5 :=
            |   | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
            |   | |   +-type_annotation_map=<{Collation:"und:binary"}>
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |   | +-type_annotation_map={Collation:"und:binary"}
            |   | |   | +-Literal(type=STRING, value="x")
            |   | |   | +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
            |   | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
            |   | |     +-type_annotation_map={Collation:"und:binary"}
            |   | |     +-Literal(type=STRING, value="Y")
            |   | |     +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
            |   | +-arr1_len#6 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#5<{Collation:"und:binary"}>)
            |   | |   +-Literal(type=INT64, value=0)
            |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
            |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#5<{Collation:"und:binary"}>)
            |   | +-mode#7 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
            |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
            |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
            |   | +-strict_check#8 :=
            |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
            |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
            |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
            |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
            |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
            |   | |   +-Literal(type=INT64, value=NULL)
            |   | +-result_len#9 :=
            |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
            |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
            |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#7)
            |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
            |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#4)
            |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#6)
            |   +-expr=
            |     +-SubqueryExpr
            |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
            |       +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:binary"},_>>
            |       +-subquery_type=ARRAY
            |       +-parameter_list=
            |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#3<{Collation:"und:ci"}>)
            |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#5<{Collation:"und:binary"}>)
            |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#9)
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$make_struct.$struct#15<{Collation:"und:ci"},{Collation:"und:binary"},_>]
            |           +-is_ordered=TRUE
            |           +-expr_list=
            |           | +-$struct#15 :=
            |           |   +-MakeStruct
            |           |     +-type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>
            |           |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>
            |           |     +-field_list=
            |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#10{Collation:"und:ci"})
            |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:binary"}, column=$array.arr1#12{Collation:"und:binary"})
            |           |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |           +-input_scan=
            |             +-OrderByScan
            |               +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12{Collation:"und:binary"}, $array_offset.offset#13, $full_join.offset#14]
            |               +-is_ordered=TRUE
            |               +-input_scan=
            |               | +-FilterScan
            |               |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12{Collation:"und:binary"}, $array_offset.offset#13, $full_join.offset#14]
            |               |   +-input_scan=
            |               |   | +-ProjectScan
            |               |   |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12{Collation:"und:binary"}, $array_offset.offset#13, $full_join.offset#14]
            |               |   |   +-expr_list=
            |               |   |   | +-offset#14 :=
            |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   |   +-input_scan=
            |               |   |     +-JoinScan
            |               |   |       +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11, $array.arr1#12{Collation:"und:binary"}, $array_offset.offset#13]
            |               |   |       +-join_type=FULL
            |               |   |       +-left_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr0#10{Collation:"und:ci"}, $array_offset.offset#11]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#3<{Collation:"und:ci"}>, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr0#10{Collation:"und:ci"}]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#11)
            |               |   |       +-right_scan=
            |               |   |       | +-ArrayScan
            |               |   |       |   +-column_list=[$array.arr1#12{Collation:"und:binary"}, $array_offset.offset#13]
            |               |   |       |   +-array_expr_list=
            |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr1#5<{Collation:"und:binary"}>, is_correlated=TRUE)
            |               |   |       |   +-element_column_list=[$array.arr1#12{Collation:"und:binary"}]
            |               |   |       |   +-array_offset_column=
            |               |   |       |     +-ColumnHolder(column=$array_offset.offset#13)
            |               |   |       +-join_expr=
            |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#11)
            |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#13)
            |               |   +-filter_expr=
            |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            |               |       +-ColumnRef(type=INT64, column=$full_join.offset#14)
            |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#9, is_correlated=TRUE)
            |               +-order_by_item_list=
            |                 +-OrderByItem
            |                   +-column_ref=
            |                     +-ColumnRef(type=INT64, column=$full_join.offset#14)
            +-element_column_list=[$array.$with_expr_element#16<{Collation:"und:ci"},{Collation:"und:binary"},_>]
==

# Zipping 2 path expression arrays, with the same collation
WITH t AS (SELECT [COLLATE('A', 'und:ci'), COLLATE('b', 'und:ci')] AS xs)
SELECT *
FROM t, UNNEST(t.xs, t.xs AS arr2)
--
QueryStmt
+-output_column_list=
| +-t.xs#2<{Collation:"und:ci"}> AS xs [ARRAY<STRING>]
| +-$array.xs#3{Collation:"und:ci"} AS xs [STRING]
| +-$array.arr2#4{Collation:"und:ci"} AS arr2 [STRING]
+-query=
  +-WithScan
    +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t.xs#1<{Collation:"und:ci"}>]
    |       +-expr_list=
    |       | +-xs#1 :=
    |       |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       |     +-type_annotation_map=<{Collation:"und:ci"}>
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |     | +-type_annotation_map={Collation:"und:ci"}
    |       |     | +-Literal(type=STRING, value="A")
    |       |     | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |       +-type_annotation_map={Collation:"und:ci"}
    |       |       +-Literal(type=STRING, value="b")
    |       |       +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
        +-input_scan=
          +-ArrayScan
            +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
            +-input_scan=
            | +-WithRefScan(column_list=[t.xs#2<{Collation:"und:ci"}>], with_query_name="t")
            +-array_expr_list=
            | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.xs#2<{Collation:"und:ci"}>)
            | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.xs#2<{Collation:"und:ci"}>)
            +-element_column_list=$array.[xs#3, arr2#4]
            +-array_zip_mode=
              +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-t.xs#2<{Collation:"und:ci"}> AS xs [ARRAY<STRING>]
| +-$array.xs#3{Collation:"und:ci"} AS xs [STRING]
| +-$array.arr2#4{Collation:"und:ci"} AS arr2 [STRING]
+-query=
  +-WithScan
    +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[t.xs#1<{Collation:"und:ci"}>]
    |       +-expr_list=
    |       | +-xs#1 :=
    |       |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       |     +-type_annotation_map=<{Collation:"und:ci"}>
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |     | +-type_annotation_map={Collation:"und:ci"}
    |       |     | +-Literal(type=STRING, value="A")
    |       |     | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |       +-type_annotation_map={Collation:"und:ci"}
    |       |       +-Literal(type=STRING, value="b")
    |       |       +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
        +-input_scan=
          +-ProjectScan
            +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.xs#3{Collation:"und:ci"}, $array.arr2#4{Collation:"und:ci"}]
            +-expr_list=
            | +-xs#3 :=
            | | +-GetStructField
            | |   +-type=STRING
            | |   +-type_annotation_map={Collation:"und:ci"}
            | |   +-expr=
            | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:ci"},_>, column=$array.$with_expr_element#18<{Collation:"und:ci"},{Collation:"und:ci"},_>)
            | |   +-field_idx=0
            | +-arr2#4 :=
            |   +-GetStructField
            |     +-type=STRING
            |     +-type_annotation_map={Collation:"und:ci"}
            |     +-expr=
            |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:ci"},_>, column=$array.$with_expr_element#18<{Collation:"und:ci"},{Collation:"und:ci"},_>)
            |     +-field_idx=1
            +-input_scan=
              +-ArrayScan
                +-column_list=[t.xs#2<{Collation:"und:ci"}>, $array.$with_expr_element#18<{Collation:"und:ci"},{Collation:"und:ci"},_>]
                +-input_scan=
                | +-WithRefScan(column_list=[t.xs#2<{Collation:"und:ci"}>], with_query_name="t")
                +-array_expr_list=
                | +-WithExpr
                |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
                |   +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:ci"},_>>
                |   +-assignment_list=
                |   | +-arr0#5 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.xs#2<{Collation:"und:ci"}>)
                |   | +-arr0_len#6 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
                |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#5<{Collation:"und:ci"}>)
                |   | |   +-Literal(type=INT64, value=0)
                |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
                |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#5<{Collation:"und:ci"}>)
                |   | +-arr1#7 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.xs#2<{Collation:"und:ci"}>)
                |   | +-arr1_len#8 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
                |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr1#7<{Collation:"und:ci"}>)
                |   | |   +-Literal(type=INT64, value=0)
                |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
                |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr1#7<{Collation:"und:ci"}>)
                |   | +-mode#9 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
                |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
                |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
                |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
                |   | +-strict_check#10 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
                |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#9)
                |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
                |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
                |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
                |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#6)
                |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#8)
                |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
                |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#6)
                |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#8)
                |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
                |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
                |   | |   +-Literal(type=INT64, value=NULL)
                |   | +-result_len#11 :=
                |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#9)
                |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
                |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
                |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#6)
                |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#8)
                |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
                |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#6)
                |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#8)
                |   +-expr=
                |     +-SubqueryExpr
                |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
                |       +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:ci"},_>>
                |       +-subquery_type=ARRAY
                |       +-parameter_list=
                |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#5<{Collation:"und:ci"}>)
                |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr1#7<{Collation:"und:ci"}>)
                |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#11)
                |       +-subquery=
                |         +-ProjectScan
                |           +-column_list=[$make_struct.$struct#17<{Collation:"und:ci"},{Collation:"und:ci"},_>]
                |           +-is_ordered=TRUE
                |           +-expr_list=
                |           | +-$struct#17 :=
                |           |   +-MakeStruct
                |           |     +-type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>
                |           |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"und:ci"},_>
                |           |     +-field_list=
                |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#12{Collation:"und:ci"})
                |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr1#14{Collation:"und:ci"})
                |           |       +-ColumnRef(type=INT64, column=$full_join.offset#16)
                |           +-input_scan=
                |             +-OrderByScan
                |               +-column_list=[$array.arr0#12{Collation:"und:ci"}, $array_offset.offset#13, $array.arr1#14{Collation:"und:ci"}, $array_offset.offset#15, $full_join.offset#16]
                |               +-is_ordered=TRUE
                |               +-input_scan=
                |               | +-FilterScan
                |               |   +-column_list=[$array.arr0#12{Collation:"und:ci"}, $array_offset.offset#13, $array.arr1#14{Collation:"und:ci"}, $array_offset.offset#15, $full_join.offset#16]
                |               |   +-input_scan=
                |               |   | +-ProjectScan
                |               |   |   +-column_list=[$array.arr0#12{Collation:"und:ci"}, $array_offset.offset#13, $array.arr1#14{Collation:"und:ci"}, $array_offset.offset#15, $full_join.offset#16]
                |               |   |   +-expr_list=
                |               |   |   | +-offset#16 :=
                |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
                |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#13)
                |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#15)
                |               |   |   +-input_scan=
                |               |   |     +-JoinScan
                |               |   |       +-column_list=[$array.arr0#12{Collation:"und:ci"}, $array_offset.offset#13, $array.arr1#14{Collation:"und:ci"}, $array_offset.offset#15]
                |               |   |       +-join_type=FULL
                |               |   |       +-left_scan=
                |               |   |       | +-ArrayScan
                |               |   |       |   +-column_list=[$array.arr0#12{Collation:"und:ci"}, $array_offset.offset#13]
                |               |   |       |   +-array_expr_list=
                |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#5<{Collation:"und:ci"}>, is_correlated=TRUE)
                |               |   |       |   +-element_column_list=[$array.arr0#12{Collation:"und:ci"}]
                |               |   |       |   +-array_offset_column=
                |               |   |       |     +-ColumnHolder(column=$array_offset.offset#13)
                |               |   |       +-right_scan=
                |               |   |       | +-ArrayScan
                |               |   |       |   +-column_list=[$array.arr1#14{Collation:"und:ci"}, $array_offset.offset#15]
                |               |   |       |   +-array_expr_list=
                |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr1#7<{Collation:"und:ci"}>, is_correlated=TRUE)
                |               |   |       |   +-element_column_list=[$array.arr1#14{Collation:"und:ci"}]
                |               |   |       |   +-array_offset_column=
                |               |   |       |     +-ColumnHolder(column=$array_offset.offset#15)
                |               |   |       +-join_expr=
                |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#13)
                |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#15)
                |               |   +-filter_expr=
                |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
                |               |       +-ColumnRef(type=INT64, column=$full_join.offset#16)
                |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#11, is_correlated=TRUE)
                |               +-order_by_item_list=
                |                 +-OrderByItem
                |                   +-column_ref=
                |                     +-ColumnRef(type=INT64, column=$full_join.offset#16)
                +-element_column_list=[$array.$with_expr_element#18<{Collation:"und:ci"},{Collation:"und:ci"},_>]
==

# Zipping 2 path expression arrays, with different collations in different arrays
WITH t AS (
  SELECT
    [COLLATE('A', 'und:ci'), COLLATE('b', 'und:ci')] AS arr1,
    [COLLATE('x', 'und:binary'), COLLATE('Y', 'und:binary')] AS arr2
)
SELECT *
FROM t, UNNEST(t.arr1, t.arr2 AS arr2)
--
QueryStmt
+-output_column_list=
| +-t.arr1#3<{Collation:"und:ci"}> AS arr1 [ARRAY<STRING>]
| +-t.arr2#4<{Collation:"und:binary"}> AS arr2 [ARRAY<STRING>]
| +-$array.arr1#5{Collation:"und:ci"} AS arr1 [STRING]
| +-$array.arr2#6{Collation:"und:binary"} AS arr2 [STRING]
+-query=
  +-WithScan
    +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[arr1#1, arr2#2]
    |       +-expr_list=
    |       | +-arr1#1 :=
    |       | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       | |   +-type_annotation_map=<{Collation:"und:ci"}>
    |       | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |   | +-type_annotation_map={Collation:"und:ci"}
    |       | |   | +-Literal(type=STRING, value="A")
    |       | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |     +-type_annotation_map={Collation:"und:ci"}
    |       | |     +-Literal(type=STRING, value="b")
    |       | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       | +-arr2#2 :=
    |       |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       |     +-type_annotation_map=<{Collation:"und:binary"}>
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |     | +-type_annotation_map={Collation:"und:binary"}
    |       |     | +-Literal(type=STRING, value="x")
    |       |     | +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |       +-type_annotation_map={Collation:"und:binary"}
    |       |       +-Literal(type=STRING, value="Y")
    |       |       +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
        +-input_scan=
          +-ArrayScan
            +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
            +-input_scan=
            | +-WithRefScan(column_list=t.[arr1#3, arr2#4], with_query_name="t")
            +-array_expr_list=
            | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.arr1#3<{Collation:"und:ci"}>)
            | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=t.arr2#4<{Collation:"und:binary"}>)
            +-element_column_list=$array.[arr1#5, arr2#6]
            +-array_zip_mode=
              +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-t.arr1#3<{Collation:"und:ci"}> AS arr1 [ARRAY<STRING>]
| +-t.arr2#4<{Collation:"und:binary"}> AS arr2 [ARRAY<STRING>]
| +-$array.arr1#5{Collation:"und:ci"} AS arr1 [STRING]
| +-$array.arr2#6{Collation:"und:binary"} AS arr2 [STRING]
+-query=
  +-WithScan
    +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[arr1#1, arr2#2]
    |       +-expr_list=
    |       | +-arr1#1 :=
    |       | | +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       | |   +-type_annotation_map=<{Collation:"und:ci"}>
    |       | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |   | +-type_annotation_map={Collation:"und:ci"}
    |       | |   | +-Literal(type=STRING, value="A")
    |       | |   | +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       | |   +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       | |     +-type_annotation_map={Collation:"und:ci"}
    |       | |     +-Literal(type=STRING, value="b")
    |       | |     +-Literal(type=STRING, value="und:ci", preserve_in_literal_remover=TRUE)
    |       | +-arr2#2 :=
    |       |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
    |       |     +-type_annotation_map=<{Collation:"und:binary"}>
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |     | +-type_annotation_map={Collation:"und:binary"}
    |       |     | +-Literal(type=STRING, value="x")
    |       |     | +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
    |       |     +-FunctionCall(ZetaSQL:collate(STRING, STRING) -> STRING)
    |       |       +-type_annotation_map={Collation:"und:binary"}
    |       |       +-Literal(type=STRING, value="Y")
    |       |       +-Literal(type=STRING, value="und:binary", preserve_in_literal_remover=TRUE)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
        +-input_scan=
          +-ProjectScan
            +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.arr1#5{Collation:"und:ci"}, $array.arr2#6{Collation:"und:binary"}]
            +-expr_list=
            | +-arr1#5 :=
            | | +-GetStructField
            | |   +-type=STRING
            | |   +-type_annotation_map={Collation:"und:ci"}
            | |   +-expr=
            | |   | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>, column=$array.$with_expr_element#20<{Collation:"und:ci"},{Collation:"und:binary"},_>)
            | |   +-field_idx=0
            | +-arr2#6 :=
            |   +-GetStructField
            |     +-type=STRING
            |     +-type_annotation_map={Collation:"und:binary"}
            |     +-expr=
            |     | +-ColumnRef(type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>, type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>, column=$array.$with_expr_element#20<{Collation:"und:ci"},{Collation:"und:binary"},_>)
            |     +-field_idx=1
            +-input_scan=
              +-ArrayScan
                +-column_list=[t.arr1#3<{Collation:"und:ci"}>, t.arr2#4<{Collation:"und:binary"}>, $array.$with_expr_element#20<{Collation:"und:ci"},{Collation:"und:binary"},_>]
                +-input_scan=
                | +-WithRefScan(column_list=t.[arr1#3, arr2#4], with_query_name="t")
                +-array_expr_list=
                | +-WithExpr
                |   +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
                |   +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:binary"},_>>
                |   +-assignment_list=
                |   | +-arr0#7 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=t.arr1#3<{Collation:"und:ci"}>)
                |   | +-arr0_len#8 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
                |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#7<{Collation:"und:ci"}>)
                |   | |   +-Literal(type=INT64, value=0)
                |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
                |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#7<{Collation:"und:ci"}>)
                |   | +-arr1#9 := ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=t.arr2#4<{Collation:"und:binary"}>)
                |   | +-arr1_len#10 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
                |   | |   | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#9<{Collation:"und:binary"}>)
                |   | |   +-Literal(type=INT64, value=0)
                |   | |   +-FunctionCall(ZetaSQL:array_length(ARRAY<STRING>) -> INT64)
                |   | |     +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#9<{Collation:"und:binary"}>)
                |   | +-mode#11 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> ENUM<ARRAY_ZIP_MODE>)
                |   | |   +-FunctionCall(ZetaSQL:$is_null(ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   | |   | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
                |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> ENUM<ARRAY_ZIP_MODE>)
                |   | |   | +-Literal(type=STRING, value="UNNEST does not allow NULL mode argument")
                |   | |   +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=PAD)
                |   | +-strict_check#12 :=
                |   | | +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   | |   +-FunctionCall(ZetaSQL:$and(repeated(2) BOOL) -> BOOL)
                |   | |   | +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   | |   | | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#11)
                |   | |   | | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=STRICT)
                |   | |   | +-FunctionCall(ZetaSQL:$not_equal(INT64, INT64) -> BOOL)
                |   | |   |   +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
                |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#8)
                |   | |   |   | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#10)
                |   | |   |   +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
                |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr0_len#8)
                |   | |   |     +-ColumnRef(type=INT64, column=$with_expr.arr1_len#10)
                |   | |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
                |   | |   | +-Literal(type=STRING, value="Unnested arrays under STRICT mode must have equal lengths")
                |   | |   +-Literal(type=INT64, value=NULL)
                |   | +-result_len#13 :=
                |   |   +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                |   |     +-FunctionCall(ZetaSQL:$equal(ENUM<ARRAY_ZIP_MODE>, ENUM<ARRAY_ZIP_MODE>) -> BOOL)
                |   |     | +-ColumnRef(type=ENUM<ARRAY_ZIP_MODE>, column=$with_expr.mode#11)
                |   |     | +-Literal(type=ENUM<ARRAY_ZIP_MODE>, value=TRUNCATE)
                |   |     +-FunctionCall(ZetaSQL:least(repeated(2) INT64) -> INT64)
                |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr0_len#8)
                |   |     | +-ColumnRef(type=INT64, column=$with_expr.arr1_len#10)
                |   |     +-FunctionCall(ZetaSQL:greatest(repeated(2) INT64) -> INT64)
                |   |       +-ColumnRef(type=INT64, column=$with_expr.arr0_len#8)
                |   |       +-ColumnRef(type=INT64, column=$with_expr.arr1_len#10)
                |   +-expr=
                |     +-SubqueryExpr
                |       +-type=ARRAY<STRUCT<arr0 STRING, arr1 STRING, offset INT64>>
                |       +-type_annotation_map=<<{Collation:"und:ci"},{Collation:"und:binary"},_>>
                |       +-subquery_type=ARRAY
                |       +-parameter_list=
                |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:ci"}>, column=$with_expr.arr0#7<{Collation:"und:ci"}>)
                |       | +-ColumnRef(type=ARRAY<STRING>, type_annotation_map=<{Collation:"und:binary"}>, column=$with_expr.arr1#9<{Collation:"und:binary"}>)
                |       | +-ColumnRef(type=INT64, column=$with_expr.result_len#13)
                |       +-subquery=
                |         +-ProjectScan
                |           +-column_list=[$make_struct.$struct#19<{Collation:"und:ci"},{Collation:"und:binary"},_>]
                |           +-is_ordered=TRUE
                |           +-expr_list=
                |           | +-$struct#19 :=
                |           |   +-MakeStruct
                |           |     +-type=STRUCT<arr0 STRING, arr1 STRING, offset INT64>
                |           |     +-type_annotation_map=<{Collation:"und:ci"},{Collation:"und:binary"},_>
                |           |     +-field_list=
                |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:ci"}, column=$array.arr0#14{Collation:"und:ci"})
                |           |       +-ColumnRef(type=STRING, type_annotation_map={Collation:"und:binary"}, column=$array.arr1#16{Collation:"und:binary"})
                |           |       +-ColumnRef(type=INT64, column=$full_join.offset#18)
                |           +-input_scan=
                |             +-OrderByScan
                |               +-column_list=[$array.arr0#14{Collation:"und:ci"}, $array_offset.offset#15, $array.arr1#16{Collation:"und:binary"}, $array_offset.offset#17, $full_join.offset#18]
                |               +-is_ordered=TRUE
                |               +-input_scan=
                |               | +-FilterScan
                |               |   +-column_list=[$array.arr0#14{Collation:"und:ci"}, $array_offset.offset#15, $array.arr1#16{Collation:"und:binary"}, $array_offset.offset#17, $full_join.offset#18]
                |               |   +-input_scan=
                |               |   | +-ProjectScan
                |               |   |   +-column_list=[$array.arr0#14{Collation:"und:ci"}, $array_offset.offset#15, $array.arr1#16{Collation:"und:binary"}, $array_offset.offset#17, $full_join.offset#18]
                |               |   |   +-expr_list=
                |               |   |   | +-offset#18 :=
                |               |   |   |   +-FunctionCall(ZetaSQL:coalesce(repeated(2) INT64) -> INT64)
                |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#15)
                |               |   |   |     +-ColumnRef(type=INT64, column=$array_offset.offset#17)
                |               |   |   +-input_scan=
                |               |   |     +-JoinScan
                |               |   |       +-column_list=[$array.arr0#14{Collation:"und:ci"}, $array_offset.offset#15, $array.arr1#16{Collation:"und:binary"}, $array_offset.offset#17]
                |               |   |       +-join_type=FULL
                |               |   |       +-left_scan=
                |               |   |       | +-ArrayScan
                |               |   |       |   +-column_list=[$array.arr0#14{Collation:"und:ci"}, $array_offset.offset#15]
                |               |   |       |   +-array_expr_list=
                |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr0#7<{Collation:"und:ci"}>, is_correlated=TRUE)
                |               |   |       |   +-element_column_list=[$array.arr0#14{Collation:"und:ci"}]
                |               |   |       |   +-array_offset_column=
                |               |   |       |     +-ColumnHolder(column=$array_offset.offset#15)
                |               |   |       +-right_scan=
                |               |   |       | +-ArrayScan
                |               |   |       |   +-column_list=[$array.arr1#16{Collation:"und:binary"}, $array_offset.offset#17]
                |               |   |       |   +-array_expr_list=
                |               |   |       |   | +-ColumnRef(type=ARRAY<STRING>, column=$with_expr.arr1#9<{Collation:"und:binary"}>, is_correlated=TRUE)
                |               |   |       |   +-element_column_list=[$array.arr1#16{Collation:"und:binary"}]
                |               |   |       |   +-array_offset_column=
                |               |   |       |     +-ColumnHolder(column=$array_offset.offset#17)
                |               |   |       +-join_expr=
                |               |   |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#15)
                |               |   |           +-ColumnRef(type=INT64, column=$array_offset.offset#17)
                |               |   +-filter_expr=
                |               |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
                |               |       +-ColumnRef(type=INT64, column=$full_join.offset#18)
                |               |       +-ColumnRef(type=INT64, column=$with_expr.result_len#13, is_correlated=TRUE)
                |               +-order_by_item_list=
                |                 +-OrderByItem
                |                   +-column_ref=
                |                     +-ColumnRef(type=INT64, column=$full_join.offset#18)
                +-element_column_list=[$array.$with_expr_element#20<{Collation:"und:ci"},{Collation:"und:binary"},_>]
==

