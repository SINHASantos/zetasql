# This tests pipe operators on the output of a standard syntax set operation,
# where union all produces a value table. The result works as a value table, but
# pseudo-columns are still dropped.
[default language_features=NONE,+PIPES,+CORRESPONDING_FULL,+PIPE_STATIC_DESCRIBE,+BY_NAME,+ANALYTIC_FUNCTIONS]
(from TestExtraValueTable vt)
union all
(from TestExtraValueTable)
|> static_describe
|> where {{str_value is null|filename = ''}}
|> select vt, vt.str_value, *
--
ALTERNATION GROUP: str_value is null
--
QueryStmt
+-output_column_list=
| +-$union_all.vt#7 AS vt [PROTO<zetasql_test__.TestExtraPB>]
| +-$pipe_select.str_value#8 AS str_value [ARRAY<STRING>]
| +-$pipe_select.int32_val1#9 AS int32_val1 [INT32]
| +-$pipe_select.int32_val2#10 AS int32_val2 [INT32]
| +-$pipe_select.str_value#11 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.vt#7, $pipe_select.str_value#8, $pipe_select.int32_val1#9, $pipe_select.int32_val2#10, $pipe_select.str_value#11]
    +-expr_list=
    | +-str_value#8 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=str_value
    | |   +-default_value=[]
    | +-int32_val1#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#10 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#11 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[$union_all.vt#7]
        +-input_scan=
        | +-StaticDescribeScan
        |   +-column_list=[$union_all.vt#7]
        |   +-describe_text=
        |   |   """
        |   |   NameList (is_value_table = true):
        |   |     vt zetasql_test__.TestExtraPB $union_all.vt#7 (value table)
        |   |   NameScope:
        |   |     Range variables:
        |   |       vt -> RANGE_VARIABLE<$value>
        |   |     Value table columns:
        |   |       $union_all.vt#7
        |   |   """
        |   +-input_scan=
        |     +-SetOperationScan
        |       +-column_list=[$union_all.vt#7]
        |       +-op_type=UNION_ALL
        |       +-input_item_list=
        |         +-SetOperationItem
        |         | +-scan=
        |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
        |         | +-output_column_list=[TestExtraValueTable.value#1]
        |         +-SetOperationItem
        |           +-scan=
        |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
        |           +-output_column_list=[TestExtraValueTable.value#4]
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            +-GetProtoField
              +-type=ARRAY<STRING>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
              +-field_descriptor=str_value
              +-default_value=[]
--
ALTERNATION GROUP: filename = ''
--
ERROR: Unrecognized name: filename [at 5:10]
|> where filename = ''
         ^
==

# This tests pipe operators on the output of a standard syntax set operation.
# A set operation on value tables acts as value table when used as a table
# subquery.
from (
  (from TestExtraValueTable vt)
  union all
  (from TestExtraValueTable)
)
|> static_describe
|> where {{str_value|vt.str_value}} is null
--
QueryStmt
+-output_column_list=
| +-$union_all.vt#7 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[$union_all.vt#7]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=[$union_all.vt#7]
    |   +-describe_text=
    |   |   """
    |   |   NameList (is_value_table = true):
    |   |     vt zetasql_test__.TestExtraPB $union_all.vt#7 (value table)
    |   |   NameScope:
    |   |     Range variables:
    |   |       vt -> RANGE_VARIABLE<$value>
    |   |     Value table columns:
    |   |       $union_all.vt#7
    |   |   """
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=[$union_all.vt#7]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
    |         | +-output_column_list=[TestExtraValueTable.value#1]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
    |           +-output_column_list=[TestExtraValueTable.value#4]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
        +-GetProtoField
          +-type=ARRAY<STRING>
          +-expr=
          | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
          +-field_descriptor=str_value
          +-default_value=[]
==

# This tests pipe operators on the output of a standard syntax set operation.
# A set operation value table acts as value table when used as a table subquery,
# with an alias on the subquery.
[language_features=NONE,+PIPES,+GROUP_BY_STRUCT,+PIPE_STATIC_DESCRIBE]
from (
  select AS STRUCT 1 a, 2 b
  intersect all
  select AS STRUCT 3 c, 4 d
) as input
|> static_describe
|> where b = 2
|> where input.b = 2
--
QueryStmt
+-output_column_list=
| +-$intersect_all.$struct#7 AS `$value` [STRUCT<a INT64, b INT64>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[$intersect_all.$struct#7]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$intersect_all.$struct#7]
    |   +-input_scan=
    |   | +-StaticDescribeScan
    |   |   +-column_list=[$intersect_all.$struct#7]
    |   |   +-describe_text=
    |   |   |   """
    |   |   |   NameList (is_value_table = true):
    |   |   |     input STRUCT<a INT64, b INT64> $intersect_all.$struct#7 (value table)
    |   |   |   NameScope:
    |   |   |     Range variables:
    |   |   |       input -> RANGE_VARIABLE<$value>
    |   |   |     Value table columns:
    |   |   |       $intersect_all.$struct#7
    |   |   |   """
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=[$intersect_all.$struct#7]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |         +-SetOperationItem
    |   |         | +-scan=
    |   |         | | +-ProjectScan
    |   |         | |   +-column_list=[$make_struct.$struct#3]
    |   |         | |   +-expr_list=
    |   |         | |   | +-$struct#3 :=
    |   |         | |   |   +-MakeStruct
    |   |         | |   |     +-type=STRUCT<a INT64, b INT64>
    |   |         | |   |     +-field_list=
    |   |         | |   |       +-ColumnRef(type=INT64, column=$intersect_all1.a#1)
    |   |         | |   |       +-ColumnRef(type=INT64, column=$intersect_all1.b#2)
    |   |         | |   +-input_scan=
    |   |         | |     +-ProjectScan
    |   |         | |       +-column_list=$intersect_all1.[a#1, b#2]
    |   |         | |       +-expr_list=
    |   |         | |       | +-a#1 := Literal(type=INT64, value=1)
    |   |         | |       | +-b#2 := Literal(type=INT64, value=2)
    |   |         | |       +-input_scan=
    |   |         | |         +-SingleRowScan
    |   |         | +-output_column_list=[$make_struct.$struct#3]
    |   |         +-SetOperationItem
    |   |           +-scan=
    |   |           | +-ProjectScan
    |   |           |   +-column_list=[$intersect_all2_cast.$struct#8]
    |   |           |   +-expr_list=
    |   |           |   | +-$struct#8 :=
    |   |           |   |   +-Cast(STRUCT<c INT64, d INT64> -> STRUCT<a INT64, b INT64>)
    |   |           |   |     +-ColumnRef(type=STRUCT<c INT64, d INT64>, column=$make_struct.$struct#6)
    |   |           |   +-input_scan=
    |   |           |     +-ProjectScan
    |   |           |       +-column_list=[$make_struct.$struct#6]
    |   |           |       +-expr_list=
    |   |           |       | +-$struct#6 :=
    |   |           |       |   +-MakeStruct
    |   |           |       |     +-type=STRUCT<c INT64, d INT64>
    |   |           |       |     +-field_list=
    |   |           |       |       +-ColumnRef(type=INT64, column=$intersect_all2.c#4)
    |   |           |       |       +-ColumnRef(type=INT64, column=$intersect_all2.d#5)
    |   |           |       +-input_scan=
    |   |           |         +-ProjectScan
    |   |           |           +-column_list=$intersect_all2.[c#4, d#5]
    |   |           |           +-expr_list=
    |   |           |           | +-c#4 := Literal(type=INT64, value=3)
    |   |           |           | +-d#5 := Literal(type=INT64, value=4)
    |   |           |           +-input_scan=
    |   |           |             +-SingleRowScan
    |   |           +-output_column_list=[$intersect_all2_cast.$struct#8]
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |       +-GetStructField
    |       | +-type=INT64
    |       | +-expr=
    |       | | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$intersect_all.$struct#7)
    |       | +-field_idx=1
    |       +-Literal(type=INT64, value=2)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-GetStructField
        | +-type=INT64
        | +-expr=
        | | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$intersect_all.$struct#7)
        | +-field_idx=1
        +-Literal(type=INT64, value=2)
==

# This tests pipe operators on the output of a standard syntax set operation.
# This is similar to the table subquery case, but written as a parenthesized set
# operation producing a value table, without a table subquery.
(
  (from TestExtraValueTable)
  union all
  (from TestExtraValueTable)
)
|> static_describe
|> where str_value is null
|> select *
--
QueryStmt
+-output_column_list=
| +-$pipe_select.int32_val1#8 AS int32_val1 [INT32]
| +-$pipe_select.int32_val2#9 AS int32_val2 [INT32]
| +-$pipe_select.str_value#10 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$pipe_select.[int32_val1#8, int32_val2#9, str_value#10]
    +-expr_list=
    | +-int32_val1#8 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#10 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[$union_all.TestExtraValueTable#7]
        +-input_scan=
        | +-StaticDescribeScan
        |   +-column_list=[$union_all.TestExtraValueTable#7]
        |   +-describe_text=
        |   |   """
        |   |   NameList (is_value_table = true):
        |   |     TestExtraValueTable zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#7 (value table)
        |   |   NameScope:
        |   |     Range variables:
        |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |     Value table columns:
        |   |       $union_all.TestExtraValueTable#7
        |   |   """
        |   +-input_scan=
        |     +-SetOperationScan
        |       +-column_list=[$union_all.TestExtraValueTable#7]
        |       +-op_type=UNION_ALL
        |       +-input_item_list=
        |         +-SetOperationItem
        |         | +-scan=
        |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |         | +-output_column_list=[TestExtraValueTable.value#1]
        |         +-SetOperationItem
        |           +-scan=
        |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
        |           +-output_column_list=[TestExtraValueTable.value#4]
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            +-GetProtoField
              +-type=ARRAY<STRING>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
              +-field_descriptor=str_value
              +-default_value=[]
==

# Similar to previous test cases, but test pipe set operations rather than
# standard set operations.
# Test UNION ALL producing a value table.
# The result works as a value table, but pseudo-columns are still dropped.
(from TestExtraValueTable vt)
|> union all
(from TestExtraValueTable)
|> static_describe
|> where {{str_value is null|filename = ''}}
|> select vt, vt.str_value, *
--
ALTERNATION GROUP: str_value is null
--
QueryStmt
+-output_column_list=
| +-$union_all.vt#7 AS vt [PROTO<zetasql_test__.TestExtraPB>]
| +-$pipe_select.str_value#8 AS str_value [ARRAY<STRING>]
| +-$pipe_select.int32_val1#9 AS int32_val1 [INT32]
| +-$pipe_select.int32_val2#10 AS int32_val2 [INT32]
| +-$pipe_select.str_value#11 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.vt#7, $pipe_select.str_value#8, $pipe_select.int32_val1#9, $pipe_select.int32_val2#10, $pipe_select.str_value#11]
    +-expr_list=
    | +-str_value#8 :=
    | | +-GetProtoField
    | |   +-type=ARRAY<STRING>
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=str_value
    | |   +-default_value=[]
    | +-int32_val1#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#10 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#11 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[$union_all.vt#7]
        +-input_scan=
        | +-StaticDescribeScan
        |   +-column_list=[$union_all.vt#7]
        |   +-describe_text=
        |   |   """
        |   |   NameList (is_value_table = true):
        |   |     vt zetasql_test__.TestExtraPB $union_all.vt#7 (value table)
        |   |   NameScope:
        |   |     Range variables:
        |   |       vt -> RANGE_VARIABLE<$value>
        |   |     Value table columns:
        |   |       $union_all.vt#7
        |   |   """
        |   +-input_scan=
        |     +-SetOperationScan
        |       +-column_list=[$union_all.vt#7]
        |       +-op_type=UNION_ALL
        |       +-input_item_list=
        |         +-SetOperationItem
        |         | +-scan=
        |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
        |         | +-output_column_list=[TestExtraValueTable.value#1]
        |         +-SetOperationItem
        |           +-scan=
        |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
        |           +-output_column_list=[TestExtraValueTable.value#4]
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            +-GetProtoField
              +-type=ARRAY<STRING>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
              +-field_descriptor=str_value
              +-default_value=[]
--
ALTERNATION GROUP: filename = ''
--
ERROR: Unrecognized name: filename [at 5:10]
|> where filename = ''
         ^
==

# A set operation on value tables acts as value table when used as a table
# subquery.
from (
  (from TestExtraValueTable vt)
  |> union all
  (from TestExtraValueTable)
)
|> static_describe
|> where {{str_value|vt.str_value}} is null
--
QueryStmt
+-output_column_list=
| +-$union_all.vt#7 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[$union_all.vt#7]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=[$union_all.vt#7]
    |   +-describe_text=
    |   |   """
    |   |   NameList (is_value_table = true):
    |   |     vt zetasql_test__.TestExtraPB $union_all.vt#7 (value table)
    |   |   NameScope:
    |   |     Range variables:
    |   |       vt -> RANGE_VARIABLE<$value>
    |   |     Value table columns:
    |   |       $union_all.vt#7
    |   |   """
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=[$union_all.vt#7]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
    |         | +-output_column_list=[TestExtraValueTable.value#1]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
    |           +-output_column_list=[TestExtraValueTable.value#4]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
        +-GetProtoField
          +-type=ARRAY<STRING>
          +-expr=
          | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.vt#7)
          +-field_descriptor=str_value
          +-default_value=[]
==

# A set operation value table acts as value table when used as a table subquery,
# with an alias on the subquery.
[language_features=NONE,+PIPES,+GROUP_BY_STRUCT,+PIPE_STATIC_DESCRIBE]
from (
  select AS STRUCT 1 a, 2 b
  |> intersect all (select AS STRUCT 3 c, 4 d)
) as input
|> static_describe
|> where b = 2
|> where input.b = 2
--
QueryStmt
+-output_column_list=
| +-$intersect_all.$struct#7 AS `$value` [STRUCT<a INT64, b INT64>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[$intersect_all.$struct#7]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$intersect_all.$struct#7]
    |   +-input_scan=
    |   | +-StaticDescribeScan
    |   |   +-column_list=[$intersect_all.$struct#7]
    |   |   +-describe_text=
    |   |   |   """
    |   |   |   NameList (is_value_table = true):
    |   |   |     input STRUCT<a INT64, b INT64> $intersect_all.$struct#7 (value table)
    |   |   |   NameScope:
    |   |   |     Range variables:
    |   |   |       input -> RANGE_VARIABLE<$value>
    |   |   |     Value table columns:
    |   |   |       $intersect_all.$struct#7
    |   |   |   """
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=[$intersect_all.$struct#7]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |         +-SetOperationItem
    |   |         | +-scan=
    |   |         | | +-ProjectScan
    |   |         | |   +-column_list=[$make_struct.$struct#3]
    |   |         | |   +-expr_list=
    |   |         | |   | +-$struct#3 :=
    |   |         | |   |   +-MakeStruct
    |   |         | |   |     +-type=STRUCT<a INT64, b INT64>
    |   |         | |   |     +-field_list=
    |   |         | |   |       +-ColumnRef(type=INT64, column=input.a#1)
    |   |         | |   |       +-ColumnRef(type=INT64, column=input.b#2)
    |   |         | |   +-input_scan=
    |   |         | |     +-ProjectScan
    |   |         | |       +-column_list=input.[a#1, b#2]
    |   |         | |       +-expr_list=
    |   |         | |       | +-a#1 := Literal(type=INT64, value=1)
    |   |         | |       | +-b#2 := Literal(type=INT64, value=2)
    |   |         | |       +-input_scan=
    |   |         | |         +-SingleRowScan
    |   |         | +-output_column_list=[$make_struct.$struct#3]
    |   |         +-SetOperationItem
    |   |           +-scan=
    |   |           | +-ProjectScan
    |   |           |   +-column_list=[$intersect_all2_cast.$struct#8]
    |   |           |   +-expr_list=
    |   |           |   | +-$struct#8 :=
    |   |           |   |   +-Cast(STRUCT<c INT64, d INT64> -> STRUCT<a INT64, b INT64>)
    |   |           |   |     +-ColumnRef(type=STRUCT<c INT64, d INT64>, column=$make_struct.$struct#6)
    |   |           |   +-input_scan=
    |   |           |     +-ProjectScan
    |   |           |       +-column_list=[$make_struct.$struct#6]
    |   |           |       +-expr_list=
    |   |           |       | +-$struct#6 :=
    |   |           |       |   +-MakeStruct
    |   |           |       |     +-type=STRUCT<c INT64, d INT64>
    |   |           |       |     +-field_list=
    |   |           |       |       +-ColumnRef(type=INT64, column=$intersect_all1.c#4)
    |   |           |       |       +-ColumnRef(type=INT64, column=$intersect_all1.d#5)
    |   |           |       +-input_scan=
    |   |           |         +-ProjectScan
    |   |           |           +-column_list=$intersect_all1.[c#4, d#5]
    |   |           |           +-expr_list=
    |   |           |           | +-c#4 := Literal(type=INT64, value=3)
    |   |           |           | +-d#5 := Literal(type=INT64, value=4)
    |   |           |           +-input_scan=
    |   |           |             +-SingleRowScan
    |   |           +-output_column_list=[$intersect_all2_cast.$struct#8]
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |       +-GetStructField
    |       | +-type=INT64
    |       | +-expr=
    |       | | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$intersect_all.$struct#7)
    |       | +-field_idx=1
    |       +-Literal(type=INT64, value=2)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-GetStructField
        | +-type=INT64
        | +-expr=
        | | +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$intersect_all.$struct#7)
        | +-field_idx=1
        +-Literal(type=INT64, value=2)
==

# This is similar to the table subquery case, but written as a parenthesized set
# operation producing a value table, without a table subquery.
(
  (from TestExtraValueTable)
  |> union all
  (from TestExtraValueTable)
)
|> static_describe
|> where str_value is null
|> select *
--
QueryStmt
+-output_column_list=
| +-$pipe_select.int32_val1#8 AS int32_val1 [INT32]
| +-$pipe_select.int32_val2#9 AS int32_val2 [INT32]
| +-$pipe_select.str_value#10 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$pipe_select.[int32_val1#8, int32_val2#9, str_value#10]
    +-expr_list=
    | +-int32_val1#8 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#9 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#10 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-FilterScan
        +-column_list=[$union_all.TestExtraValueTable#7]
        +-input_scan=
        | +-StaticDescribeScan
        |   +-column_list=[$union_all.TestExtraValueTable#7]
        |   +-describe_text=
        |   |   """
        |   |   NameList (is_value_table = true):
        |   |     TestExtraValueTable zetasql_test__.TestExtraPB $union_all.TestExtraValueTable#7 (value table)
        |   |   NameScope:
        |   |     Range variables:
        |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
        |   |     Value table columns:
        |   |       $union_all.TestExtraValueTable#7
        |   |   """
        |   +-input_scan=
        |     +-SetOperationScan
        |       +-column_list=[$union_all.TestExtraValueTable#7]
        |       +-op_type=UNION_ALL
        |       +-input_item_list=
        |         +-SetOperationItem
        |         | +-scan=
        |         | | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        |         | +-output_column_list=[TestExtraValueTable.value#1]
        |         +-SetOperationItem
        |           +-scan=
        |           | +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
        |           +-output_column_list=[TestExtraValueTable.value#4]
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$is_null(ARRAY<STRING>) -> BOOL)
            +-GetProtoField
              +-type=ARRAY<STRING>
              +-expr=
              | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=$union_all.TestExtraValueTable#7)
              +-field_descriptor=str_value
              +-default_value=[]
==

# Range variables are not available after pipe set operations.
from KeyValue as T1 join KeyValue as T2 using (key)
|> intersect distinct (from KeyValue AS T3 join KeyValue AS T4 using (key))
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.key#9 AS key [INT64]
| +-$intersect_distinct.Value#10 AS Value [STRING]
| +-$intersect_distinct.Value#11 AS Value [STRING]
+-query=
  +-StaticDescribeScan
    +-column_list=$intersect_distinct.[key#9, Value#10, Value#11]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT64 $intersect_distinct.key#9
    |     Value STRING $intersect_distinct.Value#10
    |     Value STRING $intersect_distinct.Value#11
    |   NameScope:
    |     Names:
    |       Value -> ambiguous
    |       key -> INT64 ($intersect_distinct.key#9)
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=$intersect_distinct.[key#9, Value#10, Value#11]
        +-op_type=INTERSECT_DISTINCT
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-JoinScan
          | |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
          | |   +-left_scan=
          | |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="T1")
          | |   +-right_scan=
          | |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="T2")
          | |   +-join_expr=
          | |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
          | |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#3)
          | |   +-has_using=TRUE
          | +-output_column_list=KeyValue.[Key#1, Value#2, Value#4]
          +-SetOperationItem
            +-scan=
            | +-JoinScan
            |   +-column_list=KeyValue.[Key#5, Value#6, Key#7, Value#8]
            |   +-left_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1], alias="T3")
            |   +-right_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#7, Value#8], table=KeyValue, column_index_list=[0, 1], alias="T4")
            |   +-join_expr=
            |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#5)
            |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#7)
            |   +-has_using=TRUE
            +-output_column_list=KeyValue.[Key#5, Value#6, Value#8]
==

(from TestTable)
|> intersect all (from TestTable)
--
ERROR: Column 3 in INTERSECT ALL has type that does not support set operation comparisons: PROTO [at 2:19]
|> intersect all (from TestTable)
                  ^
==

# Multiple inputs for pipe set operations
from keyvalue
|> union all (from keyvalue), (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$union_all.Key#7 AS Key [INT64]
| +-$union_all.Value#8 AS Value [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[Key#7, Value#8]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
      | +-output_column_list=KeyValue.[Key#1, Value#2]
      +-SetOperationItem
      | +-scan=
      | | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
      | +-output_column_list=KeyValue.[Key#3, Value#4]
      +-SetOperationItem
        +-scan=
        | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=KeyValue.[Key#5, Value#6]
==

# Different number of columns
from keyvalue
|> union distinct (select *, 1 from keyvalue)
--
ERROR: Queries in UNION DISTINCT have mismatched column count; pipe input table has 2 columns, pipe argument query 1 has 3 columns [at 2:20]
|> union distinct (select *, 1 from keyvalue)
                   ^
==

# Incompatible column types
from keyvalue
|> intersect distinct (select 1, 1)
--
ERROR: Column 2 in INTERSECT DISTINCT has incompatible types: STRING, INT64 [at 2:24]
|> intersect distinct (select 1, 1)
                       ^
==

# Type coercions
from keyvalue
|> intersect all (select 1.0, "string")
--
QueryStmt
+-output_column_list=
| +-$intersect_all.Key#5 AS Key [DOUBLE]
| +-$intersect_all.Value#6 AS Value [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[Key#5, Value#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$intersect_all1_cast.Key#7, KeyValue.Value#2]
      | |   +-expr_list=
      | |   | +-Key#7 :=
      | |   |   +-Cast(INT64 -> DOUBLE)
      | |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      | |   +-input_scan=
      | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
      | +-output_column_list=[$intersect_all1_cast.Key#7, KeyValue.Value#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=$intersect_all1.[$col1#3, $col2#4]
        |   +-expr_list=
        |   | +-$col1#3 := Literal(type=DOUBLE, value=1)
        |   | +-$col2#4 := Literal(type=STRING, value="string")
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=$intersect_all1.[$col1#3, $col2#4]
==

# Type coercions
select 1.0, "string"
|> intersect all (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$intersect_all.$col1#5 AS `$col1` [DOUBLE]
| +-$intersect_all.$col2#6 AS `$col2` [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[$col1#5, $col2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=$query.[$col1#1, $col2#2]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=DOUBLE, value=1)
      | |   | +-$col2#2 := Literal(type=STRING, value="string")
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=$query.[$col1#1, $col2#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$intersect_all2_cast.Key#7, KeyValue.Value#4]
        |   +-expr_list=
        |   | +-Key#7 :=
        |   |   +-Cast(INT64 -> DOUBLE)
        |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#3)
        |   +-input_scan=
        |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=[$intersect_all2_cast.Key#7, KeyValue.Value#4]
==

# Multiple inputs with corresponding
from (select 1 as a, 2 as b, 3 as c)
|> {{intersect distinct corresponding|inner intersect distinct by name}}
  (select 1 AS a, 2 as b),
  (select 2 as b, 3 as c)
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_distinct.b#8]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$subquery1.b#2]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$subquery1.[a#1, b#2, c#3]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |       | +-b#2 := Literal(type=INT64, value=2)
    | | |       | +-c#3 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$subquery1.b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$intersect_distinct1.b#5]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$intersect_distinct1.[a#4, b#5]
    | | |       +-expr_list=
    | | |       | +-a#4 := Literal(type=INT64, value=1)
    | | |       | +-b#5 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$intersect_distinct1.b#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_distinct2.b#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_distinct2.[b#6, c#7]
    |   |       +-expr_list=
    |   |       | +-b#6 := Literal(type=INT64, value=2)
    |   |       | +-c#7 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$intersect_distinct2.b#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# No common columns
from keyvalue
|> {{except all corresponding|inner except all by name}} (select 1 as a)
--
ALTERNATION GROUP: except all corresponding
--
ERROR: Queries of the set operation using CORRESPONDING do not have any columns in common [at 2:4]
|> except all corresponding (select 1 as a)
   ^
--
ALTERNATION GROUP: inner except all by name
--
ERROR: Queries of the set operation using BY NAME do not have any columns in common [at 2:10]
|> inner except all by name (select 1 as a)
         ^
==

# Anonymous columns in pipe input table
select 1
|> {{except distinct corresponding|inner except distinct by name}} (from keyvalue)
--
ALTERNATION GROUP: except distinct corresponding
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: pipe input table, column 1 [at 2:1]
|> except distinct corresponding (from keyvalue)
^
--
ALTERNATION GROUP: inner except distinct by name
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: pipe input table, column 1 [at 2:1]
|> inner except distinct by name (from keyvalue)
^
==

# Anonymous columns in pipe argument query
from keyvalue
|> {{except distinct corresponding|inner except distinct by name}} (select 1)
--
ALTERNATION GROUP: except distinct corresponding
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: pipe argument query 1, column 1 [at 2:35]
|> except distinct corresponding (select 1)
                                  ^
--
ALTERNATION GROUP: inner except distinct by name
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: pipe argument query 1, column 1 [at 2:35]
|> inner except distinct by name (select 1)
                                  ^
==

# Multiple inputs with left corresponding
from keyvalue
|> select key
|> left intersect all {{corresponding|by name}}
  (from keyvalue),
  (from keyvalue |> extend 1 as additional)
--
QueryStmt
+-output_column_list=
| +-$intersect_all.key#8 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_all.key#8]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    | | +-output_column_list=[KeyValue.Key#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[KeyValue.Key#5, KeyValue.Value#6, $pipe_extend.additional#7]
    |   |       +-expr_list=
    |   |       | +-additional#7 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=[KeyValue.Key#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# No common columns
from keyvalue
|> left except all {{corresponding|by name}} (select 1 as a)
--
ALTERNATION GROUP: corresponding
--
ERROR: Pipe argument query 1 of the set operation with LEFT mode does not share any common columns with pipe input table [at 2:9]
|> left except all corresponding (select 1 as a)
        ^
--
ALTERNATION GROUP: by name
--
ERROR: Pipe argument query 1 of the set operation with LEFT mode does not share any common columns with pipe input table [at 2:9]
|> left except all by name (select 1 as a)
        ^
==

# Multiple inputs with full corresponding
select 1 as a
|> full intersect distinct {{corresponding|by name}}
      (select 2 as b), (select 3 as c)
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.a#4 AS a [INT64]
| +-$intersect_distinct.b#5 AS b [INT64]
| +-$intersect_distinct.c#6 AS c [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[a#4, b#5, c#6]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.a#1, $null_column_for_outer_set_op.b#7, $null_column_for_outer_set_op.c#8]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#7 := Literal(type=INT64, value=NULL)
    | | |   | +-c#8 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$query.a#1]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$query.a#1, $null_column_for_outer_set_op.b#7, $null_column_for_outer_set_op.c#8]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#9, $intersect_distinct1.b#2, $null_column_for_outer_set_op.c#10]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#9 := Literal(type=INT64, value=NULL)
    | | |   | +-c#10 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_distinct1.b#2]
    | | |       +-expr_list=
    | | |       | +-b#2 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$null_column_for_outer_set_op.a#9, $intersect_distinct1.b#2, $null_column_for_outer_set_op.c#10]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#11, $null_column_for_outer_set_op.b#12, $intersect_distinct2.c#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#11 := Literal(type=INT64, value=NULL)
    |   |   | +-b#12 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$intersect_distinct2.c#3]
    |   |       +-expr_list=
    |   |       | +-c#3 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#11, $null_column_for_outer_set_op.b#12, $intersect_distinct2.c#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Full corresponding has common columns
from keyvalue
|> full except all {{corresponding|by name}}
  (from keyvalue |> extend 1 as additional_1)
|> full except distinct {{corresponding|by name}}
  (from keyvalue |> extend 2 as additional_2)
--
QueryStmt
+-output_column_list=
| +-$except_distinct.Key#13 AS Key [INT64]
| +-$except_distinct.Value#14 AS Value [STRING]
| +-$except_distinct.additional_1#15 AS additional_1 [INT64]
| +-$except_distinct.additional_2#16 AS additional_2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[Key#13, Value#14, additional_1#15, additional_2#16]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$except_all.Key#6, $except_all.Value#7, $except_all.additional_1#8, $null_column_for_outer_set_op.additional_2#17]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-additional_2#17 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$except_all.[Key#6, Value#7, additional_1#8]
    | | |       +-op_type=EXCEPT_ALL
    | | |       +-input_item_list=
    | | |       | +-SetOperationItem
    | | |       | | +-scan=
    | | |       | | | +-ProjectScan
    | | |       | | |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $null_column_for_outer_set_op.additional_1#9]
    | | |       | | |   +-node_source="resolver_set_operation_corresponding"
    | | |       | | |   +-expr_list=
    | | |       | | |   | +-additional_1#9 := Literal(type=INT64, value=NULL)
    | | |       | | |   +-input_scan=
    | | |       | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | |       | | +-output_column_list=[KeyValue.Key#1, KeyValue.Value#2, $null_column_for_outer_set_op.additional_1#9]
    | | |       | +-SetOperationItem
    | | |       |   +-scan=
    | | |       |   | +-ProjectScan
    | | |       |   |   +-column_list=[KeyValue.Key#3, KeyValue.Value#4, $pipe_extend.additional_1#5]
    | | |       |   |   +-expr_list=
    | | |       |   |   | +-additional_1#5 := Literal(type=INT64, value=1)
    | | |       |   |   +-input_scan=
    | | |       |   |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | |       |   +-output_column_list=[KeyValue.Key#3, KeyValue.Value#4, $pipe_extend.additional_1#5]
    | | |       +-column_match_mode=CORRESPONDING
    | | |       +-column_propagation_mode=FULL
    | | +-output_column_list=[$except_all.Key#6, $except_all.Value#7, $except_all.additional_1#8, $null_column_for_outer_set_op.additional_2#17]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#10, KeyValue.Value#11, $null_column_for_outer_set_op.additional_1#18, $pipe_extend.additional_2#12]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-additional_1#18 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[KeyValue.Key#10, KeyValue.Value#11, $pipe_extend.additional_2#12]
    |   |       +-expr_list=
    |   |       | +-additional_2#12 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=KeyValue.[Key#10, Value#11], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=[KeyValue.Key#10, KeyValue.Value#11, $null_column_for_outer_set_op.additional_1#18, $pipe_extend.additional_2#12]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Type coercions
select cast(1 as int32) AS a
|> full union distinct {{corresponding|by name}}
  (select cast(1 as float) as a),
  (select cast(1 as int64) as b)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.a#4 AS a [DOUBLE]
| +-$union_distinct.b#5 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[a#4, b#5]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_distinct1_cast.a#6, $null_column_for_outer_set_op.b#8]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#8 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_distinct1_cast.a#6]
    | | |       +-expr_list=
    | | |       | +-a#6 := Literal(type=DOUBLE, value=1, has_explicit_type=TRUE)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[$query.a#1]
    | | |           +-expr_list=
    | | |           | +-a#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_distinct1_cast.a#6, $null_column_for_outer_set_op.b#8]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_distinct2_cast.a#7, $null_column_for_outer_set_op.b#9]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#9 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_distinct2_cast.a#7]
    | | |       +-expr_list=
    | | |       | +-a#7 := Literal(type=DOUBLE, value=1, has_explicit_type=TRUE)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[$union_distinct1.a#2]
    | | |           +-expr_list=
    | | |           | +-a#2 := Literal(type=FLOAT, value=1, has_explicit_type=TRUE)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_distinct2_cast.a#7, $null_column_for_outer_set_op.b#9]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#10, $union_distinct2.b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#10 := Literal(type=DOUBLE, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_distinct2.b#3]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#10, $union_distinct2.b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercions
select cast(1 as int64), 1, cast("string" as string)
|> except all (from keyvalue |> select key, key, value)
--
QueryStmt
+-output_column_list=
| +-$except_all.$col1#6 AS `$col1` [INT64]
| +-$except_all.$col2#7 AS `$col2` [INT64]
| +-$except_all.$col3#8 AS `$col3` [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$except_all.[$col1#6, $col2#7, $col3#8]
    +-op_type=EXCEPT_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=$query.[$col1#1, $col2#2, $col3#3]
      | |   +-expr_list=
      | |   | +-$col1#1 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
      | |   | +-$col2#2 := Literal(type=INT64, value=1)
      | |   | +-$col3#3 := Literal(type=STRING, value="string", has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-SingleRowScan
      | +-output_column_list=$query.[$col1#1, $col2#2, $col3#3]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=KeyValue.[Key#4, Key#4, Value#5]
        |   +-input_scan=
        |     +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=KeyValue.[Key#4, Key#4, Value#5]
==

# NULL literal coercions
select null, null
|> intersect distinct (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.$col1#5 AS `$col1` [INT64]
| +-$intersect_distinct.$col2#6 AS `$col2` [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[$col1#5, $col2#6]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$query.$col1#1, $intersect_distinct1_cast.$col2#7]
      | |   +-expr_list=
      | |   | +-$col2#7 := Literal(type=STRING, value=NULL)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=$query.[$col1#1, $col2#2]
      | |       +-expr_list=
      | |       | +-$col1#1 := Literal(type=INT64, value=NULL)
      | |       | +-$col2#2 := Literal(type=INT64, value=NULL)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$query.$col1#1, $intersect_distinct1_cast.$col2#7]
      +-SetOperationItem
        +-scan=
        | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=KeyValue.[Key#3, Value#4]
==

# NULL literal coercions
from keyvalue
|> intersect distinct (select null, null)
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.Key#5 AS Key [INT64]
| +-$intersect_distinct.Value#6 AS Value [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[Key#5, Value#6]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
      | +-output_column_list=KeyValue.[Key#1, Value#2]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$intersect_distinct1.$col1#3, $intersect_distinct2_cast.$col2#7]
        |   +-expr_list=
        |   | +-$col2#7 := Literal(type=STRING, value=NULL)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=$intersect_distinct1.[$col1#3, $col2#4]
        |       +-expr_list=
        |       | +-$col1#3 := Literal(type=INT64, value=NULL)
        |       | +-$col2#4 := Literal(type=INT64, value=NULL)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$intersect_distinct1.$col1#3, $intersect_distinct2_cast.$col2#7]
==

# NULL literal coercions don't work unless the NULL is projected immediately
# before the set operation.  This is similar to selecting NULL in a subquery,
# which also doesn't handle untyped NULLs.
select null, null
|> where true
|> union all (from keyvalue)
--
ERROR: Column 2 in UNION ALL has incompatible types: INT64, STRING [at 3:15]
|> union all (from keyvalue)
              ^
==

# NULL literal coercion also works with NULLs added by EXTEND.
select 5
|> extend null
|> union all (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#5 AS `$col1` [INT64]
| +-$union_all.$col1#6 AS `$col1` [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[$col1#5, $col1#6]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$query.$col1#1, $union_all1_cast.$col1#7]
      | |   +-expr_list=
      | |   | +-$col1#7 := Literal(type=STRING, value=NULL)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$query.$col1#1, $pipe_extend.$col1#2]
      | |       +-expr_list=
      | |       | +-$col1#2 := Literal(type=INT64, value=NULL)
      | |       +-input_scan=
      | |         +-ProjectScan
      | |           +-column_list=[$query.$col1#1]
      | |           +-expr_list=
      | |           | +-$col1#1 := Literal(type=INT64, value=5)
      | |           +-input_scan=
      | |             +-SingleRowScan
      | +-output_column_list=[$query.$col1#1, $union_all1_cast.$col1#7]
      +-SetOperationItem
        +-scan=
        | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
        +-output_column_list=KeyValue.[Key#3, Value#4]
==

# NULL literal coercion doesn't work here, where the EXTEND has a
# window function, because it sees a ResolvedAnalyticScan rather than
# a ResolvedProjectScan as the input to UNION.
select 5
|> extend null, count(*) OVER ()
|> union all (from keyvalue |> extend 10)
--
ERROR: Column 2 in UNION ALL has incompatible types: INT64, STRING [at 3:15]
|> union all (from keyvalue |> extend 10)
              ^
==

# Multiple inputs with strict corresponding
from keyvalue |> select value, key
|> except distinct {{strict corresponding|by name}} (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$except_distinct.value#5 AS value [STRING]
| +-$except_distinct.key#6 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[value#5, key#6]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=KeyValue.[Value#2, Key#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=KeyValue.[Value#2, Key#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=KeyValue.[Value#4, Key#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Value#4, Key#3]
    +-column_match_mode=CORRESPONDING
==

# Different sets of columns: argument query has more columns.
from keyvalue
|> intersect all {{strict corresponding|by name}}
  (from keyvalue),
  (from keyvalue |> extend 1 as additional_column)
--
ALTERNATION GROUP: strict corresponding
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but pipe input table has [Key, Value] and pipe argument query 2 has [Key, Value, additional_column] [at 2:4]
|> intersect all strict corresponding
   ^
--
ALTERNATION GROUP: by name
--
ERROR: BY NAME requires all input queries to have identical column names, but pipe input table has [Key, Value] and pipe argument query 2 has [Key, Value, additional_column] [at 2:4]
|> intersect all by name
   ^
==

# Different sets of columns: input table has more columns.
from keyvalue |> extend 1 as additional_column
|> intersect all {{strict corresponding|by name}} (from keyvalue)
--
ALTERNATION GROUP: strict corresponding
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but pipe input table has [Key, Value, additional_column] and pipe argument query 1 has [Key, Value] [at 2:4]
|> intersect all strict corresponding (from keyvalue)
   ^
--
ALTERNATION GROUP: by name
--
ERROR: BY NAME requires all input queries to have identical column names, but pipe input table has [Key, Value, additional_column] and pipe argument query 1 has [Key, Value] [at 2:4]
|> intersect all by name (from keyvalue)
   ^
==

# Multiple inputs for corresponding by
from keyvalue
|> {{union distinct corresponding by|inner union distinct by name on}} (key)
  (from keyvalue),
  (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.key#7 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_distinct.key#7]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=[KeyValue.Key#5]
    +-column_match_mode=CORRESPONDING_BY
    +-column_propagation_mode=INNER
==

# A corresponding column is not present in the pipe input table.
from keyvalue
|> {{union all corresponding by|inner union all by name on}} (key, a)
     (from keyvalue |> extend 1 as a)
--
ALTERNATION GROUP: union all corresponding by
--
ERROR: The column name a from the CORRESPONDING BY list does not appear in pipe input table. All columns in the BY list must appear in each input query unless FULL CORRESPONDING or LEFT CORRESPONDING is specified [at 2:37]
|> union all corresponding by (key, a)
                                    ^
--
ALTERNATION GROUP: inner union all by name on
--
ERROR: The column name a from the BY NAME ON list does not appear in pipe input table. All columns in the ON list must appear in each input query unless FULL BY NAME or LEFT BY NAME is specified [at 2:37]
|> inner union all by name on (key, a)
                                    ^
==

# A corresponding column is not present in an argument query.
from keyvalue |> extend 1 as a
|> {{union distinct corresponding by|inner union all by name on}}
    (key, a) (from keyvalue)
--
ALTERNATION GROUP: union distinct corresponding by
--
ERROR: The column name a from the CORRESPONDING BY list does not appear in pipe argument query 1. All columns in the BY list must appear in each input query unless FULL CORRESPONDING or LEFT CORRESPONDING is specified [at 3:11]
    (key, a) (from keyvalue)
          ^
--
ALTERNATION GROUP: inner union all by name on
--
ERROR: The column name a from the BY NAME ON list does not appear in pipe argument query 1. All columns in the ON list must appear in each input query unless FULL BY NAME or LEFT BY NAME is specified [at 3:11]
    (key, a) (from keyvalue)
          ^
==

# Multiple inputs for left corresponding by
from keyvalue
|> left intersect distinct {{corresponding by|by name on}} (key)
  (from keyvalue),
  (from keyvalue)
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.key#7 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$intersect_distinct.key#7]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=[KeyValue.Key#5]
    +-column_match_mode=CORRESPONDING_BY
    +-column_propagation_mode=LEFT
==

# Left corresponding by column not present in one input
from keyvalue
|> left union distinct {{corresponding by|by name on}} (key)
  (from keyvalue |> select key),
  (from keyvalue |> select value)
--
QueryStmt
+-output_column_list=
| +-$union_distinct.key#7 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_distinct.key#7]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#3]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0])
    | | +-output_column_list=[KeyValue.Key#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.key#8]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-key#8 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[KeyValue.Value#6]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
    |   +-output_column_list=[$null_column_for_outer_set_op.key#8]
    +-column_match_mode=CORRESPONDING_BY
    +-column_propagation_mode=LEFT
==

# Left corresponding by column not present in the pipe input table.
from keyvalue |> select value
|> left union all {{corresponding by|by name on}} (key)
  (from keyvalue)
--
ALTERNATION GROUP: corresponding by
--
ERROR: The column name 'key' from the LEFT CORRESPONDING BY list must appear in pipe input table [at 2:37]
|> left union all corresponding by (key)
                                    ^
--
ALTERNATION GROUP: by name on
--
ERROR: The column name 'key' from the LEFT BY NAME ON list must appear in pipe input table [at 2:31]
|> left union all by name on (key)
                              ^
==

# Multiple inputs for full corresponding by
from keyvalue
|> full union all {{corresponding by|by name on}} (key, a, b)
  (from keyvalue |> extend 1 as a),
  (from keyvalue |> extend 2 as b)
--
QueryStmt
+-output_column_list=
| +-$union_all.key#9 AS key [INT64]
| +-$union_all.a#10 AS a [INT64]
| +-$union_all.b#11 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[key#9, a#10, b#11]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#1, $null_column_for_outer_set_op.a#12, $null_column_for_outer_set_op.b#13]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#12 := Literal(type=INT64, value=NULL)
    | | |   | +-b#13 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#1, $null_column_for_outer_set_op.a#12, $null_column_for_outer_set_op.b#13]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[KeyValue.Key#3, $pipe_extend.a#5, $null_column_for_outer_set_op.b#14]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#14 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[KeyValue.Key#3, KeyValue.Value#4, $pipe_extend.a#5]
    | | |       +-expr_list=
    | | |       | +-a#5 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=[KeyValue.Key#3, $pipe_extend.a#5, $null_column_for_outer_set_op.b#14]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#6, $null_column_for_outer_set_op.a#15, $pipe_extend.b#8]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#15 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[KeyValue.Key#6, KeyValue.Value#7, $pipe_extend.b#8]
    |   |       +-expr_list=
    |   |       | +-b#8 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=KeyValue.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=[KeyValue.Key#6, $null_column_for_outer_set_op.a#15, $pipe_extend.b#8]
    +-column_match_mode=CORRESPONDING_BY
    +-column_propagation_mode=FULL
==

# Full corresponding by list contains all columns
select 1 as a
|> full intersect all {{corresponding by|by name on}} (a, b)
  (select 2 as b)
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#3 AS a [INT64]
| +-$intersect_all.b#4 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#3, b#4]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.a#1, $null_column_for_outer_set_op.b#5]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#5 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$query.a#1]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$query.a#1, $null_column_for_outer_set_op.b#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#6, $intersect_all1.b#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$intersect_all1.b#2]
    |   |       +-expr_list=
    |   |       | +-b#2 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#6, $intersect_all1.b#2]
    +-column_match_mode=CORRESPONDING_BY
    +-column_propagation_mode=FULL
==

# FULL corresponding by list contains an extra column
select 1 as a
|> full union all {{corresponding by|by name on}} (a, b, c)
  (select 1 as b)
--
ALTERNATION GROUP: corresponding by
--
ERROR: The column name c from the CORRESPONDING BY list does not appear in any input queries. [at 2:43]
|> full union all corresponding by (a, b, c)
                                          ^
--
ALTERNATION GROUP: by name on
--
ERROR: The column name c from the BY NAME ON list does not appear in any input queries. [at 2:37]
|> full union all by name on (a, b, c)
                                    ^
==

# Multiple inputs for strict corresponding by
from keyvalue
|> except all {{strict corresponding by|by name on}} (value, key)
  (from keyvalue),
  (from keyvalue |> select value, key)
--
QueryStmt
+-output_column_list=
| +-$except_all.value#7 AS value [STRING]
| +-$except_all.key#8 AS key [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_all.[value#7, key#8]
    +-op_type=EXCEPT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=KeyValue.[Value#2, Key#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=KeyValue.[Value#2, Key#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=KeyValue.[Value#4, Key#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=KeyValue.[Value#4, Key#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=KeyValue.[Value#6, Key#5]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Value#6, Key#5]
    +-column_match_mode=CORRESPONDING_BY
==

# strict corresponding by list missing columns
from keyvalue
|> union all {{strict corresponding by|by name on}} (key)
  (from keyvalue)
--
ALTERNATION GROUP: strict corresponding by
--
ERROR: Pipe input table must share the same set of column names as the BY list when using STRICT CORRESPONDING BY [at 2:1]
|> union all strict corresponding by (key)
^
--
ALTERNATION GROUP: by name on
--
ERROR: Pipe input table must share the same set of column names as the ON list when using BY NAME ON [at 2:1]
|> union all by name on (key)
^
==

# strict corresponding by list extra columns
from keyvalue |> extend 1 as a
|> union all {{strict corresponding by|by name on}} (key, value, a)
  (from keyvalue)
--
ALTERNATION GROUP: strict corresponding by
--
ERROR: Pipe argument query 1 must share the same set of column names as the BY list when using STRICT CORRESPONDING BY [at 3:4]
  (from keyvalue)
   ^
--
ALTERNATION GROUP: by name on
--
ERROR: Pipe argument query 1 must share the same set of column names as the ON list when using BY NAME ON [at 3:4]
  (from keyvalue)
   ^
==

# Output column names match order and case from the ON list.
(FROM KeyValue)
|> UNION ALL BY NAME ON (vALue, kEy)
(FROM KeyValue)
--
QueryStmt
+-output_column_list=
| +-$union_all.vALue#5 AS vALue [STRING]
| +-$union_all.kEy#6 AS kEy [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[vALue#5, kEy#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=KeyValue.[Value#2, Key#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-output_column_list=KeyValue.[Value#2, Key#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=KeyValue.[Value#4, Key#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |   +-output_column_list=KeyValue.[Value#4, Key#3]
    +-column_match_mode=CORRESPONDING_BY
==

[language_features=NONE,+PIPES,+CORRESPONDING_FULL,+WITH_RECURSIVE]
with recursive T as (
  select 1 as n
  |> union {{all|distinct}} (select n + 1 from T where n < 3)
)
select * from T
--
ALTERNATION GROUP: all
--
QueryStmt
+-output_column_list=
| +-T.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[T.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="T"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_all.n#2]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_all1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_all1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_all1.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=T.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[T.n#3]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[T.n#3])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=T.n#3)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=[$union_all1.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[T.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[T.n#5], with_query_name="T")
    +-recursive=TRUE
--
ALTERNATION GROUP: distinct
--
QueryStmt
+-output_column_list=
| +-T.n#5 AS n [INT64]
+-query=
  +-WithScan
    +-column_list=[T.n#5]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="T"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=[$union_distinct.n#2]
    |       +-op_type=UNION_DISTINCT
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-ProjectScan
    |       |   |   +-column_list=[$union_distinct1.n#1]
    |       |   |   +-expr_list=
    |       |   |   | +-n#1 := Literal(type=INT64, value=1)
    |       |   |   +-input_scan=
    |       |   |     +-SingleRowScan
    |       |   +-output_column_list=[$union_distinct1.n#1]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-ProjectScan
    |           |   +-column_list=[$union_distinct1.$col1#4]
    |           |   +-expr_list=
    |           |   | +-$col1#4 :=
    |           |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |           |   |     +-ColumnRef(type=INT64, column=T.n#3)
    |           |   |     +-Literal(type=INT64, value=1)
    |           |   +-input_scan=
    |           |     +-FilterScan
    |           |       +-column_list=[T.n#3]
    |           |       +-input_scan=
    |           |       | +-RecursiveRefScan(column_list=[T.n#3])
    |           |       +-filter_expr=
    |           |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |           |           +-ColumnRef(type=INT64, column=T.n#3)
    |           |           +-Literal(type=INT64, value=3)
    |           +-output_column_list=[$union_distinct1.$col1#4]
    +-query=
    | +-ProjectScan
    |   +-column_list=[T.n#5]
    |   +-input_scan=
    |     +-WithRefScan(column_list=[T.n#5], with_query_name="T")
    +-recursive=TRUE
==

[language_features=NONE,+PIPES,+CORRESPONDING_FULL,+WITH_RECURSIVE]
# pipe except or intersect cannot be used inside WITH RECURSIVE.
with recursive T as (
  select 1 as n
  |> {{intersect|except}} {{all|distinct}} (select n + 1 from T where n < 3)
)
select * from T
--
ERROR: Recursive query does not have the form <non-recursive-term> UNION [ALL|DISTINCT] <recursive-term> or the pipe form <non-recursive-term> |> UNION [ALL|DISTINCT] <recursive-term> [at 2:21]
with recursive T as (
                    ^
==

# The 2nd pipe argument query has error.
from keyvalue
|> union distinct {{strict corresponding|by name}} (from keyvalue), (from keyvalue |> extend 1)
--
ALTERNATION GROUP: strict corresponding
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: pipe argument query 2, column 3 [at 2:58]
...distinct strict corresponding (from keyvalue), (from keyvalue |> extend 1)
                                                   ^
--
ALTERNATION GROUP: by name
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: pipe argument query 2, column 3 [at 2:45]
|> union distinct by name (from keyvalue), (from keyvalue |> extend 1)
                                            ^
==

# Pipe union value table with a compatible one-column table. Result is a value
# table because the pipe input table is a value table.
(from Int64ValueTable vt1)
|> union all (select 1)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.vt1#3 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.vt1#3]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     vt1 INT64 $union_all.vt1#3 (value table)
    |   NameScope:
    |     Range variables:
    |       vt1 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.vt1#3
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.vt1#3]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-TableScan(column_list=[Int64ValueTable.IntValue#1], table=Int64ValueTable, column_index_list=[0], alias="vt1")
          | +-output_column_list=[Int64ValueTable.IntValue#1]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all1.$col1#2]
            |   +-expr_list=
            |   | +-$col1#2 := Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-SingleRowScan
            +-output_column_list=[$union_all1.$col1#2]
==

# Pipe union value table with a compatible one-column table. The result is not
# a value table because the pipe input table is not a value table.
(select 1)
|> union all (from Int64ValueTable vt1)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS `$col1` [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.$col1#3]
    +-describe_text=
    |   """
    |   NameList:
    |     <unnamed> INT64 $union_all.$col1#3
    |   NameScope:
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.$col1#3]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-ProjectScan
          | |   +-column_list=[$query.$col1#1]
          | |   +-expr_list=
          | |   | +-$col1#1 := Literal(type=INT64, value=1)
          | |   +-input_scan=
          | |     +-SingleRowScan
          | +-output_column_list=[$query.$col1#1]
          +-SetOperationItem
            +-scan=
            | +-TableScan(column_list=[Int64ValueTable.IntValue#2], table=Int64ValueTable, column_index_list=[0], alias="vt1")
            +-output_column_list=[Int64ValueTable.IntValue#2]
==

# Pipe set operations with value table and incompatible one-column scan.
from Int64ValueTable vt1
|> intersect all (select "string")
--
ERROR: Column 1 in INTERSECT ALL has incompatible types: INT64, STRING [at 2:19]
|> intersect all (select "string")
                  ^
==

# Pipe set operations with value table and incompatible one-column scan.
(select "string")
|> intersect all (from Int64ValueTable vt1)
--
ERROR: Column 1 in INTERSECT ALL has incompatible types: STRING, INT64 [at 2:19]
|> intersect all (from Int64ValueTable vt1)
                  ^
==

# Pipe set operations with value table and a scan with multiple columns
from Int64ValueTable vt1
|> except distinct (select 1, 2)
--
ERROR: Queries in EXCEPT DISTINCT have mismatched column count; pipe input table is value table with 1 column, pipe argument query 1 has 2 columns [at 2:21]
|> except distinct (select 1, 2)
                    ^
==

# Pipe set operations with value table and a scan with multiple columns
(select 1, 2)
|> except distinct (from Int64ValueTable vt1)
--
ERROR: Queries in EXCEPT DISTINCT have mismatched column count; pipe input table has 2 columns, pipe argument query 1 is value table with 1 column [at 2:21]
|> except distinct (from Int64ValueTable vt1)
                    ^
==

# Value tables are still not allowed when CORRESPONDING is used.
from Int64ValueTable
|> union all {{corresponding|corresponding by (value)|by name}} (select 1 AS value)
--
ALTERNATION GROUP: corresponding
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: pipe input table [at 2:4]
|> union all corresponding (select 1 AS value)
   ^
--
ALTERNATION GROUP: corresponding by (value)
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: pipe input table [at 2:4]
|> union all corresponding by (value) (select 1 AS value)
   ^
--
ALTERNATION GROUP: by name
--
ERROR: Value table type not allowed in set operations when BY NAME is used: pipe input table [at 2:4]
|> union all by name (select 1 AS value)
   ^
==

# Value tables are still not allowed when CORRESPONDING is used.
(select 1 AS value)
|> union all {{corresponding|corresponding by (value)|by name}} (from Int64ValueTable)
--
ALTERNATION GROUP: corresponding
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: pipe argument query 1 [at 2:4]
|> union all corresponding (from Int64ValueTable)
   ^
--
ALTERNATION GROUP: corresponding by (value)
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: pipe argument query 1 [at 2:4]
|> union all corresponding by (value) (from Int64ValueTable)
   ^
--
ALTERNATION GROUP: by name
--
ERROR: Value table type not allowed in set operations when BY NAME is used: pipe argument query 1 [at 2:4]
|> union all by name (from Int64ValueTable)
   ^
==

# Value tables and null literals
from Int64ValueTable
|> union all (select null)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.Int64ValueTable#3 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.Int64ValueTable#3]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     Int64ValueTable INT64 $union_all.Int64ValueTable#3 (value table)
    |   NameScope:
    |     Range variables:
    |       Int64ValueTable -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.Int64ValueTable#3
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.Int64ValueTable#3]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-TableScan(column_list=[Int64ValueTable.IntValue#1], table=Int64ValueTable, column_index_list=[0])
          | +-output_column_list=[Int64ValueTable.IntValue#1]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all1.$col1#2]
            |   +-expr_list=
            |   | +-$col1#2 := Literal(type=INT64, value=NULL)
            |   +-input_scan=
            |     +-SingleRowScan
            +-output_column_list=[$union_all1.$col1#2]
==

# Type coercions between value tables and null literals
select null
|> union all (from Int64ValueTable)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#3 AS `$col1` [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.$col1#3]
    +-describe_text=
    |   """
    |   NameList:
    |     <unnamed> INT64 $union_all.$col1#3
    |   NameScope:
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.$col1#3]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-ProjectScan
          | |   +-column_list=[$query.$col1#1]
          | |   +-expr_list=
          | |   | +-$col1#1 := Literal(type=INT64, value=NULL)
          | |   +-input_scan=
          | |     +-SingleRowScan
          | +-output_column_list=[$query.$col1#1]
          +-SetOperationItem
            +-scan=
            | +-TableScan(column_list=[Int64ValueTable.IntValue#2], table=Int64ValueTable, column_index_list=[0])
            +-output_column_list=[Int64ValueTable.IntValue#2]
==

# Type coercions between value tables and null literals
from Int64ValueTable
|> union all (select null)
|> static_describe
--
QueryStmt
+-output_column_list=
| +-$union_all.Int64ValueTable#3 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$union_all.Int64ValueTable#3]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     Int64ValueTable INT64 $union_all.Int64ValueTable#3 (value table)
    |   NameScope:
    |     Range variables:
    |       Int64ValueTable -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $union_all.Int64ValueTable#3
    |   """
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.Int64ValueTable#3]
        +-op_type=UNION_ALL
        +-input_item_list=
          +-SetOperationItem
          | +-scan=
          | | +-TableScan(column_list=[Int64ValueTable.IntValue#1], table=Int64ValueTable, column_index_list=[0])
          | +-output_column_list=[Int64ValueTable.IntValue#1]
          +-SetOperationItem
            +-scan=
            | +-ProjectScan
            |   +-column_list=[$union_all1.$col1#2]
            |   +-expr_list=
            |   | +-$col1#2 := Literal(type=INT64, value=NULL)
            |   +-input_scan=
            |     +-SingleRowScan
            +-output_column_list=[$union_all1.$col1#2]
==

# Type coercions for value table, super type is different from both the input
# types.
select as value cast(1 as int32)
|> except distinct (select as value cast(2 as uint32))
--
QueryStmt
+-output_column_list=
| +-$except_distinct.$value_column#3 AS `$value_column` [INT64]
+-is_value_table=TRUE
+-query=
  +-SetOperationScan
    +-column_list=[$except_distinct.$value_column#3]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$except_distinct1_cast.$col1#4]
      | |   +-expr_list=
      | |   | +-$col1#4 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$query.$col1#1]
      | |       +-expr_list=
      | |       | +-$col1#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$except_distinct1_cast.$col1#4]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$except_distinct2_cast.$col1#5]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=INT64, value=2, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$except_distinct1.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=UINT32, value=2, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$except_distinct2_cast.$col1#5]
==

# Type coercions between value tables and regular tables, super type is
# different from both the inputs types.
select as value cast(1 as int32)
|> except distinct (select cast(1 as uint32))
--
QueryStmt
+-output_column_list=
| +-$except_distinct.$value_column#3 AS `$value_column` [INT64]
+-is_value_table=TRUE
+-query=
  +-SetOperationScan
    +-column_list=[$except_distinct.$value_column#3]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$except_distinct1_cast.$col1#4]
      | |   +-expr_list=
      | |   | +-$col1#4 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$query.$col1#1]
      | |       +-expr_list=
      | |       | +-$col1#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$except_distinct1_cast.$col1#4]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$except_distinct2_cast.$col1#5]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$except_distinct1.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=UINT32, value=1, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$except_distinct2_cast.$col1#5]
==

# Type coercions between value tables and regular tables, super type is
# different from both the inputs types.
select cast(1 as uint32)
|> except distinct (select as value cast(1 as int32))
--
QueryStmt
+-output_column_list=
| +-$except_distinct.$col1#3 AS `$col1` [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$except_distinct.$col1#3]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$except_distinct1_cast.$col1#4]
      | |   +-expr_list=
      | |   | +-$col1#4 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$query.$col1#1]
      | |       +-expr_list=
      | |       | +-$col1#1 := Literal(type=UINT32, value=1, has_explicit_type=TRUE)
      | |       +-input_scan=
      | |         +-SingleRowScan
      | +-output_column_list=[$except_distinct1_cast.$col1#4]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$except_distinct2_cast.$col1#5]
        |   +-expr_list=
        |   | +-$col1#5 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=[$except_distinct1.$col1#2]
        |       +-expr_list=
        |       | +-$col1#2 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
        |       +-input_scan=
        |         +-SingleRowScan
        +-output_column_list=[$except_distinct2_cast.$col1#5]
==

# Pipe set operations do not have access to the names of the previous scope.
from unnest([1, 2, 3]) as number
|> union all (select number)
--
ERROR: Unrecognized name: number [at 2:22]
|> union all (select number)
                     ^
==

# Range variables defined in the previous arg input is not visible in the next
# arg input.
from unnest([1, 2]) as number1
|> union all (from unnest([1, 2, 3]) as number2), (select number2)
--
ERROR: Unrecognized name: number2 [at 2:59]
|> union all (from unnest([1, 2, 3]) as number2), (select number2)
                                                          ^
==

select * from unnest([1, 2, 3]) as number
|> intersect distinct (select number)
--
ERROR: Unrecognized name: number [at 2:31]
|> intersect distinct (select number)
                              ^
==

from keyvalue
|> as alias
|> except all (select * from alias)
--
ERROR: Table not found: alias [at 3:30]
|> except all (select * from alias)
                             ^
==

# Correlated columns are allowed inside the pipe union. The `number` column
# inside the pipe union is the correlated column introduced by
# "|> select key as number", not by "unnest([1, 2, 3]) as key".
from keyvalue
|> select key as number
|> select (
  select * from unnest([1, 2, 3]) as number
  |> union distinct (select number)
)
--
QueryStmt
+-output_column_list=
| +-$pipe_select.$col1#6 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$pipe_select.$col1#6]
    +-expr_list=
    | +-$col1#6 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-SetOperationScan
    |         +-column_list=[$union_distinct.number#5]
    |         +-op_type=UNION_DISTINCT
    |         +-input_item_list=
    |           +-SetOperationItem
    |           | +-scan=
    |           | | +-ProjectScan
    |           | |   +-column_list=[$array.number#3]
    |           | |   +-input_scan=
    |           | |     +-ArrayScan
    |           | |       +-column_list=[$array.number#3]
    |           | |       +-array_expr_list=
    |           | |       | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |           | |       +-element_column_list=[$array.number#3]
    |           | +-output_column_list=[$array.number#3]
    |           +-SetOperationItem
    |             +-scan=
    |             | +-ProjectScan
    |             |   +-column_list=[$union_distinct1.number#4]
    |             |   +-expr_list=
    |             |   | +-number#4 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             |   +-input_scan=
    |             |     +-SingleRowScan
    |             +-output_column_list=[$union_distinct1.number#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1]
        +-input_scan=
          +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
