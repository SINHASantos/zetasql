# Without language feature MAP_TYPE, map functions are not defined.
[default language_features=NONE]
SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
--
ERROR: Function not found: MAP_FROM_ARRAY [at 1:8]
SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
       ^
==

[default language_features=NONE,+MAP_TYPE]

SELECT MAP_FROM_ARRAY([("a", 1), ("b", 2)]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY([STRUCT(1 AS foo, 2 AS bar), STRUCT(2, 4)]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<foo INT64, bar INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<foo INT64, bar INT64>>, value=[{foo:1, bar:2}, {foo:2, bar:4}])
    +-input_scan=
      +-SingleRowScan
==

# Struct field names hold no special meaning; only field order matters.
SELECT MAP_FROM_ARRAY([STRUCT(1 AS value, "a" AS key), STRUCT(2, "b")]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<value INT64, key STRING>>) -> MAP<INT64, STRING>)
    |     +-Literal(type=ARRAY<STRUCT<value INT64, key STRING>>, value=[{value:1, key:"a"}, {value:2, key:"b"}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<INT64, INT64>>));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY(CAST([] AS ARRAY<STRUCT<INT64, INT64>>));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, INT64>>) -> MAP<INT64, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<INT64, INT64>>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_FROM_ARRAY({{|"a"| [("a", "b")], "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_FROM_ARRAY. Supported signature: MAP_FROM_ARRAY(ARRAY<STRUCT<T1, T2>>) [at 1:8]
SELECT MAP_FROM_ARRAY()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_FROM_ARRAY
  Argument types: STRING
  Signature: MAP_FROM_ARRAY(ARRAY<T1>)
    Argument 1: expected array type but found STRING [at 1:8]
SELECT MAP_FROM_ARRAY("a")
       ^
--
ALTERNATION GROUP:  [("a", "b")], "extra_arg"
--
ERROR: No matching signature for function MAP_FROM_ARRAY. Supported signature: MAP_FROM_ARRAY(ARRAY<STRUCT<T1, T2>>) [at 1:8]
SELECT MAP_FROM_ARRAY( [("a", "b")], "extra_arg")
       ^
==

SELECT MAP_FROM_ARRAY(NULL);
--
ERROR: MAP_FROM_ARRAY result type cannot be determined from argument NULL. Consider casting the argument to ARRAY<STRUCT<T1, T2>> so that key type T1 and value type T2 can be determined from the argument [at 1:8]
SELECT MAP_FROM_ARRAY(NULL);
       ^
==

SELECT MAP_FROM_ARRAY([]);
--
ERROR: MAP_FROM_ARRAY result type cannot be determined from argument []. Consider casting the argument to ARRAY<STRUCT<T1, T2>> so that key type T1 and value type T2 can be determined from the argument [at 1:8]
SELECT MAP_FROM_ARRAY([]);
       ^
==

SELECT MAP_FROM_ARRAY([1,2,3,4]);
--
ERROR: MAP_FROM_ARRAY input argument must be an array of structs, but got type ARRAY<INT64> [at 1:8]
SELECT MAP_FROM_ARRAY([1,2,3,4]);
       ^
==

SELECT MAP_FROM_ARRAY([(true, true, "oops")]);
--
ERROR: MAP_FROM_ARRAY input array must be of type ARRAY<STRUCT<T1, T2>>, but found a struct member with 3 fields [at 1:8]
SELECT MAP_FROM_ARRAY([(true, true, "oops")]);
       ^
==

# Error for non-groupable key
SELECT MAP_FROM_ARRAY([(new zetasql_test__.EmptyMessage(), true)]);
--
ERROR: MAP_FROM_ARRAY expected a groupable key, but got a key of type `zetasql_test__.EmptyMessage`, which does not support grouping [at 1:8]
SELECT MAP_FROM_ARRAY([(new zetasql_test__.EmptyMessage(), true)]);
       ^
==

# No error for non-groupable value
SELECT MAP_FROM_ARRAY([(true, new zetasql_test__.EmptyMessage())]);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<BOOL, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<BOOL, PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>>)
    |       +-MakeStruct
    |         +-type=STRUCT<BOOL, PROTO<zetasql_test__.EmptyMessage>>
    |         +-field_list=
    |           +-Literal(type=BOOL, value=true)
    |           +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE{{|,+DISALLOW_GROUP_BY_FLOAT}}]

SELECT MAP_FROM_ARRAY([(0.1, true)]);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, BOOL>>) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=ARRAY<STRUCT<DOUBLE, BOOL>>, value=[{0.1, true}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ,+DISALLOW_GROUP_BY_FLOAT
--
ERROR: MAP_FROM_ARRAY expected a groupable key, but got a key of type DOUBLE, which does not support grouping [at 1:8]
SELECT MAP_FROM_ARRAY([(0.1, true)]);
       ^
==

[language_features=NONE,+MAP_TYPE,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK]
SELECT MAP_FROM_ARRAY([('a', true), (COLLATE('Z', 'und:ci'), false)]);
--
ERROR: Collation is not allowed on argument 1 (<<"und:ci",_>>) [at 1:8]
SELECT MAP_FROM_ARRAY([('a', true), (COLLATE('Z', 'und:ci'), false)]);
       ^
==

SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([("a", 1), ("b", 2)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<key STRING, value INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_entries_sorted(MAP<STRING, INT64>) -> ARRAY<STRUCT<key STRING, value INT64>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_ENTRIES_SORTED(NULL);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: NULL
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_SORTED(NULL);
       ^
==

SELECT MAP_ENTRIES_SORTED([]);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: []
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_SORTED([]);
       ^
==

[default language_features=NONE,+MAP_TYPE,+GROUP_BY_STRUCT]

SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
--
ERROR: MAP_ENTRIES_SORTED map key type must be orderable, but was not: STRUCT is not orderable [at 1:8]
SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
       ^
==

SELECT MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([(STRUCT(1), true)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<key STRUCT<INT64>, value BOOL>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_entries_unsorted(MAP<STRUCT<INT64>, BOOL>) -> ARRAY<STRUCT<key STRUCT<INT64>, value BOOL>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<INT64>, BOOL>>) -> MAP<STRUCT<INT64>, BOOL>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<INT64>, BOOL>>, value=[{{1}, true}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_ENTRIES_UNSORTED(NULL);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: NULL
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(NULL);
       ^
==

SELECT MAP_ENTRIES_UNSORTED([]);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: []
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    The map type could not be constructed because the key and value types were not determinable [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([]);
       ^
==

SELECT MAP_ENTRIES_SORTED([('a', 'b')]);
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: ARRAY<STRUCT<STRING, STRING>>
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found ARRAY<STRUCT<STRING, STRING>> [at 1:8]
SELECT MAP_ENTRIES_SORTED([('a', 'b')]);
       ^

==

SELECT MAP_ENTRIES_UNSORTED([('a', 'b')]);
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: ARRAY<STRUCT<STRING, STRING>>
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found ARRAY<STRUCT<STRING, STRING>> [at 1:8]
SELECT MAP_ENTRIES_UNSORTED([('a', 'b')]);
       ^
==

SELECT MAP_ENTRIES_SORTED({{|"a"|MAP_FROM_ARRAY([("a", "b")]), "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED with no arguments
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
SELECT MAP_ENTRIES_SORTED()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: STRING
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found STRING [at 1:8]
SELECT MAP_ENTRIES_SORTED("a")
       ^
--
ALTERNATION GROUP: MAP_FROM_ARRAY([("a", "b")]), "extra_arg"
--
ERROR: No matching signature for function MAP_ENTRIES_SORTED
  Argument types: MAP<STRING, STRING>, STRING
  Signature: MAP_ENTRIES_SORTED(MAP<T1, T2>)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
SELECT MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
==

SELECT MAP_ENTRIES_UNSORTED({{|"a"|MAP_FROM_ARRAY([("a", "b")]), "extra_arg"}})
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED with no arguments
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
SELECT MAP_ENTRIES_UNSORTED()
       ^
--
ALTERNATION GROUP: "a"
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: STRING
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Argument 1: expected MAP<T1, T2>, found STRING [at 1:8]
SELECT MAP_ENTRIES_UNSORTED("a")
       ^
--
ALTERNATION GROUP: MAP_FROM_ARRAY([("a", "b")]), "extra_arg"
--
ERROR: No matching signature for function MAP_ENTRIES_UNSORTED
  Argument types: MAP<STRING, STRING>, STRING
  Signature: MAP_ENTRIES_UNSORTED(MAP<T1, T2>)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
SELECT MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([("a", "b")]), "extra_arg")
       ^
==

[default language_features=NONE,+MAP_TYPE,+SQL_GRAPH,+SQL_GRAPH_EXPOSE_GRAPH_ELEMENT]
select MAP_FROM_ARRAY([(a, 1)]) from graph_table(
  aml
  match (a IS Person) -[e]-> (b IS Account)
)
--
ERROR: Returning expressions of type GRAPH_ELEMENT is not allowed [at 1:1]
select MAP_FROM_ARRAY([(a, 1)]) from graph_table(
^
==

[default language_features=NONE,+MAP_TYPE,+SQL_GRAPH,+SQL_GRAPH_EXPOSE_GRAPH_ELEMENT]
select MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(a, 1)])) from graph_table(
  aml
  match (a IS Person) -[e]-> (b IS Account)
)
--
ERROR: MAP_ENTRIES_SORTED map key type must be orderable, but was not: GRAPH_ELEMENT is not orderable [at 1:8]
select MAP_ENTRIES_SORTED(MAP_FROM_ARRAY([(a, 1)])) from graph_table(
       ^
==

[default language_features=NONE,+MAP_TYPE,+SQL_GRAPH,+SQL_GRAPH_EXPOSE_GRAPH_ELEMENT]
select MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([(a, 1)])) from graph_table(
  aml
  match (a IS Person) -[e]-> (b IS Account)
)
--
ERROR: Returning expressions of type GRAPH_ELEMENT is not allowed [at 1:1]
select MAP_ENTRIES_UNSORTED(MAP_FROM_ARRAY([(a, 1)])) from graph_table(
^
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), {{'a'|1|NULL}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 1
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 1);
       ^
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 'a', {{0.5|'b'|1|NULL}});
--
ALTERNATION GROUP: 0.5
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=0.5)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'b'
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, STRING, STRING
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {DOUBLE, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', 1.1)]), 'a', 'b');
       ^
--
ALTERNATION GROUP: 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=[{"a", 1.1}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(NULL, {{NULL|'a'|false}});
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<INT64, INT64> input_map, INT64 lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, INT64> input_map, STRING lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<BOOL, INT64> input_map, BOOL lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-Literal(type=MAP<BOOL, INT64>, value=NULL)
    |     +-Literal(type=BOOL, value=false)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(NULL, {{NULL, NULL|NULL, 'a'|'a', NULL|'a', true}});
--
ALTERNATION GROUP: NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<INT64, INT64> input_map, INT64 lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<INT64, STRING> input_map, INT64 lookup_key, optional(1) STRING default_value) -> STRING)
    |     +-Literal(type=MAP<INT64, STRING>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, INT64> input_map, STRING lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, BOOL> input_map, STRING lookup_key, optional(1) BOOL default_value) -> BOOL)
    |     +-Literal(type=MAP<STRING, BOOL>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), {{'a'|NULL|1|NULL, 1|NULL, NULL|'a', 1}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUPS:
    NULL
    NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 1
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), 1);
       ^
--
ALTERNATION GROUP: NULL, 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, DOUBLE> input_map, STRING lookup_key, optional(1) DOUBLE default_value) -> DOUBLE)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, DOUBLE>>) -> MAP<STRING, DOUBLE>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, DOUBLE>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), {{DATE('2020-01-01'), 1|'a', false}});
--
ALTERNATION GROUP: DATE('2020-01-01'), 1
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, DATE, INT64
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {STRING, DATE} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), D...
       ^
--
ALTERNATION GROUP: 'a', false
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<STRING, DOUBLE>, STRING, BOOL
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {BOOL, DOUBLE} [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, DOUBLE>>)), '...
       ^
==

SELECT MAP_GET(MAP_FROM_ARRAY([(1.1, "foo")]), 1);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<DOUBLE, STRING> input_map, DOUBLE lookup_key, optional(1) STRING default_value) -> STRING)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, STRING>>) -> MAP<DOUBLE, STRING>)
    |     | +-Literal(type=ARRAY<STRUCT<DOUBLE, STRING>>, value=[{1.1, "foo"}])
    |     +-Literal(type=DOUBLE, value=1)
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([(DATE("2020-01-01"), "foo")]), "2020-01-01");
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<DATE, STRING> input_map, DATE lookup_key, optional(1) STRING default_value) -> STRING)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, STRING>>) -> MAP<DATE, STRING>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, STRING>) -> ARRAY<STRUCT<DATE, STRING>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, STRING>
    |     |     +-field_list=
    |     |       +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     |       | +-Literal(type=TIMESTAMP, value=2020-01-01 08:00:00+00)
    |     |       +-Literal(type=STRING, value="foo")
    |     +-Literal(type=DATE, value=2020-01-01)
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES]
SELECT MAP_GET(MAP_FROM_ARRAY([(b'a', 1)]), 'a');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<BYTES, INT64> input_map, BYTES lookup_key, optional(1) INT64 default_value) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BYTES, INT64>>) -> MAP<BYTES, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<BYTES, INT64>>, value=[{b"a", 1}])
    |     +-Literal(type=BYTES, value=b"a")
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_GET(MAP_FROM_ARRAY([('a', new zetasql_test__.EmptyMessage())]), 'b', '');
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [PROTO<zetasql_test__.EmptyMessage>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map, STRING lookup_key, optional(1) PROTO<zetasql_test__.EmptyMessage> default_value) -> PROTO<zetasql_test__.EmptyMessage>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=PROTO<zetasql_test__.EmptyMessage>, value={})
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+JSON_TYPE]
SELECT MAP_GET(MAP_FROM_ARRAY([('a', JSON '1')]), NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [JSON]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, JSON> input_map, STRING lookup_key, optional(1) JSON default_value) -> JSON)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, JSON>>) -> MAP<STRING, JSON>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, JSON>) -> ARRAY<STRUCT<STRING, JSON>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, JSON>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-Literal(type=JSON, value=1, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=JSON, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+JSON_TYPE]
SELECT MAP_GET(MAP_FROM_ARRAY([
       ('a',
           (MAP_FROM_ARRAY([('b', JSON '1')]), new zetasql_test__.EmptyMessage())
       )]), NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_get(MAP<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>> input_map, STRING lookup_key, optional(1) STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>> default_value) -> STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>>) -> MAP<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>) -> ARRAY<STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<STRING, STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>>
    |     |     +-field_list=
    |     |       +-Literal(type=STRING, value="a")
    |     |       +-MakeStruct
    |     |         +-type=STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>
    |     |         +-field_list=
    |     |           +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, JSON>>) -> MAP<STRING, JSON>)
    |     |           | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, JSON>) -> ARRAY<STRUCT<STRING, JSON>>)
    |     |           |   +-MakeStruct
    |     |           |     +-type=STRUCT<STRING, JSON>
    |     |           |     +-field_list=
    |     |           |       +-Literal(type=STRING, value="b")
    |     |           |       +-Literal(type=JSON, value=1, has_explicit_type=TRUE)
    |     |           +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=STRUCT<MAP<STRING, JSON>, PROTO<zetasql_test__.EmptyMessage>>, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK,+GROUP_BY_STRUCT]
# Regression test for b/409835344
SELECT MAP_GET(CAST(NULL AS MAP<STRUCT<STRING>, STRING>), STRUCT(COLLATE("foo", "und:ci")));
--
ERROR: Collation is not allowed on argument lookup_key (<"und:ci">) [at 2:8]
SELECT MAP_GET(CAST(NULL AS MAP<STRUCT<STRING>, STRING>), STRUCT(COLLATE("foo...
       ^
==

# Regression test for b/411412805
SELECT MAP_GET(MAP_FROM_ARRAY([(1, 1)]), rand());
--
ERROR: No matching signature for function MAP_GET
  Argument types: MAP<INT64, INT64>, DOUBLE
  Signature: MAP_GET(MAP<T1, T2>, T1, [T2])
    Unable to coerce type MAP<INT64, INT64> to inferred map type MAP<DOUBLE, INT64> for argument <map<T1, T2>> [at 1:8]
SELECT MAP_GET(MAP_FROM_ARRAY([(1, 1)]), rand());
       ^
==

SELECT MAP_FROM_ARRAY([('a', 1)])[{{'a'|NULL|5}}];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [INT64] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[5];
                                  ^
==

SELECT MAP_FROM_ARRAY([('a', 1)])[KEY({{'a'|NULL|5}})];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [KEY(INT64)] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[KEY(5)];
                                  ^
==

[language_features=NONE,+MAP_TYPE,+SAFE_FUNCTION_CALL]
SELECT MAP_FROM_ARRAY([('a', 1)])[SAFE_KEY({{'a'|NULL|5}})];
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall({SAFE_ERROR_MODE} ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall({SAFE_ERROR_MODE} ZetaSQL:$subscript_with_key(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 5
--
ERROR: Subscript access using [KEY(INT64)] is not supported on values of type MAP<STRING, INT64> [at 1:35]
SELECT MAP_FROM_ARRAY([('a', 1)])[SAFE_KEY(5)];
                                  ^
==

SELECT MAP_FROM_ARRAY([(1.5, 1)])[1];
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<DOUBLE, INT64>, DOUBLE) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, INT64>>) -> MAP<DOUBLE, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<DOUBLE, INT64>>, value=[{1.5, 1}])
    |     +-Literal(type=DOUBLE, value=1)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK,+GROUP_BY_STRUCT]
# Regression test for b/409835344
SELECT CAST(NULL AS MAP<STRUCT<STRING>, STRING>)[STRUCT(COLLATE("foo", "und:ci"))];
--
ERROR: Collation is not allowed on argument 2 (<"und:ci">) [at 2:50]
SELECT CAST(NULL AS MAP<STRUCT<STRING>, STRING>)[STRUCT(COLLATE("foo", "und:c...
                                                 ^
==


[language_features=NONE,+MAP_TYPE{{|,+IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES}}]
SELECT MAP_FROM_ARRAY([(b'hello', 1)])['bonjour'];
--
ALTERNATION GROUP: <empty>
--
ERROR: Subscript access using [STRING] is not supported on values of type MAP<BYTES, INT64> [at 1:40]
SELECT MAP_FROM_ARRAY([(b'hello', 1)])['bonjour'];
                                       ^
--
ALTERNATION GROUP: ,+IMPLICIT_COERCION_STRING_LITERAL_TO_BYTES
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<BYTES, INT64>, BYTES) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<BYTES, INT64>>) -> MAP<BYTES, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<BYTES, INT64>>, value=[{b"hello", 1}])
    |     +-Literal(type=BYTES, value=b"bonjour")
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+SAFE_FUNCTION_CALL]
SELECT MAP_FROM_ARRAY([(1, 'a')])[{{OFFSET(0)|SAFE_OFFSET(0)|ORDINAL(1)|SAFE_ORDINAL(1)}}];
--
ALTERNATION GROUP: OFFSET(0)
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[OFFSET(0)];
                                  ^
--
ALTERNATION GROUP: SAFE_OFFSET(0)
--
ERROR: Subscript access using [OFFSET(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[SAFE_OFFSET(0)];
                                  ^
--
ALTERNATION GROUP: ORDINAL(1)
--
ERROR: Subscript access using [ORDINAL(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[ORDINAL(1)];
                                  ^
--
ALTERNATION GROUP: SAFE_ORDINAL(1)
--
ERROR: Subscript access using [ORDINAL(INT64)] is not supported on values of type MAP<INT64, STRING> [at 1:35]
SELECT MAP_FROM_ARRAY([(1, 'a')])[SAFE_ORDINAL(1)];
                                  ^
==

SELECT MAP_CONTAINS_KEY(MAP_FROM_ARRAY([('a', 1)]), {{'a'|NULL}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_contains_key(MAP<STRING, INT64> input_map, STRING lookup_key) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_contains_key(MAP<STRING, INT64> input_map, STRING lookup_key) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_CONTAINS_KEY(CAST(NULL AS MAP<STRING, INT64>), {{'a'|NULL}});
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_contains_key(MAP<STRING, INT64> input_map, STRING lookup_key) -> BOOL)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_contains_key(MAP<STRING, INT64> input_map, STRING lookup_key) -> BOOL)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_CONTAINS_KEY(NULL, {{'a'|NULL}});
--
ALTERNATION GROUP: 'a'
--
ERROR: No matching signature for function MAP_CONTAINS_KEY
  Argument types: NULL, STRING
  Signature: MAP_CONTAINS_KEY(MAP<T1, T2>, T1)
    The map type could not be constructed because the value type was not determinable [at 1:8]
SELECT MAP_CONTAINS_KEY(NULL, 'a');
       ^
--
ALTERNATION GROUP: NULL
--
ERROR: No matching signature for function MAP_CONTAINS_KEY
  Argument types: NULL, NULL
  Signature: MAP_CONTAINS_KEY(MAP<T1, T2>, T1)
    The map type could not be constructed because the value type was not determinable [at 1:8]
SELECT MAP_CONTAINS_KEY(NULL, NULL);
       ^
==

[language_features=NONE,+MAP_TYPE,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK,+GROUP_BY_STRUCT]
SELECT MAP_CONTAINS_KEY(CAST(NULL AS MAP<STRING, STRING>), COLLATE("foo", "und:ci"));
--
ERROR: Collation is not allowed on argument lookup_key ("und:ci"). Use COLLATE(arg, '') to remove collation [at 1:8]
SELECT MAP_CONTAINS_KEY(CAST(NULL AS MAP<STRING, STRING>), COLLATE("foo", "un...
       ^
==

SELECT CAST(NULL AS MAP<STRING, STRING>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, STRING>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+PARAMETERIZED_TYPES,+TIMESTAMP_PRECISION]
# Cast map with type parameter.
SELECT CAST(MAP_FROM_ARRAY([("a", "b")]) AS MAP<TIMESTAMP(6), STRING(5)>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<TIMESTAMP, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-Cast(MAP<STRING, STRING> -> MAP<TIMESTAMP, STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"a", "b"}])
    |     +-type_modifiers=type_parameters:[(precision=6),(max_length=5)]
    +-input_scan=
      +-SingleRowScan
==

SELECT
  CAST(MAP_FROM_ARRAY([("a", 1)]) AS MAP<STRING, INT64>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    +-input_scan=
      +-SingleRowScan
==

SELECT
  CAST(MAP_FROM_ARRAY([("a", 1)]) AS MAP<STRING, FLOAT>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, FLOAT>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-Cast(MAP<STRING, INT64> -> MAP<STRING, FLOAT>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    +-input_scan=
      +-SingleRowScan
==

SELECT
  CAST(MAP_FROM_ARRAY([(1, "a")]) AS MAP<FLOAT, STRING>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<FLOAT, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-Cast(MAP<INT64, STRING> -> MAP<FLOAT, STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<INT64, STRING>>) -> MAP<INT64, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<INT64, STRING>>, value=[{1, "a"}])
    +-input_scan=
      +-SingleRowScan
==

SELECT
  CAST(MAP_FROM_ARRAY([(b"a", 1)]) AS MAP<FLOAT, INT64>);
--
ERROR: Invalid cast from MAP<BYTES, INT64> to MAP<FLOAT, INT64> [at 2:8]
  CAST(MAP_FROM_ARRAY([(b"a", 1)]) AS MAP<FLOAT, INT64>);
       ^
==

SELECT
  CAST(MAP_FROM_ARRAY([(1, b"a")]) AS MAP<INT64, FLOAT>);
--
ERROR: Invalid cast from MAP<INT64, BYTES> to MAP<INT64, FLOAT> [at 2:8]
  CAST(MAP_FROM_ARRAY([(1, b"a")]) AS MAP<INT64, FLOAT>);
       ^
==

SELECT
  CAST(MAP_FROM_ARRAY([(1.5, "foo")]) AS MAP<INT32, BYTES>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT32, BYTES>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-Cast(MAP<DOUBLE, STRING> -> MAP<INT32, BYTES>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DOUBLE, STRING>>) -> MAP<DOUBLE, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<DOUBLE, STRING>>, value=[{1.5, "foo"}])
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS MAP<STRING, MAP<STRING, STRING>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, MAP<STRING, STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, MAP<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS MAP<STRING, MAP<STRING, STRING> >);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, MAP<STRING, STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, MAP<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

# Nested types work without space if just one MAP is present.
SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS ARRAY<MAP<STRING, STRUCT<STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<MAP<STRING, STRUCT<STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<MAP<STRING, STRUCT<STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS ARRAY<STRUCT<MAP<STRING, STRING>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<MAP<STRING, STRING>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=ARRAY<STRUCT<MAP<STRING, STRING>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>> >);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, ARRAY<STRUCT<MAP<STRING, STRING>>>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(NULL AS MAP<{{zetasql_test__.EmptyMessage, STRING|STRING, zetasql_test__.EmptyMessage}}>);
--
ALTERNATION GROUP: zetasql_test__.EmptyMessage, STRING
--
ERROR: MAP key type PROTO is not groupable [at 1:21]
SELECT CAST(NULL AS MAP<zetasql_test__.EmptyMessage, STRING>);
                    ^
--
ALTERNATION GROUP: STRING, zetasql_test__.EmptyMessage
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT CAST(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<INT64, STRING>>)) AS MAP<BYTES, STRING>);
--
ERROR: Invalid cast from MAP<INT64, STRING> to MAP<BYTES, STRING> [at 1:13]
SELECT CAST(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<INT64, STRING>>)) AS MAP...
            ^
==

SELECT CAST(MAP_FROM_ARRAY([("", 1)]) AS MAP<zetasql_test__.EmptyMessage, STRING>);
--
ERROR: MAP key type PROTO is not groupable [at 1:42]
SELECT CAST(MAP_FROM_ARRAY([("", 1)]) AS MAP<zetasql_test__.EmptyMessage, STR...
                                         ^
==

[default language_features=NONE,+MAP_TYPE{{,+GROUP_BY_ARRAY,+GROUP_BY_STRUCT|,+GROUP_BY_ARRAY|}}]
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
--
ALTERNATION GROUP: ,+GROUP_BY_ARRAY,+GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<ARRAY<STRUCT<STRING>>, STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=MAP<ARRAY<STRUCT<STRING>>, STRING>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: ,+GROUP_BY_ARRAY
--
ERROR: MAP key type ARRAY containing STRUCT is not groupable [at 1:21]
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
                    ^
--
ALTERNATION GROUP: <empty>
--
ERROR: MAP key type ARRAY is not groupable [at 1:21]
SELECT CAST(NULL AS MAP<ARRAY<STRUCT<STRING>>, STRING>);
                    ^
==

SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([("k", "v")]));
--
ALTERNATION GROUP: KEYS_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_sorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRING, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRING>>) -> MAP<STRING, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=[{"k", "v"}])
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+GROUP_BY_STRUCT]
# MAP key is not orderable here
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([(STRUCT("a"), "")]));
--
ALTERNATION GROUP: KEYS_SORTED
--
ERROR: MAP_KEYS_SORTED: MAP element type STRUCT is not orderable [at 2:8]
SELECT MAP_KEYS_SORTED(
       ^
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<STRING>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRUCT<STRING>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRUCT<STRING>, STRING> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRUCT<STRING>, STRING>>) -> MAP<STRUCT<STRING>, STRING>)
    |       +-Literal(type=ARRAY<STRUCT<STRUCT<STRING>, STRING>>, value=[{{"a"}, ""}])
    +-input_scan=
      +-SingleRowScan
==


# MAP value is not orderable here
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED|VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([("", NEW zetasql_test__.EmptyMessage())]));
--
ALTERNATION GROUP: KEYS_SORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_sorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: KEYS_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_keys_unsorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<STRING>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: VALUES_SORTED
--
ERROR: MAP_VALUES_SORTED: MAP element type PROTO is not orderable [at 1:8]
SELECT MAP_VALUES_SORTED(
       ^
--
ALTERNATION GROUP: VALUES_UNSORTED
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<PROTO<zetasql_test__.EmptyMessage>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_unsorted(MAP<STRING, PROTO<zetasql_test__.EmptyMessage>> input_map) -> ARRAY<PROTO<zetasql_test__.EmptyMessage>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>) -> MAP<STRING, PROTO<zetasql_test__.EmptyMessage>>)
    |       +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>) -> ARRAY<STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>>)
    |         +-MakeStruct
    |           +-type=STRUCT<STRING, PROTO<zetasql_test__.EmptyMessage>>
    |           +-field_list=
    |             +-Literal(type=STRING, value="")
    |             +-MakeProto(type=PROTO<zetasql_test__.EmptyMessage>)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+ARRAY_ORDERING]
# Array of array is not supported
SELECT MAP_{{VALUES_SORTED|VALUES_UNSORTED}}(
  MAP_FROM_ARRAY([('key', [1, 2, 3])]));
--
ALTERNATION GROUP: VALUES_SORTED
--
ERROR: No matching signature for function MAP_VALUES_SORTED
  Argument types: MAP<STRING, ARRAY<INT64>>
  Signature: MAP_VALUES_SORTED(MAP<T1, T2>)
    <array<T2>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_VALUES_SORTED(
       ^
--
ALTERNATION GROUP: VALUES_UNSORTED
--
ERROR: No matching signature for function MAP_VALUES_UNSORTED
  Argument types: MAP<STRING, ARRAY<INT64>>
  Signature: MAP_VALUES_UNSORTED(MAP<T1, T2>)
    <array<T2>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_VALUES_UNSORTED(
       ^
==

[language_features=NONE,+MAP_TYPE,+GROUP_BY_ARRAY,+ARRAY_ORDERING]
# Array of array is not supported
SELECT MAP_{{KEYS_SORTED|KEYS_UNSORTED}}(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
--
ALTERNATION GROUP: KEYS_SORTED
--
ERROR: No matching signature for function MAP_KEYS_SORTED
  Argument types: MAP<ARRAY<INT64>, STRING>
  Signature: MAP_KEYS_SORTED(MAP<T1, T2>)
    <array<T1>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_KEYS_SORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
--
ALTERNATION GROUP: KEYS_UNSORTED
--
ERROR: No matching signature for function MAP_KEYS_UNSORTED
  Argument types: MAP<ARRAY<INT64>, STRING>
  Signature: MAP_KEYS_UNSORTED(MAP<T1, T2>)
    <array<T1>> is inferred to be array of array, which is not supported [at 2:8]
SELECT MAP_KEYS_UNSORTED(MAP_FROM_ARRAY([([1, 2, 3], 'value')]));
       ^
==

SELECT MAP_VALUES_SORTED_BY_KEY(MAP_FROM_ARRAY([('b', 1), ('a', 2)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted_by_key(MAP<STRING, INT64> input_map) -> ARRAY<INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"b", 1}, {"a", 2}])
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+GROUP_BY_STRUCT]
SELECT MAP_VALUES_SORTED_BY_KEY(
  MAP_FROM_ARRAY([({{STRUCT('a'), 1|'a', STRUCT(1)}})]));
--
ALTERNATION GROUP: STRUCT('a'), 1
--
ERROR: MAP_VALUES_SORTED_BY_KEY: MAP element type STRUCT is not orderable [at 1:8]
SELECT MAP_VALUES_SORTED_BY_KEY(
       ^
--
ALTERNATION GROUP: 'a', STRUCT(1)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [ARRAY<STRUCT<INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_values_sorted_by_key(MAP<STRING, STRUCT<INT64>> input_map) -> ARRAY<STRUCT<INT64>>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, STRUCT<INT64>>>) -> MAP<STRING, STRUCT<INT64>>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, STRUCT<INT64>>>, value=[{"a", {1}}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_EMPTY(
  MAP_FROM_ARRAY({{[('a', 1)]|CAST([] AS ARRAY<STRUCT<STRING, INT64>>)|CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)}}));
--
ALTERNATION GROUP: [('a', 1)]
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: CAST([] AS ARRAY<STRUCT<STRING, INT64>>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_empty(MAP<STRING, INT64> input_map) -> BOOL)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2),
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, 'c', 3),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, 'c', 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value="c")
    | |   +-Literal(type=INT64, value=3)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value="c")
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(
  MAP_FROM_ARRAY([('a', 1)]), 'b', 2, {{'c', 'x'|1, 3|'c'}});
--
ALTERNATION GROUP: 'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, INT64, STRING} [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: 1, 3
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING, STRING} [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: 'c'
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Wrong number of repeated arguments provided. Expected a multiple of 2 but got 1 repeated argument [at 1:8]
SELECT MAP_INSERT(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, INT64, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,1, 3
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c'
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Wrong number of repeated arguments provided. Expected a multiple of 2 but got 1 repeated argument [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(
       ^
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([('a', 1)]))
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT64>
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 1 argument [at 1:8]
SELECT MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]))
       ^
--
ALTERNATION GROUP: _OR_REPLACE
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT64>
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 1 argument [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]))
       ^
==

SELECT
  MAP_INSERT(NULL, 'b', 2),
  MAP_INSERT(NULL, 'b', 2, 'c', 3),
  MAP_INSERT_OR_REPLACE(NULL, 'b', 2),
  MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 'c', 3);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value="c")
    | |   +-Literal(type=INT64, value=3)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-Literal(type=MAP<STRING, INT64>, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value="c")
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(NULL, 'b', 2, {{1, 3|'c', 'x'}});
--
ALTERNATION GROUP: 1, 3
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: NULL, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_INSERT(NULL, 'b', 2, 1, 3);
       ^
--
ALTERNATION GROUP: 'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: NULL, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, STRING} [at 1:8]
SELECT MAP_INSERT(NULL, 'b', 2, 'c', 'x');
       ^
--
ALTERNATION GROUP: _OR_REPLACE,1, 3
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: NULL, STRING, INT64, INT64, INT64
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 1, 3);
       ^
--
ALTERNATION GROUP: _OR_REPLACE,'c', 'x'
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: NULL, STRING, INT64, STRING, STRING
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, STRING} [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(NULL, 'b', 2, 'c', 'x');
       ^
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(
  NULL, {{'a', 1|DATE('2024-01-01'), STRUCT()|NULL, NULL|NULL, NULL, 1.1, true}})
--
ALTERNATION GROUP: 'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: DATE('2024-01-01'), STRUCT()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, STRUCT<>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, STRUCT<>> input_map, DATE, STRUCT<>, repeated(0) DATE, repeated(0) STRUCT<>) -> MAP<DATE, STRUCT<>>)
    |     +-Literal(type=MAP<DATE, STRUCT<>>, value=NULL)
    |     +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     | +-Literal(type=TIMESTAMP, value=2024-01-01 08:00:00+00)
    |     +-Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<INT64, INT64> input_map, INT64, INT64, repeated(0) INT64, repeated(0) INT64) -> MAP<INT64, INT64>)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL, NULL, 1.1, true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DOUBLE, BOOL> input_map, DOUBLE, BOOL, repeated(1) DOUBLE, repeated(1) BOOL) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=MAP<DOUBLE, BOOL>, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    |     +-Literal(type=BOOL, value=NULL)
    |     +-Literal(type=DOUBLE, value=1.1)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,'a', 1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    |     +-Literal(type=MAP<STRING, INT64>, value=NULL)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,DATE('2024-01-01'), STRUCT()
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, STRUCT<>>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, STRUCT<>> input_map, DATE, STRUCT<>, repeated(0) DATE, repeated(0) STRUCT<>) -> MAP<DATE, STRUCT<>>)
    |     +-Literal(type=MAP<DATE, STRUCT<>>, value=NULL)
    |     +-FunctionCall(ZetaSQL:date(TIMESTAMP, optional(0) STRING) -> DATE)
    |     | +-Literal(type=TIMESTAMP, value=2024-01-01 08:00:00+00)
    |     +-Literal(type=STRUCT<>, value={})
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,NULL, NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<INT64, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<INT64, INT64> input_map, INT64, INT64, repeated(0) INT64, repeated(0) INT64) -> MAP<INT64, INT64>)
    |     +-Literal(type=MAP<INT64, INT64>, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE,NULL, NULL, 1.1, true
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DOUBLE, BOOL>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DOUBLE, BOOL> input_map, DOUBLE, BOOL, repeated(1) DOUBLE, repeated(1) BOOL) -> MAP<DOUBLE, BOOL>)
    |     +-Literal(type=MAP<DOUBLE, BOOL>, value=NULL)
    |     +-Literal(type=DOUBLE, value=NULL)
    |     +-Literal(type=BOOL, value=NULL)
    |     +-Literal(type=DOUBLE, value=1.1)
    |     +-Literal(type=BOOL, value=true)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), NULL, NULL, 'b', 2),
  MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, NULL, NULL),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), NULL, NULL, 'b', 2),
  MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2, NULL, NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
| +-$query.$col2#2 AS `$col2` [MAP<STRING, INT64>]
| +-$query.$col3#3 AS `$col3` [MAP<STRING, INT64>]
| +-$query.$col4#4 AS `$col4` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2, $col3#3, $col4#4]
    +-expr_list=
    | +-$col1#1 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col2#2 :=
    | | +-FunctionCall(ZetaSQL:map_insert(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | +-$col3#3 :=
    | | +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=NULL)
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-$col4#4 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value=NULL)
    |     +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([(DATE "2020-01-01", 1)]), "2020-01-02", 2);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, INT64> input_map, DATE, INT64, repeated(0) DATE, repeated(0) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, INT64> input_map, DATE, INT64, repeated(0) DATE, repeated(0) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([(DATE "2020-01-01", 1)]), "2020-01-02", 2, "2020-01-03", 3);
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert(MAP<DATE, INT64> input_map, DATE, INT64, repeated(1) DATE, repeated(1) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=DATE, value=2020-01-03)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: _OR_REPLACE
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<DATE, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_insert_or_replace(MAP<DATE, INT64> input_map, DATE, INT64, repeated(1) DATE, repeated(1) INT64) -> MAP<DATE, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<DATE, INT64>>) -> MAP<DATE, INT64>)
    |     | +-FunctionCall(ZetaSQL:$make_array(repeated(1) STRUCT<DATE, INT64>) -> ARRAY<STRUCT<DATE, INT64>>)
    |     |   +-MakeStruct
    |     |     +-type=STRUCT<DATE, INT64>
    |     |     +-field_list=
    |     |       +-Literal(type=DATE, value=2020-01-01, has_explicit_type=TRUE)
    |     |       +-Literal(type=INT64, value=1)
    |     +-Literal(type=DATE, value=2020-01-02)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=DATE, value=2020-01-03)
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK,+GROUP_BY_STRUCT]
SELECT MAP_{{INSERT|INSERT_OR_REPLACE|REPLACE}}(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci'), 2);
--
ALTERNATION GROUP: INSERT
--
ERROR: Collation is not allowed on argument 2 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 1:8]
SELECT MAP_INSERT(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci'), 2);
       ^
--
ALTERNATION GROUP: INSERT_OR_REPLACE
--
ERROR: Collation is not allowed on argument 2 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci...
       ^
--
ALTERNATION GROUP: REPLACE
--
ERROR: Collation is not allowed on argument 2 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 1:8]
SELECT MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci'), 2);
       ^
==

# Regression test that insertion/replacement doesn't change the underlying type of the map b/411412805
SELECT MAP_INSERT{{|_OR_REPLACE}}(MAP_FROM_ARRAY([('a', CAST(1 AS INT32))]), 'b', 1.5);
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for function MAP_INSERT
  Argument types: MAP<STRING, INT32>, STRING, DOUBLE
  Signature: MAP_INSERT(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to coerce type MAP<STRING, INT32> to inferred map type MAP<STRING, DOUBLE> for argument <map<T1, T2>> [at 1:8]
SELECT MAP_INSERT(MAP_FROM_ARRAY([('a', CAST(1 AS INT32))]), 'b', 1.5);
       ^
--
ALTERNATION GROUP: _OR_REPLACE
--
ERROR: No matching signature for function MAP_INSERT_OR_REPLACE
  Argument types: MAP<STRING, INT32>, STRING, DOUBLE
  Signature: MAP_INSERT_OR_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to coerce type MAP<STRING, INT32> to inferred map type MAP<STRING, DOUBLE> for argument <map<T1, T2>> [at 1:8]
SELECT MAP_INSERT_OR_REPLACE(MAP_FROM_ARRAY([('a', CAST(1 AS INT32))]), 'b', ...
       ^
==

SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 2) as a,
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'b', 2) as b,
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), NULL, 2) as c,
  MAP_REPLACE(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)), 'a', 2) as d,
  MAP_REPLACE(MAP_FROM_ARRAY(CAST(NULL AS ARRAY<STRUCT<STRING, INT64>>)), 'a', 2, 'b', 3) as e,
--
QueryStmt
+-output_column_list=
| +-$query.a#1 AS a [MAP<STRING, INT64>]
| +-$query.b#2 AS b [MAP<STRING, INT64>]
| +-$query.c#3 AS c [MAP<STRING, INT64>]
| +-$query.d#4 AS d [MAP<STRING, INT64>]
| +-$query.e#5 AS e [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=$query.[a#1, b#2, c#3, d#4, e#5]
    +-expr_list=
    | +-a#1 :=
    | | +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="a")
    | |   +-Literal(type=INT64, value=2)
    | +-b#2 :=
    | | +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value="b")
    | |   +-Literal(type=INT64, value=2)
    | +-c#3 :=
    | | +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    | |   +-Literal(type=STRING, value=NULL)
    | |   +-Literal(type=INT64, value=2)
    | +-d#4 :=
    | | +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(0) STRING, repeated(0) INT64) -> MAP<STRING, INT64>)
    | |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    | |   | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    | |   +-Literal(type=STRING, value="a")
    | |   +-Literal(type=INT64, value=2)
    | +-e#5 :=
    |   +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, INT64, repeated(1) STRING, repeated(1) INT64) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=INT64, value=3)
    +-input_scan=
      +-SingleRowScan
==

SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]));
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 1 argument
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Signature requires at least 3 arguments, found 1 argument [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]));
  ^
==

SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), {{'a'|'a', 'b'|1, 2|'a', 2, 'b'}});
--
ALTERNATION GROUP: 'a'
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, STRING
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Signature requires at least 3 arguments, found 2 arguments
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Signature requires at least 3 arguments, found 2 arguments [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a');
  ^
--
ALTERNATION GROUP: 'a', 'b'
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, STRING
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T2>
      Input types for <T2>: {INT64, STRING}
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Argument 3: expected FUNCTION<T2->T2>, found STRING [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b');
  ^
--
ALTERNATION GROUP: 1, 2
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, INT64, INT64
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING}
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Argument 3: expected FUNCTION<T2->T2>, found INT64 [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 1, 2);
  ^
--
ALTERNATION GROUP: 'a', 2, 'b'
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, INT64, STRING
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Wrong number of repeated arguments provided. Expected a multiple of 2 but got 1 repeated argument
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Argument 4: expected FUNCTION<T2->T2>, found STRING [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 2, 'b');
  ^
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), {{'a'|NULL|'a', 'b', 'c'}}, v -> v + 1);
--
ALTERNATION GROUP: 'a'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, repeated(0) STRING, FUNCTION<INT64->INT64> value) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="a")
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.v#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, repeated(0) STRING, FUNCTION<INT64->INT64> value) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value=NULL)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.v#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: 'a', 'b', 'c'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, repeated(2) STRING, FUNCTION<INT64->INT64> value) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="a")
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="b")
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="c")
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.v#1]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#1)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b', 'c', v -> NULL);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#2 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#2]
    +-expr_list=
    | +-$col1#2 :=
    |   +-FunctionCall(ZetaSQL:map_replace(MAP<STRING, INT64> input_map, STRING, repeated(2) STRING, FUNCTION<INT64->INT64> value) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="a")
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="b")
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-Literal(type=STRING, value="c")
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.v#1]
    |           +-body=
    |             +-Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b', 1, v -> v + 1);
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, STRING, INT64, LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Argument 5: expected T2, found LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING, STRING} [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b', 1, v -> v + 1);
  ^
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b', 1, v -> 'a');
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: MAP<STRING, INT64>, STRING, STRING, INT64, LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Argument 5: expected T2, found LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Argument 5: failed to resolve lambda body, error: Lambda should return type INT64, but returns STRING [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), 'a', 'b', 1, v -> 'a');
  ^
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_REPLACE(NULL, 'a', 'b', 1, v -> 'a');
--
ERROR: No matching signature for function MAP_REPLACE
  Argument types: NULL, STRING, STRING, INT64, LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, T2, [[T1, T2], ...])
    Argument 5: expected T2, found LAMBDA
  Signature: MAP_REPLACE(MAP<T1, T2>, T1, [T1, ...], FUNCTION<T2->T2>)
    Failed to infer type <T2> [at 2:3]
  MAP_REPLACE(NULL, 'a', 'b', 1, v -> 'a');
  ^
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT,+COLLATION_SUPPORT,+ANNOTATION_FRAMEWORK]
SELECT
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci'), v -> NULL);
--
ERROR: Collation is not allowed on argument 2 ("und:ci"). Use COLLATE(arg, '') to remove collation [at 2:3]
  MAP_REPLACE(MAP_FROM_ARRAY([('a', 1)]), COLLATE('a', 'und:ci'), v -> NULL);
  ^
==

SELECT
  MAP_CARDINALITY(MAP_FROM_ARRAY(CAST({{NULL|[]}} AS ARRAY<STRUCT<STRING, INT64>>)));
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_cardinality(MAP<STRING, INT64> input_map) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_cardinality(MAP<STRING, INT64> input_map) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[], has_explicit_type=TRUE)
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_CARDINALITY(MAP_FROM_ARRAY([('a', 1), ('b', 2)]));
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_cardinality(MAP<STRING, INT64> input_map) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |       +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_DELETE(MAP_FROM_ARRAY([('a', 1), ('b', 2)]), 'a'{{|, 'b'|, 'b', 'c'}});
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_delete(MAP<STRING, INT64> input_map, STRING, repeated(0) STRING) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: , 'b'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_delete(MAP<STRING, INT64> input_map, STRING, repeated(1) STRING) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=STRING, value="b")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: , 'b', 'c'
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_delete(MAP<STRING, INT64> input_map, STRING, repeated(2) STRING) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    |     +-Literal(type=STRING, value="a")
    |     +-Literal(type=STRING, value="b")
    |     +-Literal(type=STRING, value="c")
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_DELETE(MAP_FROM_ARRAY(CAST({{NULL|[]}} AS ARRAY<STRUCT<STRING, INT64>>)), 'a');
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_delete(MAP<STRING, INT64> input_map, STRING, repeated(0) STRING) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:map_delete(MAP<STRING, INT64> input_map, STRING, repeated(0) STRING) -> MAP<STRING, INT64>)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[], has_explicit_type=TRUE)
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan
==

SELECT MAP_DELETE(MAP_FROM_ARRAY([('a', 1), ('b', 2)]));
--
ERROR: No matching signature for function MAP_DELETE
  Argument types: MAP<STRING, INT64>
  Signature: MAP_DELETE(MAP<T1, T2>, T1, [T1, ...])
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
SELECT MAP_DELETE(MAP_FROM_ARRAY([('a', 1), ('b', 2)]));
       ^
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT MAP_FILTER(MAP_FROM_ARRAY([('a', 1), ('b', 2)]), (k, v) -> v > 1);
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:map_filter(MAP<STRING, INT64> input_map, FUNCTION<(STRING, INT64)->BOOL> condition) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}, {"b", 2}])
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[k#1, v#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#2)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

[language_features=NONE,+MAP_TYPE,+INLINE_LAMBDA_ARGUMENT]
SELECT
  MAP_FILTER(
    MAP_FROM_ARRAY(CAST({{NULL|[]}} AS ARRAY<STRUCT<STRING, INT64>>)),
    (k, v) -> v > 1);
--
ALTERNATION GROUP: NULL
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:map_filter(MAP<STRING, INT64> input_map, FUNCTION<(STRING, INT64)->BOOL> condition) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=NULL, has_explicit_type=TRUE)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[k#1, v#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#2)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
--
ALTERNATION GROUP: []
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [MAP<STRING, INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:map_filter(MAP<STRING, INT64> input_map, FUNCTION<(STRING, INT64)->BOOL> condition) -> MAP<STRING, INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     |     +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[], has_explicit_type=TRUE)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=$lambda_arg.[k#1, v#2]
    |           +-body=
    |             +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |               +-ColumnRef(type=INT64, column=$lambda_arg.v#2)
    |               +-Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
==

CREATE TEMP FUNCTION MapUdf () RETURNS MAP<STRING, ARRAY<INT64>> AS (CAST(NULL AS MAP<STRING, ARRAY<INT64>>))
--
CreateFunctionStmt
+-name_path=MapUdf
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=MAP<STRING, ARRAY<INT64>>
+-signature=() -> MAP<STRING, ARRAY<INT64>>
+-language="SQL"
+-code="CAST(NULL AS MAP<STRING, ARRAY<INT64>>)"
+-function_expression=
  +-Literal(type=MAP<STRING, ARRAY<INT64>>, value=NULL, has_explicit_type=TRUE)
==

[language_features=NONE,+MAP_TYPE,+CREATE_AGGREGATE_FUNCTION]
CREATE TEMP AGGREGATE FUNCTION MapUda () RETURNS MAP<STRING, ARRAY<INT64>> AS (CAST(NULL AS MAP<STRING, ARRAY<INT64>>))
--
CreateFunctionStmt
+-name_path=MapUda
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=MAP<STRING, ARRAY<INT64>>
+-signature=() -> MAP<STRING, ARRAY<INT64>>
+-is_aggregate=TRUE
+-language="SQL"
+-code="CAST(NULL AS MAP<STRING, ARRAY<INT64>>)"
+-function_expression=
  +-Literal(type=MAP<STRING, ARRAY<INT64>>, value=NULL, has_explicit_type=TRUE)
