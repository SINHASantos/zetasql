[default language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]
[default no_test_extract_table_names]

SELECT * from graph_table(aml
  let single = 3
  let x = [4]
  let xx = [4,4]
  let y = SUM(x + single) + SUM(xx)
  let z = ARRAY_AGG(x + x)
  return y, z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.y#9 AS y [INT64]
| +-$graph_table.z#10 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[y#9, z#10]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[y#9, z#10]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[y#9, z#10]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[y#9, z#10]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.single#1]
                  | +-expr_list=
                  | | +-single#1 := Literal(type=INT64, value=3)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2]
                  | +-expr_list=
                  | | +-x#2 := Literal(type=ARRAY<INT64>, value=[4])
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.single#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, xx#3]
                  | +-expr_list=
                  | | +-xx#3 := Literal(type=ARRAY<INT64>, value=[4, 4])
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, xx#3, y#6]
                  | +-expr_list=
                  | | +-y#6 :=
                  | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     +-ArrayAggregate
                  | |     | +-type=INT64
                  | |     | +-array=
                  | |     | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     | +-element_column=$horizontal_aggregate.x#4
                  | |     | +-aggregate=
                  | |     |   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |     |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     |       +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#4)
                  | |     |       +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | |     +-ArrayAggregate
                  | |       +-type=INT64
                  | |       +-array=
                  | |       | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.xx#3)
                  | |       +-element_column=$horizontal_aggregate.xx#5
                  | |       +-aggregate=
                  | |         +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.xx#5)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2, xx#3])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, xx#3, y#6, z#8]
                  | +-expr_list=
                  | | +-z#8 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     +-element_column=$horizontal_aggregate.x#7
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#7)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#7)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2, xx#3, y#6])
                  +-ProjectScan
                    +-column_list=$graph_table.[y#9, z#10]
                    +-expr_list=
                    | +-y#9 := ColumnRef(type=INT64, column=$graph_table.y#6)
                    | +-z#10 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#8)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[single#1, x#2, xx#3, y#6, z#8])
==

SELECT * from graph_table(aml
  let x = [4, 5]
  let z = ARRAY_AGG(x + x)[OFFSET(0)]
  return z
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-FunctionCall(ZetaSQL:$array_at_offset(ARRAY<INT64>, INT64) -> INT64)
                  | |     +-ArrayAggregate
                  | |     | +-type=ARRAY<INT64>
                  | |     | +-array=
                  | |     | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     | +-element_column=$horizontal_aggregate.x#2
                  | |     | +-aggregate=
                  | |     |   +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |     |     +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     |       +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |     |       +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |     +-Literal(type=INT64, value=0)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=INT64, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

# Simple order by
SELECT * from graph_table(aml
  let x = [4]
  let z = ARRAY_AGG(x + x ORDER BY x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |         +-order_by_item_list=
                  | |           +-OrderByItem
                  | |             +-column_ref=
                  | |               +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==


# Complex order by
SELECT * from graph_table(aml
  let x = [4]
  let single = 3
  let z = ARRAY_AGG(x ORDER BY single, x + x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#6 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#6]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#6]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#6]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#6]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, single#2]
                  | +-expr_list=
                  | | +-single#2 := Literal(type=INT64, value=3)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, single#2, z#5]
                  | +-expr_list=
                  | | +-z#5 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#3
                  | |     +-pre_aggregate_computed_column_list=
                  | |     | +-$orderbycol2#4 :=
                  | |     |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |         +-order_by_item_list=
                  | |           +-OrderByItem
                  | |           | +-column_ref=
                  | |           |   +-ColumnRef(type=INT64, column=$graph_table.single#2)
                  | |           +-OrderByItem
                  | |             +-column_ref=
                  | |               +-ColumnRef(type=INT64, column=$orderby.$orderbycol2#4)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[x#1, single#2])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#6]
                    +-expr_list=
                    | +-z#6 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#5)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, single#2, z#5])

==

# All arrays are treated as horizontally aggregatable. In theory this example
# could be given reasonable semantics but today this doesn't type check
SELECT * from graph_table(aml
  let x = [4]
  let y = [5]
  let z = SUM(x + ARRAY_LENGTH(y))
  return z
)

--
ERROR: Horizontal aggregation on more than one array-typed variable is not allowed. First variable: x [at 4:32]
  let z = SUM(x + ARRAY_LENGTH(y))
                               ^

==

# Multiple uses of a single array are fine
SELECT * from graph_table(aml
  let x = [4, 5]
  let z = SUM(x + x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=INT64
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=INT64, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

# Separate horizontal aggregations are separate
SELECT * from graph_table(aml
  let x = [4, 5]
  let y = [6, 7]
  let z = SUM(x + x) + AVG(y) + MAX(x - x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#7 AS z [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#7]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#7]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#7]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#7]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#2]
                  | +-expr_list=
                  | | +-y#2 := Literal(type=ARRAY<INT64>, value=[6, 7])
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#2, z#6]
                  | +-expr_list=
                  | | +-z#6 :=
                  | |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     | +-Cast(INT64 -> DOUBLE)
                  | |     | | +-ArrayAggregate
                  | |     | |   +-type=INT64
                  | |     | |   +-array=
                  | |     | |   | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     | |   +-element_column=$horizontal_aggregate.x#3
                  | |     | |   +-aggregate=
                  | |     | |     +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |     | |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     | +-ArrayAggregate
                  | |     |   +-type=DOUBLE
                  | |     |   +-array=
                  | |     |   | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.y#2)
                  | |     |   +-element_column=$horizontal_aggregate.y#4
                  | |     |   +-aggregate=
                  | |     |     +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
                  | |     |       +-ColumnRef(type=INT64, column=$horizontal_aggregate.y#4)
                  | |     +-Cast(INT64 -> DOUBLE)
                  | |       +-ArrayAggregate
                  | |         +-type=INT64
                  | |         +-array=
                  | |         | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |         +-element_column=$horizontal_aggregate.x#5
                  | |         +-aggregate=
                  | |           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
                  | |             +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
                  | |               +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | |               +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[x#1, y#2])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#7]
                    +-expr_list=
                    | +-z#7 := ColumnRef(type=DOUBLE, column=$graph_table.z#6)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, y#2, z#6])

==

SELECT * from graph_table(aml
  let x = [4, 5]
  let z = ARRAY_AGG(x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])


==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]

# For aggregates that support order by, the default is path order. Take 2
SELECT * from graph_table(aml
  let x = ["hello", ", ", "world"]
  let z = STRING_AGG(x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<STRING>, value=["hello", ", ", "world"])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=STRING
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<STRING>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:string_agg(STRING) -> STRING)
                  | |         +-ColumnRef(type=STRING, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=STRING, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]

# Aggregate with non-aggregate arguments
SELECT * from graph_table(aml
  let x = ["hello", "world"]
  let z = STRING_AGG(x, ", ")
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<STRING>, value=["hello", "world"])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=STRING
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<STRING>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:string_agg(STRING, STRING) -> STRING)
                  | |         +-ColumnRef(type=STRING, column=$horizontal_aggregate.x#2)
                  | |         +-Literal(type=STRING, value=", ")
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=STRING, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE,+GROUPING_BUILTIN,+QUALIFY,+ANALYTIC_FUNCTIONS]

# Grouping is not allowed in horizontal aggregates
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(x + GROUPING(x))
  return z
)

--
ERROR: Horizontal aggregations of horizontal aggregations are not allowed [at 4:19]
  let z = SUM(x + GROUPING(x))
                  ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE,+GROUPING_BUILTIN,+QUALIFY,+ANALYTIC_FUNCTIONS]

# Analytic functions not allowed
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = afn_order(x)
  return z
)

--
ERROR: Analytic function SAMPLE_FUNCTIONS:AFN_ORDER cannot be called without an OVER clause [at 4:11]
  let z = afn_order(x)
          ^

==

# Analytic functions not allowed
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = afn_agg(x) over ()
  return z
)

--
ERROR: Analytic functions not supported [at 3:11]
  let z = afn_agg(x) over ()
          ^

==

# Analytic functions not allowed
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = afn_order(x) over ()
  return z
)

--
ERROR: Analytic functions not supported [at 3:11]
  let z = afn_order(x) over ()
          ^

==

# Bare array access
SELECT * from graph_table(aml
  let x = [1,2,3]
  let y = x
  let z = y
  return z
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#2]
                  | +-expr_list=
                  | | +-y#2 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#2, z#3]
                  | +-expr_list=
                  | | +-z#3 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.y#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[x#1, y#2])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, y#2, z#3])

==

# Bare array access outside horizontal aggregation
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = ARRAY_LENGTH(x) + SUM(x)
  return z
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     +-FunctionCall(ZetaSQL:array_length(ARRAY<INT64>) -> INT64)
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-ArrayAggregate
                  | |       +-type=INT64
                  | |       +-array=
                  | |       | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |       +-element_column=$horizontal_aggregate.x#2
                  | |       +-aggregate=
                  | |         +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=INT64, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==


# Unused horizontal aggregation doesn't RET_CHECK
with arr as (select [1,2,3] as x)
select * from arr where
 (select true from graph_table(aml match (a) columns (arr.x as r)))

--

QueryStmt
+-output_column_list=
| +-arr.x#2 AS x [ARRAY<INT64>]
+-query=
  +-WithScan
    +-column_list=[arr.x#2]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="arr"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[arr.x#1]
    |       +-expr_list=
    |       | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[arr.x#2]
        +-input_scan=
          +-FilterScan
            +-column_list=[arr.x#2]
            +-input_scan=
            | +-WithRefScan(column_list=[arr.x#2], with_query_name="arr")
            +-filter_expr=
              +-SubqueryExpr
                +-type=BOOL
                +-subquery_type=SCALAR
                +-parameter_list=
                | +-ColumnRef(type=ARRAY<INT64>, column=arr.x#2)
                +-subquery=
                  +-ProjectScan
                    +-column_list=[$expr_subquery.$col1#5]
                    +-expr_list=
                    | +-$col1#5 := Literal(type=BOOL, value=true)
                    +-input_scan=
                      +-GraphTableScan
                        +-column_list=[$graph_table.r#4]
                        +-property_graph=aml
                        +-input_scan=
                        | +-GraphScan
                        |   +-column_list=[$element_table.a#3]
                        |   +-input_scan_list=
                        |     +-GraphPathScan
                        |       +-column_list=[$element_table.a#3]
                        |       +-input_scan_list=
                        |       | +-GraphNodeScan
                        |       |   +-column_list=[$element_table.a#3]
                        |       |   +-label_expr=
                        |       |   | +-GraphLabelNaryExpr
                        |       |   |   +-op=OR
                        |       |   |   +-operand_list=
                        |       |   |     +-GraphWildCardLabel
                        |       |   |     +-GraphLabelNaryExpr
                        |       |   |       +-op=NOT
                        |       |   |       +-operand_list=
                        |       |   |         +-GraphWildCardLabel
                        |       |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                        |       +-head=$element_table.a#3
                        |       +-tail=$element_table.a#3
                        +-shape_expr_list=
                          +-r#4 := ColumnRef(type=ARRAY<INT64>, column=arr.x#2, is_correlated=TRUE)

==

# Nested horizontal aggregations are not allowed
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(SUM(x) + x)
  return z
)

--

ERROR: Horizontal aggregations of horizontal aggregations are not allowed [at 3:15]
  let z = SUM(SUM(x) + x)
              ^

==

# Multi-level horizontal aggregations are not allowed
[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY{{|,+MULTILEVEL_AGGREGATION}}]
SELECT * from graph_table(aml
  let x = [1,2,3]
  let y = 4
  let z = SUM(MIN(x) GROUP BY y)
  return z
)

--

ALTERNATION GROUP: <empty>

--
ERROR: Multi-level aggregation is not yet supported. [at 4:22]
  let z = SUM(MIN(x) GROUP BY y)
                     ^
--
ALTERNATION GROUP: ,+MULTILEVEL_AGGREGATION
--
ERROR: Horizontal aggregates do not support multi-level aggregation. [at 4:22]
  let z = SUM(MIN(x) GROUP BY y)
                     ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+WITH_EXPRESSION]

# No aggregations with expressions introduced in a WITH expression
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = WITH(a as [123], SUM(a))
  return z
)

--
ERROR: Column 'a' is introduced by WITH. Columns introduced by WITH cannot be used in the arguments to aggregate or analytic functions. [at 4:32]
  let z = WITH(a as [123], SUM(a))
                               ^


==

# Horizontal aggregation and with expressions are fine with scalar values
# and the WITH outside of the horizontal aggregate.

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE,+WITH_EXPRESSION]
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = WITH(a as 123, ARRAY_CONCAT(ARRAY_AGG(x ORDER BY 2 * x), [a]))
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#6 AS z [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#6]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#6]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#6]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#6]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#5]
                  | +-expr_list=
                  | | +-z#5 :=
                  | |   +-WithExpr
                  | |     +-type=ARRAY<INT64>
                  | |     +-assignment_list=
                  | |     | +-a#2 := Literal(type=INT64, value=123)
                  | |     +-expr=
                  | |       +-FunctionCall(ZetaSQL:array_concat(ARRAY<INT64>, repeated(1) ARRAY<INT64>) -> ARRAY<INT64>)
                  | |         +-ArrayAggregate
                  | |         | +-type=ARRAY<INT64>
                  | |         | +-array=
                  | |         | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |         | +-element_column=$horizontal_aggregate.x#3
                  | |         | +-pre_aggregate_computed_column_list=
                  | |         | | +-$orderbycol1#4 :=
                  | |         | |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
                  | |         | |     +-Literal(type=INT64, value=2)
                  | |         | |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |         | +-aggregate=
                  | |         |   +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |         |     +-order_by_item_list=
                  | |         |       +-OrderByItem
                  | |         |         +-column_ref=
                  | |         |           +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
                  | |         +-FunctionCall(ZetaSQL:$make_array(repeated(1) INT64) -> ARRAY<INT64>)
                  | |           +-ColumnRef(type=INT64, column=$with_expr.a#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#6]
                    +-expr_list=
                    | +-z#6 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.z#5)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#5])

==

# No WITH inside horizontal aggregations

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+WITH_EXPRESSION]
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(WITH(a as [123], a))
  return z
)

--
ERROR: WITH expressions are not supported in horizontal aggregation. [at 3:15]
  let z = SUM(WITH(a as [123], a))
              ^

==

# WITH expression inside horizontal aggregation.

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+WITH_EXPRESSION]
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(WITH(a as 4, x + a))
  return z
)

--
ERROR: WITH expressions are not supported in horizontal aggregation. [at 3:15]
  let z = SUM(WITH(a as 4, x + a))
              ^

==

# Horizontal aggregation with no array-typed variables gives a reasonable error.

SELECT * from graph_table(aml
  let x = [1,2,3]
  let y = 4
  let z = SUM(y)
  return z
)

--
ERROR: Horizontal aggregation without an array-typed variable is not allowed. Normal vertical aggregation is not allowed in this syntactic context [at 4:11]
  let z = SUM(y)
          ^


==

# Horizontal aggregation with more than one array-typed variables

SELECT * from graph_table(aml
  let x = [1,2,3]
  let y = [4,5,6]
  let z = SUM(x + y)
  return z
)

--
ERROR: Horizontal aggregation on more than one array-typed variable is not allowed. First variable: x [at 4:19]
  let z = SUM(x + y)
                  ^

==

# Without the ORDER_BY_IN_AGGREGATE language feature we get a good error
# when using an aggregate that supports ordering

SELECT * from graph_table(aml
  let x = ["hello", "world"]
  let z = STRING_AGG(x, ", ")
  return z
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<STRING>, value=["hello", "world"])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=STRING
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<STRING>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:string_agg(STRING, STRING) -> STRING)
                  | |         +-ColumnRef(type=STRING, column=$horizontal_aggregate.x#2)
                  | |         +-Literal(type=STRING, value=", ")
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=STRING, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

# Horizontal aggregations allowed these syntactic positions (columns clause
# checked above)
SELECT * from graph_table(aml
  let x = [1,2,3]
  FILTER SUM(x) = 6
  MATCH (a) where MIN(x) = 1
  let z = AVG(x)
  return z
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.z#7 AS z [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#7]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#7]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#7]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#7]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-FilterScan
                  | +-column_list=[$graph_table.x#1]
                  | +-input_scan=
                  | | +-GraphRefScan(column_list=[$graph_table.x#1])
                  | +-filter_expr=
                  |   +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                  |     +-ArrayAggregate
                  |     | +-type=INT64
                  |     | +-array=
                  |     | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  |     | +-element_column=$horizontal_aggregate.x#2
                  |     | +-aggregate=
                  |     |   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  |     +-Literal(type=INT64, value=6)
                  +-GraphScan
                  | +-column_list=[$graph_table.x#1, $element_table.a#3]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$element_table.a#3]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.a#3]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$element_table.a#3
                  | |   +-tail=$element_table.a#3
                  | +-filter_expr=
                  | | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                  | |   +-ArrayAggregate
                  | |   | +-type=INT64
                  | |   | +-array=
                  | |   | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |   | +-element_column=$horizontal_aggregate.x#4
                  | |   | +-aggregate=
                  | |   |   +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
                  | |   |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#4)
                  | |   +-Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1, $element_table.a#3, $graph_table.z#6]
                  | +-expr_list=
                  | | +-z#6 :=
                  | |   +-ArrayAggregate
                  | |     +-type=DOUBLE
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#5
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
                  | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1, $element_table.a#3])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#7]
                    +-expr_list=
                    | +-z#7 := ColumnRef(type=DOUBLE, column=$graph_table.z#6)
                    +-input_scan=
                      +-GraphRefScan(column_list=[$graph_table.x#1, $element_table.a#3, $graph_table.z#6])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+INLINE_LAMBDA_ARGUMENT]
# ARRAY_TRANSFORM

SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(ARRAY_TRANSFORM(x, e -> 2 * e))
  return z
)

--

ERROR: Lambda arguments are not supported in horizontal aggregation [at 5:34]
  let z = SUM(ARRAY_TRANSFORM(x, e -> 2 * e))
                                 ^

==

# TODO: Parameters aren't horizontal aggregatable because they
# aren't in the namescope
select * from graph_table(aml
  let r = STRING_AGG(@test_param_array_string, @test_param_string)
  return r
)
--
ERROR: No matching signature for aggregate function STRING_AGG
  Argument types: ARRAY<STRING>, STRING
  Signature: STRING_AGG(STRING)
    Signature accepts at most 1 argument, found 2 arguments
  Signature: STRING_AGG(STRING, STRING)
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type STRING
  Signature: STRING_AGG(BYTES)
    Signature accepts at most 1 argument, found 2 arguments
  Signature: STRING_AGG(BYTES, BYTES)
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type BYTES [at 2:11]
  let r = STRING_AGG(@test_param_array_string, @test_param_string)
          ^

==

[parameter_mode=positional]
[allow_undeclared_parameters]
[sqlbuilder_positional_parameter_mode=named]

# TODO: Same as previous test
select * from graph_table(aml
  let r = STRING_AGG(cast(? AS ARRAY<STRING>), cast(? AS STRING))
  return r
)
--
ERROR: No matching signature for aggregate function STRING_AGG
  Argument types: ARRAY<STRING>, STRING
  Signature: STRING_AGG(STRING)
    Signature accepts at most 1 argument, found 2 arguments
  Signature: STRING_AGG(STRING, STRING)
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type STRING
  Signature: STRING_AGG(BYTES)
    Signature accepts at most 1 argument, found 2 arguments
  Signature: STRING_AGG(BYTES, BYTES)
    Argument 1: Unable to coerce type ARRAY<STRING> to expected type BYTES [at 3:11]
  let r = STRING_AGG(cast(? AS ARRAY<STRING>), cast(? AS STRING))
          ^

==

# Horizontal aggregation cannot have a subquery inside it
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM((SELECT 2 * x))
  return z
)

--

ERROR: Horizontal aggregation expression must not include a subquery [at 3:15]
  let z = SUM((SELECT 2 * x))
              ^
==

# Horizontal aggregation cannot have a subquery inside it even if it's unrelated
WITH t as (SELECT 1 as a)
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(x + (SELECT SUM(t.a) FROM t))
  return z
)

--

ERROR: Horizontal aggregation expression must not include a subquery [at 4:19]
  let z = SUM(x + (SELECT SUM(t.a) FROM t))
                  ^
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+INLINE_LAMBDA_ARGUMENT]
# Horizontal aggregation cannot contain lambdas
WITH t as (SELECT 1 as a)
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(ARRAY_TRANSFORM([1,2,3], e -> e + 1)[0] + x)
  return z
)

--
ERROR: Lambda arguments are not supported in horizontal aggregation [at 5:40]
  let z = SUM(ARRAY_TRANSFORM([1,2,3], e -> e + 1)[0] + x)
                                       ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+INLINE_LAMBDA_ARGUMENT]
# Horizontal aggregation cannot contain lambdas especially if they refer to the
# element variable
WITH t as (SELECT 1 as a)
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(ARRAY_TRANSFORM([1,2,3], e -> e + x)[0] + x)
  return z
)

--
ERROR: Lambda arguments are not supported in horizontal aggregation [at 6:40]
  let z = SUM(ARRAY_TRANSFORM([1,2,3], e -> e + x)[0] + x)
                                       ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+INLINE_LAMBDA_ARGUMENT,+ARRAY_FIND_FUNCTIONS]
# Horizontal aggregation cannot contain lambdas
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(ARRAY_FIND([1,2,3], e -> e = 2) + x)
  return z
)

--
ERROR: Lambda arguments are not supported in horizontal aggregation [at 4:35]
  let z = SUM(ARRAY_FIND([1,2,3], e -> e = 2) + x)
                                  ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+INLINE_LAMBDA_ARGUMENT,+ARRAY_FIND_FUNCTIONS]
# While ARRAY_FIND failed above because it used a lambda, when it uses a
# signature that doesn't have a lambda it works
SELECT * from graph_table(aml
  let x = [1,2,3]
  let z = SUM(ARRAY_FIND([1,2,3], 2) + x)
  return z
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.z#4 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.z#4]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.z#4]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.z#4]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.z#4]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, z#3]
                  | +-expr_list=
                  | | +-z#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=INT64
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     +-element_column=$horizontal_aggregate.x#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  | |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |           +-FunctionCall(ZetaSQL:array_find(ARRAY<INT64> input_array, INT64 target_element, optional(1) ENUM<ARRAY_FIND_MODE> find_mode) -> INT64)
                  | |           | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
                  | |           | +-Literal(type=INT64, value=2)
                  | |           | +-Literal(type=ENUM<ARRAY_FIND_MODE>, value=FIRST)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.z#4]
                    +-expr_list=
                    | +-z#4 := ColumnRef(type=INT64, column=$graph_table.z#3)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, z#3])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY{{|,+ENFORCE_CONDITIONAL_EVALUATION}}]

# Resolving potentially failing aggregates
SELECT * from graph_table(aml
  let x = [4, 0, 5]
  let y = IFERROR(SUM(x / 2) + SUM(2 / x), SUM(x / 2))
  return y
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.y#6 AS y [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.y#6]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.y#6]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.y#6]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.y#6]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 0, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#5]
                  | +-expr_list=
                  | | +-y#5 :=
                  | |   +-FunctionCall(ZetaSQL:iferror(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     | +-ArrayAggregate
                  | |     | | +-type=DOUBLE
                  | |     | | +-array=
                  | |     | | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     | | +-element_column=$horizontal_aggregate.x#2
                  | |     | | +-aggregate=
                  | |     | |   +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
                  | |     | |     +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     | |       +-Cast(INT64 -> DOUBLE)
                  | |     | |       | +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |     | |       +-Literal(type=DOUBLE, value=2)
                  | |     | +-ArrayAggregate
                  | |     |   +-type=DOUBLE
                  | |     |   +-array=
                  | |     |   | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     |   +-element_column=$horizontal_aggregate.x#3
                  | |     |   +-aggregate=
                  | |     |     +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
                  | |     |       +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     |         +-Literal(type=DOUBLE, value=2)
                  | |     |         +-Cast(INT64 -> DOUBLE)
                  | |     |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     +-ArrayAggregate
                  | |       +-type=DOUBLE
                  | |       +-array=
                  | |       | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |       +-element_column=$horizontal_aggregate.x#4
                  | |       +-aggregate=
                  | |         +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
                  | |           +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
                  | |             +-Cast(INT64 -> DOUBLE)
                  | |             | +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#4)
                  | |             +-Literal(type=DOUBLE, value=2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.y#6]
                    +-expr_list=
                    | +-y#6 := ColumnRef(type=DOUBLE, column=$graph_table.y#5)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, y#5])
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE{{|,+ENFORCE_CONDITIONAL_EVALUATION}}]

# Resolving potentially failing aggregates
SELECT * from graph_table(aml
  let x = [4, 0, 5]
  let y = IFERROR(ARRAY_AGG(2 / x), ARRAY_AGG(x / 2))
  return y
)

--

QueryStmt
+-output_column_list=
| +-$graph_table.y#5 AS y [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.y#5]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.y#5]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.y#5]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.y#5]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.x#1]
                  | +-expr_list=
                  | | +-x#1 := Literal(type=ARRAY<INT64>, value=[4, 0, 5])
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[x#1, y#4]
                  | +-expr_list=
                  | | +-y#4 :=
                  | |   +-FunctionCall(ZetaSQL:iferror(ARRAY<DOUBLE>, ARRAY<DOUBLE>) -> ARRAY<DOUBLE>)
                  | |     +-ArrayAggregate
                  | |     | +-type=ARRAY<DOUBLE>
                  | |     | +-array=
                  | |     | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |     | +-element_column=$horizontal_aggregate.x#2
                  | |     | +-aggregate=
                  | |     |   +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
                  | |     |     +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
                  | |     |       +-Literal(type=DOUBLE, value=2)
                  | |     |       +-Cast(INT64 -> DOUBLE)
                  | |     |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#2)
                  | |     +-ArrayAggregate
                  | |       +-type=ARRAY<DOUBLE>
                  | |       +-array=
                  | |       | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#1)
                  | |       +-element_column=$horizontal_aggregate.x#3
                  | |       +-aggregate=
                  | |         +-AggregateFunctionCall(ZetaSQL:array_agg(DOUBLE) -> ARRAY<DOUBLE>)
                  | |           +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
                  | |             +-Cast(INT64 -> DOUBLE)
                  | |             | +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |             +-Literal(type=DOUBLE, value=2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.x#1])
                  +-ProjectScan
                    +-column_list=[$graph_table.y#5]
                    +-expr_list=
                    | +-y#5 := ColumnRef(type=ARRAY<DOUBLE>, column=$graph_table.y#4)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[x#1, y#4])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]
# Make sure the generated element column in a horizontal aggregate is not correlated
WITH t as (SELECT 1 as a, [1,2,3] as b)
SELECT (SELECT * from graph_table(aml let x = ARRAY_AGG(b) return x)) FROM t

--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [ARRAY<INT64>]
+-query=
  +-WithScan
    +-column_list=[$query.$col1#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=INT64, value=1)
    |       | +-b#2 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$query.$col1#8]
        +-expr_list=
        | +-$col1#8 :=
        |   +-SubqueryExpr
        |     +-type=ARRAY<INT64>
        |     +-subquery_type=SCALAR
        |     +-parameter_list=
        |     | +-ColumnRef(type=ARRAY<INT64>, column=t.b#4)
        |     +-subquery=
        |       +-ProjectScan
        |         +-column_list=[$graph_table.x#7]
        |         +-input_scan=
        |           +-GraphTableScan
        |             +-column_list=[$graph_table.x#7]
        |             +-property_graph=aml
        |             +-input_scan=
        |               +-GraphLinearScan
        |                 +-column_list=[$graph_table.x#7]
        |                 +-scan_list=
        |                   +-GraphLinearScan
        |                     +-column_list=[$graph_table.x#7]
        |                     +-scan_list=
        |                       +-ProjectScan
        |                       | +-column_list=[$graph_table.x#6]
        |                       | +-expr_list=
        |                       | | +-x#6 :=
        |                       | |   +-ArrayAggregate
        |                       | |     +-type=ARRAY<INT64>
        |                       | |     +-array=
        |                       | |     | +-ColumnRef(type=ARRAY<INT64>, column=t.b#4, is_correlated=TRUE)
        |                       | |     +-element_column=$horizontal_aggregate.b#5
        |                       | |     +-aggregate=
        |                       | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
        |                       | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.b#5)
        |                       | +-input_scan=
        |                       |   +-SingleRowScan
        |                       +-ProjectScan
        |                         +-column_list=[$graph_table.x#7]
        |                         +-expr_list=
        |                         | +-x#7 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#6)
        |                         +-input_scan=
        |                           +-GraphRefScan(column_list=[$graph_table.x#6])
        +-input_scan=
          +-WithRefScan(column_list=t.[a#3, b#4], with_query_name="t")

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]
[no_run_sqlbuilder] # ProjectScans that just project values don't unparse correctly

# Even more complicated ORDER BY in ARRAY_AGG
select * from graph_table(aml
  let single = 3
  let x = [4, 5]
  let r1 = ARRAY_AGG(x + single),
      r2 = ARRAY_AGG(x + x ORDER BY x + single DESC),
      r3 = ARRAY_AGG(x ORDER BY single, x)
  return r1, r2, r3
)
--

QueryStmt
+-output_column_list=
| +-$graph_table.r1#10 AS r1 [ARRAY<INT64>]
| +-$graph_table.r2#11 AS r2 [ARRAY<INT64>]
| +-$graph_table.r3#12 AS r3 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[r1#10, r2#11, r3#12]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[r1#10, r2#11, r3#12]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[r1#10, r2#11, r3#12]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[r1#10, r2#11, r3#12]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.single#1]
                  | +-expr_list=
                  | | +-single#1 := Literal(type=INT64, value=3)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2]
                  | +-expr_list=
                  | | +-x#2 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.single#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, r1#4, r2#7, r3#9]
                  | +-expr_list=
                  | | +-r1#4 :=
                  | | | +-ArrayAggregate
                  | | |   +-type=ARRAY<INT64>
                  | | |   +-array=
                  | | |   | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | | |   +-element_column=$horizontal_aggregate.x#3
                  | | |   +-aggregate=
                  | | |     +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | | |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | | |         +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | | +-r2#7 :=
                  | | | +-ArrayAggregate
                  | | |   +-type=ARRAY<INT64>
                  | | |   +-array=
                  | | |   | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | | |   +-element_column=$horizontal_aggregate.x#5
                  | | |   +-pre_aggregate_computed_column_list=
                  | | |   | +-$orderbycol1#6 :=
                  | | |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | | |   |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | | |   |     +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | | |   +-aggregate=
                  | | |     +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | | |       +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#5)
                  | | |       +-order_by_item_list=
                  | | |         +-OrderByItem
                  | | |           +-column_ref=
                  | | |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#6)
                  | | |           +-is_descending=TRUE
                  | | +-r3#9 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     +-element_column=$horizontal_aggregate.x#8
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#8)
                  | |         +-order_by_item_list=
                  | |           +-OrderByItem
                  | |           | +-column_ref=
                  | |           |   +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | |           +-OrderByItem
                  | |             +-column_ref=
                  | |               +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#8)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2])
                  +-ProjectScan
                    +-column_list=$graph_table.[r1#10, r2#11, r3#12]
                    +-expr_list=
                    | +-r1#10 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r1#4)
                    | +-r2#11 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r2#7)
                    | +-r3#12 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r3#9)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[single#1, x#2, r1#4, r2#7, r3#9])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+LIMIT_IN_AGGREGATE,+HAVING_IN_AGGREGATE,+NULL_HANDLING_MODIFIER_IN_AGGREGATE,+ORDER_BY_IN_AGGREGATE]
# All features of ARRAY_AGG
select * from graph_table(aml
  let single = 3
  let x = [4, 5]
  let r1 = ARRAY_AGG(x + single IGNORE NULLS HAVING MAX -x ORDER BY x - single LIMIT 1 )
  # This having min doesn't actually do anything
  let r2 = ARRAY_AGG(DISTINCT x + single IGNORE NULLS HAVING MIN 3 ORDER BY x + single LIMIT 1  )
  let r3 = ARRAY_AGG(if (x = 4, NULL, x) IGNORE NULLS HAVING MIN 3 ORDER BY -x LIMIT 1  )
  return r1, r2, r3
)
--

QueryStmt
+-output_column_list=
| +-$graph_table.r1#12 AS r1 [ARRAY<INT64>]
| +-$graph_table.r2#13 AS r2 [ARRAY<INT64>]
| +-$graph_table.r3#14 AS r3 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[r1#12, r2#13, r3#14]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[r1#12, r2#13, r3#14]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[r1#12, r2#13, r3#14]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[r1#12, r2#13, r3#14]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.single#1]
                  | +-expr_list=
                  | | +-single#1 := Literal(type=INT64, value=3)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2]
                  | +-expr_list=
                  | | +-x#2 := Literal(type=ARRAY<INT64>, value=[4, 5])
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.single#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, r1#5]
                  | +-expr_list=
                  | | +-r1#5 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     +-element_column=$horizontal_aggregate.x#3
                  | |     +-pre_aggregate_computed_column_list=
                  | |     | +-$orderbycol1#4 :=
                  | |     |   +-FunctionCall(ZetaSQL:$subtract(INT64, INT64) -> INT64)
                  | |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |     |     +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |           +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | |         +-null_handling_modifier=IGNORE_NULLS
                  | |         +-having_modifier=
                  | |         | +-AggregateHavingModifier
                  | |         |   +-kind=MAX
                  | |         |   +-having_expr=
                  | |         |     +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
                  | |         |       +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#3)
                  | |         +-order_by_item_list=
                  | |         | +-OrderByItem
                  | |         |   +-column_ref=
                  | |         |     +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
                  | |         +-limit=
                  | |           +-Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, r1#5, r2#8]
                  | +-expr_list=
                  | | +-r2#8 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     +-element_column=$horizontal_aggregate.x#6
                  | |     +-pre_aggregate_computed_column_list=
                  | |     | +-$orderbycol1#7 :=
                  | |     |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                  | |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#6)
                  | |     |     +-ColumnRef(type=INT64, column=$graph_table.single#1)
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
                  | |         +-distinct=TRUE
                  | |         +-null_handling_modifier=IGNORE_NULLS
                  | |         +-having_modifier=
                  | |         | +-AggregateHavingModifier
                  | |         |   +-kind=MIN
                  | |         |   +-having_expr=
                  | |         |     +-Literal(type=INT64, value=3)
                  | |         +-order_by_item_list=
                  | |         | +-OrderByItem
                  | |         |   +-column_ref=
                  | |         |     +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#7)
                  | |         +-limit=
                  | |           +-Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2, r1#5])
                  +-ProjectScan
                  | +-column_list=$graph_table.[single#1, x#2, r1#5, r2#8, r3#11]
                  | +-expr_list=
                  | | +-r3#11 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.x#2)
                  | |     +-element_column=$horizontal_aggregate.x#9
                  | |     +-pre_aggregate_computed_column_list=
                  | |     | +-$orderbycol1#10 :=
                  | |     |   +-FunctionCall(ZetaSQL:$unary_minus(INT64) -> INT64)
                  | |     |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#9)
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(INT64) -> ARRAY<INT64>)
                  | |         +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                  | |           +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                  | |           | +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#9)
                  | |           | +-Literal(type=INT64, value=4)
                  | |           +-Literal(type=INT64, value=NULL)
                  | |           +-ColumnRef(type=INT64, column=$horizontal_aggregate.x#9)
                  | |         +-null_handling_modifier=IGNORE_NULLS
                  | |         +-having_modifier=
                  | |         | +-AggregateHavingModifier
                  | |         |   +-kind=MIN
                  | |         |   +-having_expr=
                  | |         |     +-Literal(type=INT64, value=3)
                  | |         +-order_by_item_list=
                  | |         | +-OrderByItem
                  | |         |   +-column_ref=
                  | |         |     +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#10)
                  | |         +-limit=
                  | |           +-Literal(type=INT64, value=1)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[single#1, x#2, r1#5, r2#8])
                  +-ProjectScan
                    +-column_list=$graph_table.[r1#12, r2#13, r3#14]
                    +-expr_list=
                    | +-r1#12 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r1#5)
                    | +-r2#13 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r2#8)
                    | +-r3#14 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r3#11)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[single#1, x#2, r1#5, r2#8, r3#11])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+LIMIT_IN_AGGREGATE,+HAVING_IN_AGGREGATE,+NULL_HANDLING_MODIFIER_IN_AGGREGATE,+JSON_TYPE,+JSON_CONSTRUCTOR_FUNCTIONS,+JSON_VALUE_EXTRACTION_FUNCTIONS,+ORDER_BY_IN_AGGREGATE]
# ARRAY_AGG with data type that doesn't support equality
select * from graph_table(aml
  let arr = [JSON_OBJECT('foo', 10, 'bar', TRUE), JSON_OBJECT('foo', 11, 'bar', FALSE)]
  let r1 = ARRAY_AGG(arr)
  let r2 = ARRAY_AGG(arr HAVING MAX INT64(JSON_QUERY(arr, '$.foo')))
  return r1, r2
)

--
QueryStmt
+-output_column_list=
| +-$graph_table.r1#6 AS r1 [ARRAY<JSON>]
| +-$graph_table.r2#7 AS r2 [ARRAY<JSON>]
+-query=
  +-ProjectScan
    +-column_list=$graph_table.[r1#6, r2#7]
    +-input_scan=
      +-GraphTableScan
        +-column_list=$graph_table.[r1#6, r2#7]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=$graph_table.[r1#6, r2#7]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=$graph_table.[r1#6, r2#7]
                +-scan_list=
                  +-ProjectScan
                  | +-column_list=[$graph_table.arr#1]
                  | +-expr_list=
                  | | +-arr#1 :=
                  | |   +-FunctionCall(ZetaSQL:$make_array(repeated(2) JSON) -> ARRAY<JSON>)
                  | |     +-FunctionCall(ZetaSQL:json_object(repeated(1) STRING, repeated(1) INT64, repeated(1) STRING, repeated(1) BOOL) -> JSON)
                  | |     | +-Literal(type=STRING, value="foo")
                  | |     | +-Literal(type=INT64, value=10)
                  | |     | +-Literal(type=STRING, value="bar")
                  | |     | +-Literal(type=BOOL, value=true)
                  | |     +-FunctionCall(ZetaSQL:json_object(repeated(1) STRING, repeated(1) INT64, repeated(1) STRING, repeated(1) BOOL) -> JSON)
                  | |       +-Literal(type=STRING, value="foo")
                  | |       +-Literal(type=INT64, value=11)
                  | |       +-Literal(type=STRING, value="bar")
                  | |       +-Literal(type=BOOL, value=false)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=$graph_table.[arr#1, r1#3]
                  | +-expr_list=
                  | | +-r1#3 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<JSON>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<JSON>, column=$graph_table.arr#1)
                  | |     +-element_column=$horizontal_aggregate.arr#2
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(JSON) -> ARRAY<JSON>)
                  | |         +-ColumnRef(type=JSON, column=$horizontal_aggregate.arr#2)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$graph_table.arr#1])
                  +-ProjectScan
                  | +-column_list=$graph_table.[arr#1, r1#3, r2#5]
                  | +-expr_list=
                  | | +-r2#5 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<JSON>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<JSON>, column=$graph_table.arr#1)
                  | |     +-element_column=$horizontal_aggregate.arr#4
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:array_agg(JSON) -> ARRAY<JSON>)
                  | |         +-ColumnRef(type=JSON, column=$horizontal_aggregate.arr#4)
                  | |         +-having_modifier=
                  | |           +-AggregateHavingModifier
                  | |             +-kind=MAX
                  | |             +-having_expr=
                  | |               +-FunctionCall(ZetaSQL:int64(JSON) -> INT64)
                  | |                 +-FunctionCall(ZetaSQL:json_query(JSON, STRING) -> JSON)
                  | |                   +-ColumnRef(type=JSON, column=$horizontal_aggregate.arr#4)
                  | |                   +-Literal(type=STRING, value="$.foo")
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=$graph_table.[arr#1, r1#3])
                  +-ProjectScan
                    +-column_list=$graph_table.[r1#6, r2#7]
                    +-expr_list=
                    | +-r1#6 := ColumnRef(type=ARRAY<JSON>, column=$graph_table.r1#3)
                    | +-r2#7 := ColumnRef(type=ARRAY<JSON>, column=$graph_table.r2#5)
                    +-input_scan=
                      +-GraphRefScan(column_list=$graph_table.[arr#1, r1#3, r2#5])
==

[default no_run_sqlbuilder]
[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]
select * from graph_table(aml
  match (n:Syndicate)-[e]->
  let r1 = ANY_VALUE(n.SyndicateData)
  return r1
)
--
ERROR: Horizontal aggregation without an array-typed variable is not allowed. Normal vertical aggregation is not allowed in this syntactic context [at 3:12]
  let r1 = ANY_VALUE(n.SyndicateData)
           ^
==

# Make sure that ARRAY_AGG is not allowed on an array-typed property when the
# node variable ranges over a quantified path pattern.
[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
select * from graph_table(aml
  match ((n:Syndicate)-[e]->){1,3}
  let r1 = ARRAY_AGG(n.SyndicateData)
  return r1
)
--
ERROR: The argument to ARRAY_AGG must not be an array type but was ARRAY<INT64> [at 3:12]
  let r1 = ARRAY_AGG(n.SyndicateData)
           ^
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
select * from graph_table(aml
  match ((n:Syndicate)-[e]->){1,3}
  let r1 = ANY_VALUE(n.SyndicateData)
  return r1
)
--
QueryStmt
+-output_column_list=
| +-$graph_table.r1#11 AS r1 [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$graph_table.r1#11]
    +-input_scan=
      +-GraphTableScan
        +-column_list=[$graph_table.r1#11]
        +-property_graph=aml
        +-input_scan=
          +-GraphLinearScan
            +-column_list=[$graph_table.r1#11]
            +-scan_list=
              +-GraphLinearScan
                +-column_list=[$graph_table.r1#11]
                +-scan_list=
                  +-GraphScan
                  | +-column_list=[$path_scan.$head#7, $element_table.n#4, $path_scan.$tail#8]
                  | +-input_scan_list=
                  | | +-GraphPathScan
                  | |   +-column_list=[$path_scan.$head#7, $element_table.n#4, $path_scan.$tail#8]
                  | |   +-input_scan_list=
                  | |   | +-GraphNodeScan
                  | |   | | +-column_list=[$element_table.n#1]
                  | |   | | +-label_expr=
                  | |   | | | +-GraphLabel(parse_location=42-51, label=aml.Syndicate)
                  | |   | | +-target_element_table_list=[aml.Syndicate]
                  | |   | +-GraphEdgeScan
                  | |   | | +-column_list=[$element_table.e#2]
                  | |   | | +-label_expr=
                  | |   | | | +-GraphLabelNaryExpr
                  | |   | | |   +-op=OR
                  | |   | | |   +-operand_list=
                  | |   | | |     +-GraphWildCardLabel
                  | |   | | |     +-GraphLabelNaryExpr
                  | |   | | |       +-op=NOT
                  | |   | | |       +-operand_list=
                  | |   | | |         +-GraphWildCardLabel
                  | |   | | +-target_element_table_list=[aml.PersonOwnAccount,aml.Transfer]
                  | |   | | +-orientation=RIGHT
                  | |   | +-GraphNodeScan
                  | |   |   +-column_list=[$element_table.$element1#3]
                  | |   |   +-label_expr=
                  | |   |   | +-GraphLabelNaryExpr
                  | |   |   |   +-op=OR
                  | |   |   |   +-operand_list=
                  | |   |   |     +-GraphWildCardLabel
                  | |   |   |     +-GraphLabelNaryExpr
                  | |   |   |       +-op=NOT
                  | |   |   |       +-operand_list=
                  | |   |   |         +-GraphWildCardLabel
                  | |   |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
                  | |   +-head=$path_scan.$head#7
                  | |   +-tail=$path_scan.$tail#8
                  | |   +-quantifier=
                  | |   | +-GraphPathPatternQuantifier
                  | |   |   +-lower_bound=
                  | |   |   | +-Literal(type=INT64, value=1)
                  | |   |   +-upper_bound=
                  | |   |     +-Literal(type=INT64, value=3)
                  | |   +-group_variable_list=
                  | |     +-GraphMakeArrayVariable(element=$element_table.n#1, array=$element_table.n#4)
                  | |     +-GraphMakeArrayVariable(element=$element_table.e#2, array=$element_table.e#5)
                  | |     +-GraphMakeArrayVariable(element=$element_table.$element1#3, array=$element_table.$element1#6)
                  | +-input_scan=
                  |   +-SingleRowScan
                  +-ProjectScan
                  | +-column_list=[$element_table.n#4, $graph_table.r1#10]
                  | +-expr_list=
                  | | +-r1#10 :=
                  | |   +-ArrayAggregate
                  | |     +-type=ARRAY<INT64>
                  | |     +-array=
                  | |     | +-ColumnRef(type=ARRAY<GRAPH_NODE(aml)<syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>>, column=$element_table.n#4)
                  | |     +-element_column=$horizontal_aggregate.n#9
                  | |     +-aggregate=
                  | |       +-AggregateFunctionCall(ZetaSQL:any_value(ARRAY<INT64>) -> ARRAY<INT64>)
                  | |         +-GraphGetElementProperty
                  | |           +-type=ARRAY<INT64>
                  | |           +-expr=
                  | |           | +-ColumnRef(type=GRAPH_NODE(aml)<syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$horizontal_aggregate.n#9)
                  | |           +-property=syndicateData(ARRAY<INT64>)
                  | +-input_scan=
                  |   +-GraphRefScan(column_list=[$element_table.n#4])
                  +-ProjectScan
                    +-column_list=[$graph_table.r1#11]
                    +-expr_list=
                    | +-r1#11 := ColumnRef(type=ARRAY<INT64>, column=$graph_table.r1#10)
                    +-input_scan=
                      +-GraphRefScan(column_list=[$element_table.n#4, $graph_table.r1#10])
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,+UNNEST_AND_FLATTEN_ARRAYS]
select * from graph_table(aml
  match ((n:Syndicate)-[e]->){1,3}
  let r1 = ARRAY_AGG(n.SyndicateData)
  return r1
)
--
ERROR: The argument to ARRAY_AGG must not be an array type but was ARRAY<INT64> [at 3:12]
  let r1 = ARRAY_AGG(n.SyndicateData)
           ^
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,+UNNEST_AND_FLATTEN_ARRAYS]
select * from graph_table(aml
  match ((n:Syndicate)-[e]->){1,3}
  let r1 = ARRAY_AGG(flatten(n.SyndicateData))
  return r1
)
--
ERROR: Horizontal aggregation expression must not include FLATTEN [at 3:22]
  let r1 = ARRAY_AGG(flatten(n.SyndicateData))
                     ^
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,+UNNEST_AND_FLATTEN_ARRAYS]
select * from graph_table(aml
  match ((n:Syndicate)-[e]->){1,3}
  let r1 = ANY_VALUE(flatten(n.SyndicateData))
  return r1
)
--
ERROR: Horizontal aggregation expression must not include FLATTEN [at 3:22]
  let r1 = ANY_VALUE(flatten(n.SyndicateData))
                     ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+UNNEST_AND_FLATTEN_ARRAYS]
# From b/355303648
graph aml
let arr = [struct([1] as x), struct(null), struct([2])]
let r = SUM(flatten(arr.x))
return r
--
ERROR: Horizontal aggregation expression must not include FLATTEN [at 4:13]
let r = SUM(flatten(arr.x))
            ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+ORDER_BY_IN_AGGREGATE]

graph aml
let arr = [1,2,3]
let r = array_agg(distinct arr)
return r
--
ERROR: Horizontal aggregates are implicitly ordered by the underlying array order unless an explicit ORDER BY is specified. An aggregate function that has both DISTINCT and ORDER BY arguments can only ORDER BY expressions that are arguments to the function [at 3:9]
let r = array_agg(distinct arr)
        ^
==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
MATCH (p:Person WHERE MIN(p.name) = 'John')
return 1 as r
--
ERROR: Aggregate function MIN not allowed in WHERE clause [at 2:23]
MATCH (p:Person WHERE MIN(p.name) = 'John')
                      ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
MATCH (p:Person) WHERE MIN(p.name) = 'John'
return 1 as r
--
ERROR: Horizontal aggregation without an array-typed variable is not allowed. Normal vertical aggregation is not allowed in this syntactic context [at 2:24]
MATCH (p:Person) WHERE MIN(p.name) = 'John'
                       ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
MATCH ((p:Person)-[e]->(p2:Person) WHERE MIN(p.name) = 'John')
return 1 as r
--
ERROR: Horizontal aggregation without an array-typed variable is not allowed. Normal vertical aggregation is not allowed in this syntactic context [at 2:42]
MATCH ((p:Person)-[e]->(p2:Person) WHERE MIN(p.name) = 'John')
                                         ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
let arr = [1,2,3]
MATCH (p:Person WHERE MIN(arr) = 1)
return 1 as r
--
ERROR: Name 'arr', defined in the previous statement, can only be referenced in the outermost WHERE clause of MATCH [at 3:27]
MATCH (p:Person WHERE MIN(arr) = 1)
                          ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
let arr = [1,2,3]
MATCH (p:Person) WHERE MIN(arr) = 1
return 1 as r
--
QueryStmt
+-output_column_list=
| +-$graph_table.r#4 AS r [INT64]
+-query=
  +-GraphTableScan
    +-column_list=[$graph_table.r#4]
    +-property_graph=aml
    +-input_scan=
      +-GraphLinearScan
        +-column_list=[$graph_table.r#4]
        +-scan_list=
          +-GraphLinearScan
            +-column_list=[$graph_table.r#4]
            +-scan_list=
              +-ProjectScan
              | +-column_list=[$graph_table.arr#1]
              | +-expr_list=
              | | +-arr#1 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
              | +-input_scan=
              |   +-SingleRowScan
              +-GraphScan
              | +-column_list=[$graph_table.arr#1, $element_table.p#2]
              | +-input_scan_list=
              | | +-GraphPathScan
              | |   +-column_list=[$element_table.p#2]
              | |   +-input_scan_list=
              | |   | +-GraphNodeScan
              | |   |   +-column_list=[$element_table.p#2]
              | |   |   +-label_expr=
              | |   |   | +-GraphLabel(parse_location=37-43, label=aml.Person)
              | |   |   +-target_element_table_list=[aml.Person]
              | |   +-head=$element_table.p#2
              | |   +-tail=$element_table.p#2
              | +-filter_expr=
              | | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
              | |   +-ArrayAggregate
              | |   | +-type=INT64
              | |   | +-array=
              | |   | | +-ColumnRef(type=ARRAY<INT64>, column=$graph_table.arr#1)
              | |   | +-element_column=$horizontal_aggregate.arr#3
              | |   | +-aggregate=
              | |   |   +-AggregateFunctionCall(ZetaSQL:min(INT64) -> INT64)
              | |   |     +-ColumnRef(type=INT64, column=$horizontal_aggregate.arr#3)
              | |   +-Literal(type=INT64, value=1)
              | +-input_scan=
              |   +-GraphRefScan(column_list=[$graph_table.arr#1])
              +-ProjectScan
                +-column_list=[$graph_table.r#4]
                +-expr_list=
                | +-r#4 := Literal(type=INT64, value=1)
                +-input_scan=
                  +-GraphRefScan(column_list=[$graph_table.arr#1, $element_table.p#2])

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY]

graph aml
let arr = [1,2,3]
MATCH ((p:Person)-[e]->(p2:Person) WHERE MIN(arr) = 1)
return 1 as r
--
ERROR: Name 'arr', defined in the previous statement, can only be referenced in the outermost WHERE clause of MATCH [at 3:46]
MATCH ((p:Person)-[e]->(p2:Person) WHERE MIN(arr) = 1)
                                             ^

==

[language_features=NONE,+SQL_GRAPH,+SQL_GRAPH_ADVANCED_QUERY,+SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]

graph aml
MATCH ((a:Account)-[t:Transfer]->{1}(a2:Account) WHERE MIN(t.amount) = 1)
return 1 as r
--
QueryStmt
+-output_column_list=
| +-$graph_table.r#12 AS r [INT64]
+-query=
  +-GraphTableScan
    +-column_list=[$graph_table.r#12]
    +-property_graph=aml
    +-input_scan=
      +-GraphLinearScan
        +-column_list=[$graph_table.r#12]
        +-scan_list=
          +-GraphLinearScan
            +-column_list=[$graph_table.r#12]
            +-scan_list=
              +-GraphScan
              | +-column_list=[$element_table.a#1, $path_scan.$head#8, $element_table.t#6, $path_scan.$tail#9, $element_table.a2#10]
              | +-input_scan_list=
              | | +-GraphPathScan
              | |   +-column_list=[$element_table.a#1, $path_scan.$head#8, $element_table.t#6, $path_scan.$tail#9, $element_table.a2#10]
              | |   +-input_scan_list=
              | |   | +-GraphNodeScan
              | |   | | +-column_list=[$element_table.a#1]
              | |   | | +-label_expr=
              | |   | | | +-GraphLabel(parse_location=20-27, label=aml.Account)
              | |   | | +-target_element_table_list=[aml.Account]
              | |   | +-GraphPathScan
              | |   | | +-column_list=[$path_scan.$head#8, $element_table.t#6, $path_scan.$tail#9]
              | |   | | +-input_scan_list=
              | |   | | | +-GraphNodeScan
              | |   | | | | +-column_list=[$element_table.$element1#2]
              | |   | | | | +-label_expr=
              | |   | | | | | +-GraphLabelNaryExpr
              | |   | | | | |   +-op=OR
              | |   | | | | |   +-operand_list=
              | |   | | | | |     +-GraphWildCardLabel
              | |   | | | | |     +-GraphLabelNaryExpr
              | |   | | | | |       +-op=NOT
              | |   | | | | |       +-operand_list=
              | |   | | | | |         +-GraphWildCardLabel
              | |   | | | | +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
              | |   | | | +-GraphEdgeScan
              | |   | | | | +-column_list=[$element_table.t#3]
              | |   | | | | +-label_expr=
              | |   | | | | | +-GraphLabel(parse_location=32-40, label=aml.Transfer)
              | |   | | | | +-target_element_table_list=[aml.Transfer]
              | |   | | | | +-orientation=RIGHT
              | |   | | | +-GraphNodeScan
              | |   | | |   +-column_list=[$element_table.$element2#4]
              | |   | | |   +-label_expr=
              | |   | | |   | +-GraphLabelNaryExpr
              | |   | | |   |   +-op=OR
              | |   | | |   |   +-operand_list=
              | |   | | |   |     +-GraphWildCardLabel
              | |   | | |   |     +-GraphLabelNaryExpr
              | |   | | |   |       +-op=NOT
              | |   | | |   |       +-operand_list=
              | |   | | |   |         +-GraphWildCardLabel
              | |   | | |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
              | |   | | +-head=$path_scan.$head#8
              | |   | | +-tail=$path_scan.$tail#9
              | |   | | +-quantifier=
              | |   | | | +-GraphPathPatternQuantifier
              | |   | | |   +-lower_bound=
              | |   | | |   | +-Literal(type=INT64, value=1)
              | |   | | |   +-upper_bound=
              | |   | | |     +-Literal(type=INT64, value=1)
              | |   | | +-group_variable_list=
              | |   | |   +-GraphMakeArrayVariable(element=$element_table.$element1#2, array=$element_table.$element1#5)
              | |   | |   +-GraphMakeArrayVariable(element=$element_table.t#3, array=$element_table.t#6)
              | |   | |   +-GraphMakeArrayVariable(element=$element_table.$element2#4, array=$element_table.$element2#7)
              | |   | +-GraphNodeScan
              | |   |   +-column_list=[$element_table.a2#10]
              | |   |   +-label_expr=
              | |   |   | +-GraphLabel(parse_location=50-57, label=aml.Account)
              | |   |   +-target_element_table_list=[aml.Account]
              | |   +-filter_expr=
              | |   | +-FunctionCall(ZetaSQL:$equal(UINT64, INT64) -> BOOL)
              | |   |   +-ArrayAggregate
              | |   |   | +-type=UINT64
              | |   |   | +-array=
              | |   |   | | +-ColumnRef(type=ARRAY<GRAPH_EDGE(aml)<accountId INT64, amount UINT64, targetAccountId INT64>>, column=$element_table.t#6)
              | |   |   | +-element_column=$horizontal_aggregate.t#11
              | |   |   | +-aggregate=
              | |   |   |   +-AggregateFunctionCall(ZetaSQL:min(UINT64) -> UINT64)
              | |   |   |     +-GraphGetElementProperty
              | |   |   |       +-type=UINT64
              | |   |   |       +-expr=
              | |   |   |       | +-ColumnRef(type=GRAPH_EDGE(aml)<accountId INT64, amount UINT64, targetAccountId INT64>, column=$horizontal_aggregate.t#11)
              | |   |   |       +-property=amount(UINT64)
              | |   |   +-Literal(type=INT64, value=1)
              | |   +-head=$element_table.a#1
              | |   +-tail=$element_table.a2#10
              | +-input_scan=
              |   +-SingleRowScan
              +-ProjectScan
                +-column_list=[$graph_table.r#12]
                +-expr_list=
                | +-r#12 := Literal(type=INT64, value=1)
                +-input_scan=
                  +-GraphRefScan(column_list=$element_table.[a#1, t#6, a2#10])

