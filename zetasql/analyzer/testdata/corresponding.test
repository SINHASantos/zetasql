# CORRESPONDING
[default language_features=NONE]
[default enabled_ast_rewrites=DEFAULTS]
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING for set operations is not supported [at 2:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUPS:
    +CORRESPONDING
    +CORRESPONDING_FULL
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

# CORRESPONDING in multiple operations.
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING
SELECT 3
--
ALTERNATION GROUP: <empty>
--
ERROR: CORRESPONDING for set operations is not supported [at 4:11]
UNION ALL CORRESPONDING
          ^
--
ALTERNATION GROUPS:
    +CORRESPONDING
    +CORRESPONDING_FULL
--
ERROR: Different set operation modifiers cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL CORRESPONDING
          ^
==

# CORRESPONDING BY
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: CORRESPONDING BY for set operations is not supported [at 2:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: The column name a from the CORRESPONDING BY list does not appear in query 1. All columns in the BY list must appear in each input query unless FULL CORRESPONDING or LEFT CORRESPONDING is specified [at 2:29]
UNION ALL CORRESPONDING BY (a, b, c)
                            ^
==

# CORRESPONDING BY in multiple operations
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION ALL
SELECT 2
UNION ALL CORRESPONDING BY (a, b, c)
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: CORRESPONDING BY for set operations is not supported [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: Different set operation modifiers cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL CORRESPONDING BY (a, b, c)
          ^
==

# STRICT without CORRESPONDING
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION DISTINCT STRICT
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (STRICT) for set operations is not supported [at 2:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 2:16]
UNION DISTINCT STRICT
               ^
==

# STRICT without CORRESPONDING in multiple set operations
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION DISTINCT
SELECT 2
UNION DISTINCT STRICT
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (STRICT) for set operations is not supported [at 4:16]
UNION DISTINCT STRICT
               ^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: STRICT in set operations cannot be used without CORRESPONDING [at 4:16]
UNION DISTINCT STRICT
               ^
==

# FULL without CORRESPONDING
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
FULL EXCEPT ALL
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (FULL) for set operations is not supported [at 2:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 2:1]
FULL EXCEPT ALL
^
==

# FULL without CORRESPONDING in multiple operations
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
EXCEPT ALL
SELECT 2
FULL EXCEPT ALL
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (FULL) for set operations is not supported [at 4:1]
FULL EXCEPT ALL
^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: FULL in set operations cannot be used without CORRESPONDING [at 4:1]
FULL EXCEPT ALL
^
==

# LEFT without CORRESPONDING
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
LEFT EXCEPT ALL
SELECT 2
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (LEFT) for set operations is not supported [at 2:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 2:1]
LEFT EXCEPT ALL
^
==

# LEFT without CORRESPONDING in multiple set operations
[language_features=NONE,{{|+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
EXCEPT ALL
SELECT 2
LEFT EXCEPT ALL
SELECT 3
--
ALTERNATION GROUPS:
    <empty>
    +CORRESPONDING
--
ERROR: Column propagation mode (LEFT) for set operations is not supported [at 4:1]
LEFT EXCEPT ALL
^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: LEFT in set operations cannot be used without CORRESPONDING [at 4:1]
LEFT EXCEPT ALL
^
==

[language_features=NONE,{{+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
{{FULL|LEFT}} UNION ALL CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: +CORRESPONDING,FULL
--
ERROR: Column propagation mode (FULL) for set operations is not supported [at 2:1]
FULL UNION ALL CORRESPONDING
^
--
ALTERNATION GROUP: +CORRESPONDING,LEFT
--
ERROR: Column propagation mode (LEFT) for set operations is not supported [at 2:1]
LEFT UNION ALL CORRESPONDING
^
--
ALTERNATION GROUPS:
    +CORRESPONDING_FULL,FULL
    +CORRESPONDING_FULL,LEFT
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

[language_features=NONE,{{+CORRESPONDING|+CORRESPONDING_FULL}}]
SELECT 1
UNION ALL STRICT CORRESPONDING
SELECT 2
--
ALTERNATION GROUP: +CORRESPONDING
--
ERROR: Column propagation mode (STRICT) for set operations is not supported [at 2:11]
UNION ALL STRICT CORRESPONDING
          ^
--
ALTERNATION GROUP: +CORRESPONDING_FULL
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1
^
==

[default language_features=NONE,{{+CORRESPONDING|+CORRESPONDING_FULL}},+BY_NAME]
# CORRESPONDING: same columns at same index.
SELECT 1 AS col1, 2 AS col2
{{EXCEPT DISTINCT CORRESPONDING|INNER EXCEPT DISTINCT BY NAME}}
SELECT 3 AS col1, 4 AS col2
--
ALTERNATION GROUPS:
    +CORRESPONDING,EXCEPT DISTINCT CORRESPONDING
    +CORRESPONDING_FULL,EXCEPT DISTINCT CORRESPONDING
    +CORRESPONDING_FULL,INNER EXCEPT DISTINCT BY NAME
--
QueryStmt
+-output_column_list=
| +-$except_distinct.col1#5 AS col1 [INT64]
| +-$except_distinct.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[col1#5, col2#6]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$except_distinct1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$except_distinct1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_distinct2.[col1#3, col2#4]
    |   |   +-expr_list=
    |   |   | +-col1#3 := Literal(type=INT64, value=3)
    |   |   | +-col2#4 := Literal(type=INT64, value=4)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$except_distinct2.[col1#3, col2#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
--
ALTERNATION GROUP: +CORRESPONDING,INNER EXCEPT DISTINCT BY NAME
--
ERROR: BY NAME for set operations is not supported [at 3:23]
INNER EXCEPT DISTINCT BY NAME
                      ^
==

# CORRESPONDING: same columns at different index, the output column order is
# determined by the first query.
SELECT 1 AS col1, 2 AS col2
{{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
SELECT 3 AS col2, 4 AS col1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.col1#5 AS col1 [INT64]
| +-$intersect_all.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[col1#5, col2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[col1#1, col2#2]
    | | |   +-expr_list=
    | | |   | +-col1#1 := Literal(type=INT64, value=1)
    | | |   | +-col2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[col1#1, col2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[col1#4, col2#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all2.[col2#3, col1#4]
    |   |       +-expr_list=
    |   |       | +-col2#3 := Literal(type=INT64, value=3)
    |   |       | +-col1#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[col1#4, col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: extra columns are ignored.
SELECT 1 AS col, 2 AS extra_col_1
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 3 AS extra_col_2, 4 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#5 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[col#1, extra_col_1#2]
    | | |       +-expr_list=
    | | |       | +-col#1 := Literal(type=INT64, value=1)
    | | |       | +-extra_col_1#2 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[extra_col_2#3, col#4]
    |   |       +-expr_list=
    |   |       | +-extra_col_2#3 := Literal(type=INT64, value=3)
    |   |       | +-col#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: column name comparison is case-insensitive.
SELECT 1 AS cOl1, 2 AS CoL2
{{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
SELECT 3 AS Col2, 4 AS cOL1
--
QueryStmt
+-output_column_list=
| +-$intersect_all.cOl1#5 AS cOl1 [INT64]
| +-$intersect_all.CoL2#6 AS CoL2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[cOl1#5, CoL2#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | | |   +-expr_list=
    | | |   | +-cOl1#1 := Literal(type=INT64, value=1)
    | | |   | +-CoL2#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[cOl1#1, CoL2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all2.[cOL1#4, Col2#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all2.[Col2#3, cOL1#4]
    |   |       +-expr_list=
    |   |       | +-Col2#3 := Literal(type=INT64, value=3)
    |   |       | +-cOL1#4 := Literal(type=INT64, value=4)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_all2.[cOL1#4, Col2#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: duplicate columns are not allowed.
SELECT 1 AS col1, 2 AS col2
{{EXCEPT DISTINCT CORRESPONDING|INNER EXCEPT DISTINCT BY NAME}}
SELECT 3 AS col2, 4 AS col2
--
ALTERNATION GROUP: EXCEPT DISTINCT CORRESPONDING
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: col2 in query 2 [at 3:1]
SELECT 3 AS col2, 4 AS col2
^
--
ALTERNATION GROUP: INNER EXCEPT DISTINCT BY NAME
--
ERROR: Duplicate columns found when using BY NAME in set operations: col2 in query 2 [at 3:1]
SELECT 3 AS col2, 4 AS col2
^
==

# CORRESPONDING: duplicate columns are not allowed (case-insensitive).
SELECT 1 AS col1, 2 AS COL1
{{EXCEPT DISTINCT CORRESPONDING|INNER EXCEPT DISTINCT BY NAME}}
SELECT 3 AS col2, 4 AS col3
--
ALTERNATION GROUP: EXCEPT DISTINCT CORRESPONDING
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: COL1 in query 1 [at 1:1]
SELECT 1 AS col1, 2 AS COL1
^
--
ALTERNATION GROUP: INNER EXCEPT DISTINCT BY NAME
--
ERROR: Duplicate columns found when using BY NAME in set operations: COL1 in query 1 [at 1:1]
SELECT 1 AS col1, 2 AS COL1
^
==

# CORRESPONDING: duplicate columns in SELECT *.
SELECT *, 1 AS c
FROM (
  SELECT 1 AS a, 1 AS a
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS c
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS c
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Duplicate columns found when using BY NAME in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS c
^
==

# CORRESPONDING: duplicate columns with SELECT *: '*' expands to multiple
# columns, one of which has the same name as a column outside '*'. Error
# location should be the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1 AS a, 2 AS b
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS a
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Duplicate columns found when using CORRESPONDING in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS a
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Duplicate columns found when using BY NAME in set operations: a in query 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: no common columns.
SELECT 1 AS col1, 2 AS col2
{{UNION DISTINCT CORRESPONDING|INNER UNION DISTINCT BY NAME}}
SELECT 3 AS col3, 4 AS col4
--
ALTERNATION GROUP: UNION DISTINCT CORRESPONDING
--
ERROR: Queries of the set operation using CORRESPONDING do not have any columns in common [at 2:1]
UNION DISTINCT CORRESPONDING
^
--
ALTERNATION GROUP: INNER UNION DISTINCT BY NAME
--
ERROR: Queries of the set operation using BY NAME do not have any columns in common [at 2:7]
INNER UNION DISTINCT BY NAME
      ^
==

# CORRESPONDING: value table not allowed.
SELECT AS STRUCT 1 a, 2 b
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT AS STRUCT 3 c, 4 d
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
UNION ALL CORRESPONDING
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Value table type not allowed in set operations when BY NAME is used: query 1 [at 2:7]
INNER UNION ALL BY NAME
      ^
==

# CORRESPONDING: anonymous columns are not allowed.
SELECT 1, 2
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 4, 5
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, 2
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: query 1, column 1 [at 1:1]
SELECT 1, 2
^
==

# CORRESPONDING: SELECT * with anonymous columns. Error is reported at the start
# of the query because we cannot always find the ast location of a resolved
# column.
SELECT 1, *
FROM (
  SELECT 1 AS a, 2 AS b
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS a
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT 1, *
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: query 1, column 1 [at 1:1]
SELECT 1, *
^
==

# CORRESPONDING: SELECT * with anonymous columns.
SELECT *, 1
FROM (
  SELECT 1 AS a
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS a
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 2 [at 1:1]
SELECT *, 1
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: query 1, column 2 [at 1:1]
SELECT *, 1
^
==

# CORRESPONDING: SELECT * expands to containing anonymous columns.
# Error is reported at the start of the query.
SELECT *, 1 AS a
FROM (
  SELECT 1, 2 AS c
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS a
--
ALTERNATION GROUP: UNION ALL CORRESPONDING
--
ERROR: Anonymous columns are not allowed in set operations when CORRESPONDING is used: query 1, column 1 [at 1:1]
SELECT *, 1 AS a
^
--
ALTERNATION GROUP: INNER UNION ALL BY NAME
--
ERROR: Anonymous columns are not allowed in set operations when BY NAME is used: query 1, column 1 [at 1:1]
SELECT *, 1 AS a
^
==

# CORRESPONDING: same column with different alias within a query is allowed.
SELECT `int32` AS col1, `int32` AS col2
FROM SimpleTypes
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT `float` AS col2, `float` AS col1
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#39 AS col1 [DOUBLE]
| +-$union_all.col2#40 AS col2 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#39, col2#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1_cast.[int32#41, int32#42]
    | | |   +-expr_list=
    | | |   | +-int32#41 :=
    | | |   | | +-Cast(INT32 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-int32#42 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=$union_all1_cast.[int32#41, int32#42]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[float#44, float#43]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2_cast.[float#43, float#44]
    |   |       +-expr_list=
    |   |       | +-float#43 :=
    |   |       | | +-Cast(FLOAT -> DOUBLE)
    |   |       | |   +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | +-float#44 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[float#27, float#27]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.float#27], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=$union_all2_cast.[float#44, float#43]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: same column with and without alias.
SELECT `int32` AS col, `int32` FROM SimpleTypes
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT `float`, `float` AS col FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#39 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#39]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#40]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1_cast.int32#40, SimpleTypes.int32#1]
    | | |       +-expr_list=
    | | |       | +-int32#40 :=
    | | |       |   +-Cast(INT32 -> DOUBLE)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=SimpleTypes.[int32#1, int32#1]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#1], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all1_cast.int32#40]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.float#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.float#27, $union_all2_cast.float#41]
    |   |       +-expr_list=
    |   |       | +-float#41 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[float#27, float#27]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.float#27], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all2_cast.float#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations.
SELECT * FROM
(
  SELECT 'abc' AS col, 'bcd' AS extra_col
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 'def' AS col
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$union_all.col#4]
    +-input_scan=
      +-SetOperationScan
        +-column_list=[$union_all.col#4]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=[$union_all1.col#1]
        | | |   +-node_source="resolver_set_operation_corresponding"
        | | |   +-input_scan=
        | | |     +-ProjectScan
        | | |       +-column_list=$union_all1.[col#1, extra_col#2]
        | | |       +-expr_list=
        | | |       | +-col#1 := Literal(type=STRING, value="abc")
        | | |       | +-extra_col#2 := Literal(type=STRING, value="bcd")
        | | |       +-input_scan=
        | | |         +-SingleRowScan
        | | +-output_column_list=[$union_all1.col#1]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$union_all2.col#3]
        |   |   +-expr_list=
        |   |   | +-col#3 := Literal(type=STRING, value="def")
        |   |   +-input_scan=
        |   |     +-SingleRowScan
        |   +-output_column_list=[$union_all2.col#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: no common supertype.
select 1 AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select 'abc' AS col
--
ERROR: Column col in UNION ALL has incompatible types: INT64, STRING [at 3:1]
select 'abc' AS col
^
==

# CORRESPONDING: different (non-literal) types coerce to a common supertype.
# We wrap an extra ProjectScan around the first query to coerce it to double.
SELECT 'a' a, 1 + 1 v1
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 'a' b, 1.0 + 1.0 v1
--
QueryStmt
+-output_column_list=
| +-$union_all.v1#5 AS v1 [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.v1#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.v1#6]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.a#1, $union_all1_cast.v1#6]
    | | |       +-expr_list=
    | | |       | +-v1#6 :=
    | | |       |   +-Cast(INT64 -> DOUBLE)
    | | |       |     +-ColumnRef(type=INT64, column=$union_all1.v1#2)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=$union_all1.[a#1, v1#2]
    | | |           +-expr_list=
    | | |           | +-a#1 := Literal(type=STRING, value="a")
    | | |           | +-v1#2 :=
    | | |           |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | | |           |     +-Literal(type=INT64, value=1)
    | | |           |     +-Literal(type=INT64, value=1)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.v1#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.v1#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, v1#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=STRING, value="a")
    |   |       | +-v1#4 :=
    |   |       |   +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |   |       |     +-Literal(type=DOUBLE, value=1)
    |   |       |     +-Literal(type=DOUBLE, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.v1#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Extra columns are omitted from table scan.
SELECT `uint32`, `float`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `uint32`, `json`
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `json`, `uint32`
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.uint32#58 AS uint32 [UINT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint32#58]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint32#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[uint32#3, float#8]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, float#8], table=SimpleTypes, column_index_list=[2, 7])
    | | +-output_column_list=[SimpleTypes.uint32#3]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint32#22]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[uint32#22, json#37]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[uint32#22, json#37], table=SimpleTypes, column_index_list=[2, 17])
    | | +-output_column_list=[SimpleTypes.uint32#22]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.uint32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[json#56, uint32#41]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[uint32#41, json#56], table=SimpleTypes, column_index_list=[2, 17])
    |   +-output_column_list=[SimpleTypes.uint32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in BY_POSITION.
(
  SELECT int32, int64, float FROM SimpleTypes
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT int64, int32 FROM SimpleTypes
)
UNION ALL
SELECT int32, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#60 AS int32 [INT32]
| +-$union_all.int64#61 AS int64 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#60, int64#61]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-SetOperationScan
      | |   +-column_list=$union_all.[int32#39, int64#40]
      | |   +-op_type=UNION_ALL
      | |   +-input_item_list=
      | |   | +-SetOperationItem
      | |   | | +-scan=
      | |   | | | +-ProjectScan
      | |   | | |   +-column_list=SimpleTypes.[int32#1, int64#2]
      | |   | | |   +-node_source="resolver_set_operation_corresponding"
      | |   | | |   +-input_scan=
      | |   | | |     +-ProjectScan
      | |   | | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
      | |   | | |       +-input_scan=
      | |   | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
      | |   | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
      | |   | +-SetOperationItem
      | |   |   +-scan=
      | |   |   | +-ProjectScan
      | |   |   |   +-column_list=SimpleTypes.[int32#20, int64#21]
      | |   |   |   +-node_source="resolver_set_operation_corresponding"
      | |   |   |   +-input_scan=
      | |   |   |     +-ProjectScan
      | |   |   |       +-column_list=SimpleTypes.[int64#21, int32#20]
      | |   |   |       +-input_scan=
      | |   |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
      | |   |   +-output_column_list=SimpleTypes.[int32#20, int64#21]
      | |   +-column_match_mode=CORRESPONDING
      | |   +-column_propagation_mode=INNER
      | +-output_column_list=$union_all.[int32#39, int64#40]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypes.int32#41, $union_all2_cast.int32#62]
        |   +-expr_list=
        |   | +-int32#62 :=
        |   |   +-Cast(INT32 -> INT64)
        |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#41)
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypes.[int32#41, int32#41]
        |       +-input_scan=
        |         +-TableScan(column_list=[SimpleTypes.int32#41], table=SimpleTypes, column_index_list=[0])
        +-output_column_list=[SimpleTypes.int32#41, $union_all2_cast.int32#62]
==

# CORRESPONDING: Set operation with CORRESPONDING as an input item for another
# set operation: CORREPSPONDING in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT int64, int32 FROM SimpleTypes
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#60 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.int32#60]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all.int32#39]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$union_all.[int32#39, int64#40]
    | | |       +-op_type=UNION_ALL
    | | |       +-input_item_list=
    | | |       | +-SetOperationItem
    | | |       | | +-scan=
    | | |       | | | +-ProjectScan
    | | |       | | |   +-column_list=SimpleTypes.[int32#1, int64#2]
    | | |       | | |   +-node_source="resolver_set_operation_corresponding"
    | | |       | | |   +-input_scan=
    | | |       | | |     +-ProjectScan
    | | |       | | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |       | | |       +-input_scan=
    | | |       | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |       | | +-output_column_list=SimpleTypes.[int32#1, int64#2]
    | | |       | +-SetOperationItem
    | | |       |   +-scan=
    | | |       |   | +-ProjectScan
    | | |       |   |   +-column_list=SimpleTypes.[int32#20, int64#21]
    | | |       |   |   +-node_source="resolver_set_operation_corresponding"
    | | |       |   |   +-input_scan=
    | | |       |   |     +-ProjectScan
    | | |       |   |       +-column_list=SimpleTypes.[int64#21, int32#20]
    | | |       |   |       +-input_scan=
    | | |       |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    | | |       |   +-output_column_list=SimpleTypes.[int32#20, int64#21]
    | | |       +-column_match_mode=CORRESPONDING
    | | |       +-column_propagation_mode=INNER
    | | +-output_column_list=[$union_all.int32#39]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.int32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#41, float#48]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#41, float#48], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[SimpleTypes.int32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation as an input item for another set operation:
# BY_POSITION in CORRESPONDING.
(
  SELECT int32, int64, float FROM SimpleTypes
  UNION ALL
  SELECT int64, int32, int64 FROM SimpleTypes
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int32#65 AS int32 [INT64]
| +-$union_all.float#66 AS float [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int32#65, float#66]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all.[int32#39, float#41]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$union_all.[int32#39, int64#40, float#41]
    | | |       +-op_type=UNION_ALL
    | | |       +-input_item_list=
    | | |         +-SetOperationItem
    | | |         | +-scan=
    | | |         | | +-ProjectScan
    | | |         | |   +-column_list=[$union_all1_cast.int32#42, SimpleTypes.int64#2, $union_all1_cast.float#43]
    | | |         | |   +-expr_list=
    | | |         | |   | +-int32#42 :=
    | | |         | |   | | +-Cast(INT32 -> INT64)
    | | |         | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |         | |   | +-float#43 :=
    | | |         | |   |   +-Cast(FLOAT -> DOUBLE)
    | | |         | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |         | |   +-input_scan=
    | | |         | |     +-ProjectScan
    | | |         | |       +-column_list=SimpleTypes.[int32#1, int64#2, float#8]
    | | |         | |       +-input_scan=
    | | |         | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, float#8], table=SimpleTypes, column_index_list=[0, 1, 7])
    | | |         | +-output_column_list=[$union_all1_cast.int32#42, SimpleTypes.int64#2, $union_all1_cast.float#43]
    | | |         +-SetOperationItem
    | | |           +-scan=
    | | |           | +-ProjectScan
    | | |           |   +-column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, $union_all2_cast.int64#45]
    | | |           |   +-expr_list=
    | | |           |   | +-int32#44 :=
    | | |           |   | | +-Cast(INT32 -> INT64)
    | | |           |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |           |   | +-int64#45 :=
    | | |           |   |   +-Cast(INT64 -> DOUBLE)
    | | |           |   |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#21)
    | | |           |   +-input_scan=
    | | |           |     +-ProjectScan
    | | |           |       +-column_list=SimpleTypes.[int64#21, int32#20, int64#21]
    | | |           |       +-input_scan=
    | | |           |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    | | |           +-output_column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, $union_all2_cast.int64#45]
    | | +-output_column_list=$union_all.[int32#39, float#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2_cast.[int32#67, float#68]
    |   |   +-expr_list=
    |   |   | +-int32#67 :=
    |   |   | | +-Cast(INT32 -> INT64)
    |   |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#46)
    |   |   | +-float#68 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#53)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#46, float#53]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#46, float#53], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=$union_all2_cast.[int32#67, float#68]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: The edge case of SELECT DISTINCT is handled correctly despite
# the missing ProjectScan issue mentioned in b/36095506.
SELECT DISTINCT a AS col1, b AS col2, a AS col3
FROM (
  SELECT 1 AS a, 2 AS b
)
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT 1 AS col3, 1 AS col1, 2 AS col2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#8 AS col1 [INT64]
| +-$union_all.col2#9 AS col2 [INT64]
| +-$union_all.col3#10 AS col3 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#8, col2#9, col3#10]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$distinct.[a#3, b#4, a#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-AggregateScan
    | | |       +-column_list=$distinct.[a#3, b#4]
    | | |       +-input_scan=
    | | |       | +-ProjectScan
    | | |       |   +-column_list=$subquery1.[a#1, b#2]
    | | |       |   +-expr_list=
    | | |       |   | +-a#1 := Literal(type=INT64, value=1)
    | | |       |   | +-b#2 := Literal(type=INT64, value=2)
    | | |       |   +-input_scan=
    | | |       |     +-SingleRowScan
    | | |       +-group_by_list=
    | | |         +-a#3 := ColumnRef(type=INT64, column=$subquery1.a#1)
    | | |         +-b#4 := ColumnRef(type=INT64, column=$subquery1.b#2)
    | | +-output_column_list=$distinct.[a#3, b#4, a#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[col1#6, col2#7, col3#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[col3#5, col1#6, col2#7]
    |   |       +-expr_list=
    |   |       | +-col3#5 := Literal(type=INT64, value=1)
    |   |       | +-col1#6 := Literal(type=INT64, value=1)
    |   |       | +-col2#7 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[col1#6, col2#7, col3#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two of the same proto and proto + string literal.
select KitchenSink AS col, KitchenSink from TestTable
{{union all CORRESPONDING|INNER union all BY NAME}}
select KitchenSink, "int64_key_1: 1, int64_key_2: 2" AS col from TestTable
--
QueryStmt
+-output_column_list=
| +-$union_all.col#8 AS col [PROTO<zetasql_test__.KitchenSinkPB>]
| +-$union_all.KitchenSink#9 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col#8, KitchenSink#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
    | | +-output_column_list=TestTable.[KitchenSink#3, KitchenSink#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[TestTable.KitchenSink#6, $union_all2_cast.col#10]
    |   |       +-expr_list=
    |   |       | +-col#10 := Literal(type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: 2})
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[TestTable.KitchenSink#6, $union_all2.col#7]
    |   |           +-expr_list=
    |   |           | +-col#7 := Literal(type=STRING, value="int64_key_1: 1, int64_key_2: 2")
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[TestTable.KitchenSink#6], table=TestTable, column_index_list=[2])
    |   +-output_column_list=[$union_all2_cast.col#10, TestTable.KitchenSink#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union two different protos.
select 1 AS extra_1, KitchenSink.message_with_nulls AS col from TestTable
{{union all CORRESPONDING|INNER union all BY NAME}}
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
--
ERROR: Column col in UNION ALL has incompatible types: zetasql_test__.MessageWithNulls, zetasql_test__.KitchenSinkPB.Nested [at 3:1]
select KitchenSink.nested_value AS col, 2 AS extra_2 from TestTable
^
==

# CORRESPONDING: Incompatible types in multiple operations.
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select key from KeyValue union all CORRESPONDING
select cast(5 as int64) AS key union all CORRESPONDING
select cast(5 as int32) AS key union all CORRESPONDING
select 5 AS key union all CORRESPONDING
select value AS key from KeyValue union all CORRESPONDING
select key from KeyValue
--
ERROR: Column key in UNION ALL has incompatible types: INT64, INT64, INT64, INT64, INT64, INT32, INT64, STRING, INT64 [at 2:1]
select key from KeyValue union all CORRESPONDING
^
==

# CORRESPONDING: Multiple columns, some of which have to get widened in either direction.
select `int32` AS col1, `uint32` AS col2, `string` AS col3 from SimpleTypes s1
{{union all CORRESPONDING|INNER union all BY NAME}}
select `string` AS col3, `int32` AS col2, `int64` AS col1, from SimpleTypes s2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#39 AS col1 [INT64]
| +-$union_all.col2#40 AS col2 [INT64]
| +-$union_all.col3#41 AS col3 [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#39, col2#40, col3#41]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.int32#42, $union_all1_cast.uint32#43, SimpleTypes.string#5]
    | | |   +-expr_list=
    | | |   | +-int32#42 :=
    | | |   | | +-Cast(INT32 -> INT64)
    | | |   | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   | +-uint32#43 :=
    | | |   |   +-Cast(UINT32 -> INT64)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#1, uint32#3, string#5]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3, string#5], table=SimpleTypes, column_index_list=[0, 2, 4], alias="s1")
    | | +-output_column_list=[$union_all1_cast.int32#42, $union_all1_cast.uint32#43, SimpleTypes.string#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, SimpleTypes.string#24]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.string#24, $union_all2_cast.int32#44, SimpleTypes.int64#21]
    |   |       +-expr_list=
    |   |       | +-int32#44 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[string#24, int32#20, int64#21]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[int32#20, int64#21, string#24], table=SimpleTypes, column_index_list=[0, 1, 4], alias="s2")
    |   +-output_column_list=[SimpleTypes.int64#21, $union_all2_cast.int32#44, SimpleTypes.string#24]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Nested operations output column names are ordered according to the first query.
SELECT *
FROM (
  SELECT 1 AS col1, 2 AS col2
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 1 AS col2, 2 AS col1
)
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#5 AS col1 [INT64]
| +-$union_all.col2#6 AS col2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$union_all.[col1#5, col2#6]
    +-input_scan=
      +-SetOperationScan
        +-column_list=$union_all.[col1#5, col2#6]
        +-op_type=UNION_ALL
        +-input_item_list=
        | +-SetOperationItem
        | | +-scan=
        | | | +-ProjectScan
        | | |   +-column_list=$union_all1.[col1#1, col2#2]
        | | |   +-expr_list=
        | | |   | +-col1#1 := Literal(type=INT64, value=1)
        | | |   | +-col2#2 := Literal(type=INT64, value=2)
        | | |   +-input_scan=
        | | |     +-SingleRowScan
        | | +-output_column_list=$union_all1.[col1#1, col2#2]
        | +-SetOperationItem
        |   +-scan=
        |   | +-ProjectScan
        |   |   +-column_list=$union_all2.[col1#4, col2#3]
        |   |   +-node_source="resolver_set_operation_corresponding"
        |   |   +-input_scan=
        |   |     +-ProjectScan
        |   |       +-column_list=$union_all2.[col2#3, col1#4]
        |   |       +-expr_list=
        |   |       | +-col2#3 := Literal(type=INT64, value=1)
        |   |       | +-col1#4 := Literal(type=INT64, value=2)
        |   |       +-input_scan=
        |   |         +-SingleRowScan
        |   +-output_column_list=$union_all2.[col1#4, col2#3]
        +-column_match_mode=CORRESPONDING
        +-column_propagation_mode=INNER
==

# CORRESPONDING: coercion with NULL.
SELECT NULL AS timestamp FROM SimpleTypes
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
SELECT timestamp FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.timestamp#40 AS timestamp [TIMESTAMP]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.timestamp#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.timestamp#41]
    | | |   +-expr_list=
    | | |   | +-timestamp#41 := Literal(type=TIMESTAMP, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.timestamp#20]
    | | |       +-expr_list=
    | | |       | +-timestamp#20 := Literal(type=INT64, value=NULL)
    | | |       +-input_scan=
    | | |         +-TableScan(table=SimpleTypes)
    | | +-output_column_list=[$union_all1_cast.timestamp#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[SimpleTypes.timestamp#35]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[SimpleTypes.timestamp#35], table=SimpleTypes, column_index_list=[14])
    |   +-output_column_list=[SimpleTypes.timestamp#35]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two identical structs works.
# Field names are determined from the first leg of the union.
select (select AS STRUCT 1 a, 2 bbB) AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select (select AS STRUCT 3 a, 4 Bbb) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, bbB INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, bbB INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.bbB#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, bbB#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-bbB#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, Bbb INT64>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.Bbb#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, Bbb#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-Bbb#6 := Literal(type=INT64, value=4)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two STRUCTs with different column/field names.
# Note that the second input to the union has the STRUCT field casted to a STRUCT
# with the same field names as the STRUCT from the first input to the union.
select (select AS STRUCT 1 a, 2 b) AS foo
{{union all CORRESPONDING|INNER union all BY NAME}}
select (select AS STRUCT 3 b, 4 c) as foo
--
QueryStmt
+-output_column_list=
| +-$union_all.foo#9 AS foo [STRUCT<a INT64, b INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.foo#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.foo#4]
    | | |   +-expr_list=
    | | |   | +-foo#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<a INT64, b INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<a INT64, b INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |   |             +-expr_list=
    | | |   |             | +-a#1 := Literal(type=INT64, value=1)
    | | |   |             | +-b#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.foo#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.foo#10]
    |   |   +-expr_list=
    |   |   | +-foo#10 :=
    |   |   |   +-Cast(STRUCT<b INT64, c INT64> -> STRUCT<a INT64, b INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<b INT64, c INT64>, column=$union_all2.foo#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.foo#8]
    |   |       +-expr_list=
    |   |       | +-foo#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<b INT64, c INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<b INT64, c INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.c#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[b#5, c#6]
    |   |       |             +-expr_list=
    |   |       |             | +-b#5 := Literal(type=INT64, value=3)
    |   |       |             | +-c#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.foo#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of a STRUCT value table and non-value table not allowed.
select AS STRUCT 1 a, 2 b
union all {{CORRESPONDING|BY NAME}}
select STRUCT<c int64, d int64>(3, 4) as e
--
ALTERNATION GROUP: CORRESPONDING
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 1 [at 2:1]
union all CORRESPONDING
^
--
ALTERNATION GROUP: BY NAME
--
ERROR: Value table type not allowed in set operations when BY NAME is used: query 1 [at 2:1]
union all BY NAME
^
==

# CORRESPONDING: UNION of a non-value table and STRUCT value table not allowed.
select STRUCT<c int64, d int64>(3, 4) as e
union all {{CORRESPONDING|BY NAME}}
select AS STRUCT 1 a, 2 b
--
ALTERNATION GROUP: CORRESPONDING
--
ERROR: Value table type not allowed in set operations when CORRESPONDING is used: query 2 [at 2:1]
union all CORRESPONDING
^
--
ALTERNATION GROUP: BY NAME
--
ERROR: Value table type not allowed in set operations when BY NAME is used: query 2 [at 2:1]
union all BY NAME
^
==

# CORRESPONDING: Union of two coercible structs types.
select (select AS STRUCT 1 a, 2 b) AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select (select AS STRUCT 3 a, 4.5 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<a INT64, b DOUBLE>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#10]
    | | |   +-expr_list=
    | | |   | +-col#10 :=
    | | |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<a INT64, b DOUBLE>)
    | | |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all1.col#4)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#4]
    | | |       +-expr_list=
    | | |       | +-col#4 :=
    | | |       |   +-SubqueryExpr
    | | |       |     +-type=STRUCT<a INT64, b INT64>
    | | |       |     +-subquery_type=SCALAR
    | | |       |     +-subquery=
    | | |       |       +-ProjectScan
    | | |       |         +-column_list=[$make_struct.$struct#3]
    | | |       |         +-expr_list=
    | | |       |         | +-$struct#3 :=
    | | |       |         |   +-MakeStruct
    | | |       |         |     +-type=STRUCT<a INT64, b INT64>
    | | |       |         |     +-field_list=
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#1)
    | | |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#2)
    | | |       |         +-input_scan=
    | | |       |           +-ProjectScan
    | | |       |             +-column_list=$expr_subquery.[a#1, b#2]
    | | |       |             +-expr_list=
    | | |       |             | +-a#1 := Literal(type=INT64, value=1)
    | | |       |             | +-b#2 := Literal(type=INT64, value=2)
    | | |       |             +-input_scan=
    | | |       |               +-SingleRowScan
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#10]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#8]
    |   |   +-expr_list=
    |   |   | +-col#8 :=
    |   |   |   +-SubqueryExpr
    |   |   |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |     +-subquery_type=SCALAR
    |   |   |     +-subquery=
    |   |   |       +-ProjectScan
    |   |   |         +-column_list=[$make_struct.$struct#7]
    |   |   |         +-expr_list=
    |   |   |         | +-$struct#7 :=
    |   |   |         |   +-MakeStruct
    |   |   |         |     +-type=STRUCT<a INT64, b DOUBLE>
    |   |   |         |     +-field_list=
    |   |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |   |         |       +-ColumnRef(type=DOUBLE, column=$expr_subquery.b#6)
    |   |   |         +-input_scan=
    |   |   |           +-ProjectScan
    |   |   |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |   |             +-expr_list=
    |   |   |             | +-a#5 := Literal(type=INT64, value=3)
    |   |   |             | +-b#6 := Literal(type=DOUBLE, value=4.5)
    |   |   |             +-input_scan=
    |   |   |               +-SingleRowScan
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#8]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Union of two non-coercible struct types.
select (select AS STRUCT cast(1 as uint64) a, 2 b) AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
--
ERROR: Column col in UNION ALL has incompatible types: STRUCT<a UINT64, b INT64>, STRUCT<a INT32, b INT64> [at 3:1]
select (select AS STRUCT cast(1 as int32) a, 2 b) AS col
^
==

# CORRESPONDING: Only field names of the first struct will determine the field names of
# supertyped struct.
select (select AS STRUCT 1, 2) AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select (select AS STRUCT 3 a, 4 b) AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#9 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#9]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 :=
    | | |   |   +-SubqueryExpr
    | | |   |     +-type=STRUCT<INT64, INT64>
    | | |   |     +-subquery_type=SCALAR
    | | |   |     +-subquery=
    | | |   |       +-ProjectScan
    | | |   |         +-column_list=[$make_struct.$struct#3]
    | | |   |         +-expr_list=
    | | |   |         | +-$struct#3 :=
    | | |   |         |   +-MakeStruct
    | | |   |         |     +-type=STRUCT<INT64, INT64>
    | | |   |         |     +-field_list=
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col1#1)
    | | |   |         |       +-ColumnRef(type=INT64, column=$expr_subquery.$col2#2)
    | | |   |         +-input_scan=
    | | |   |           +-ProjectScan
    | | |   |             +-column_list=$expr_subquery.[$col1#1, $col2#2]
    | | |   |             +-expr_list=
    | | |   |             | +-$col1#1 := Literal(type=INT64, value=1)
    | | |   |             | +-$col2#2 := Literal(type=INT64, value=2)
    | | |   |             +-input_scan=
    | | |   |               +-SingleRowScan
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#10]
    |   |   +-expr_list=
    |   |   | +-col#10 :=
    |   |   |   +-Cast(STRUCT<a INT64, b INT64> -> STRUCT<INT64, INT64>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT64, b INT64>, column=$union_all2.col#8)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.col#8]
    |   |       +-expr_list=
    |   |       | +-col#8 :=
    |   |       |   +-SubqueryExpr
    |   |       |     +-type=STRUCT<a INT64, b INT64>
    |   |       |     +-subquery_type=SCALAR
    |   |       |     +-subquery=
    |   |       |       +-ProjectScan
    |   |       |         +-column_list=[$make_struct.$struct#7]
    |   |       |         +-expr_list=
    |   |       |         | +-$struct#7 :=
    |   |       |         |   +-MakeStruct
    |   |       |         |     +-type=STRUCT<a INT64, b INT64>
    |   |       |         |     +-field_list=
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.a#5)
    |   |       |         |       +-ColumnRef(type=INT64, column=$expr_subquery.b#6)
    |   |       |         +-input_scan=
    |   |       |           +-ProjectScan
    |   |       |             +-column_list=$expr_subquery.[a#5, b#6]
    |   |       |             +-expr_list=
    |   |       |             | +-a#5 := Literal(type=INT64, value=3)
    |   |       |             | +-b#6 := Literal(type=INT64, value=4)
    |   |       |             +-input_scan=
    |   |       |               +-SingleRowScan
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.col#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of struct parameters.
(select struct(1, "abc") AS col)
{{union all CORRESPONDING|INNER union all BY NAME}}
(select @test_param_struct AS col limit 1)
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT32, STRING>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.col#4]
    | | |   +-expr_list=
    | | |   | +-col#4 := Literal(type=STRUCT<INT32, STRING>, value={1, "abc"})
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.col#1]
    | | |       +-expr_list=
    | | |       | +-col#1 := Literal(type=STRUCT<INT64, STRING>, value={1, "abc"})
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.col#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.col#5]
    |   |   +-expr_list=
    |   |   | +-col#5 :=
    |   |   |   +-Cast(STRUCT<a INT32, b STRING> -> STRUCT<INT32, STRING>)
    |   |   |     +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=$union_all2.col#2)
    |   |   +-input_scan=
    |   |     +-LimitOffsetScan
    |   |       +-column_list=[$union_all2.col#2]
    |   |       +-input_scan=
    |   |       | +-ProjectScan
    |   |       |   +-column_list=[$union_all2.col#2]
    |   |       |   +-expr_list=
    |   |       |   | +-col#2 := Parameter(type=STRUCT<a INT32, b STRING>, name="test_param_struct")
    |   |       |   +-input_scan=
    |   |       |     +-SingleRowScan
    |   |       +-limit=
    |   |         +-Literal(type=INT64, value=1)
    |   +-output_column_list=[$union_all2_cast.col#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: with a group by.
select `uint64` from SimpleTypes
{{union all CORRESPONDING|INNER union all BY NAME}}
select CAST(1 AS UINT64) as `uint64` from SimpleTypes
group by `uint64`
--
QueryStmt
+-output_column_list=
| +-$union_all.uint64#40 AS uint64 [UINT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.uint64#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.uint64#4]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[SimpleTypes.uint64#4], table=SimpleTypes, column_index_list=[3])
    | | +-output_column_list=[SimpleTypes.uint64#4]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$groupby.uint64#39]
    |   |   +-input_scan=
    |   |     +-AggregateScan
    |   |       +-column_list=[$groupby.uint64#39]
    |   |       +-input_scan=
    |   |       | +-TableScan(table=SimpleTypes)
    |   |       +-group_by_list=
    |   |         +-uint64#39 := Literal(type=UINT64, value=1, has_explicit_type=TRUE)
    |   +-output_column_list=[$groupby.uint64#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Type coercing in multiple operations of columns from table scans.
SELECT `uint32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `int32` AS col
FROM SimpleTypes
UNION ALL CORRESPONDING
SELECT `float` AS col
FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.col#58 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#58]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#59]
    | | |   +-expr_list=
    | | |   | +-uint32#59 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2])
    | | +-output_column_list=[$union_all1_cast.uint32#59]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2_cast.int32#60]
    | | |   +-expr_list=
    | | |   | +-int32#60 :=
    | | |   |   +-Cast(INT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.int32#20]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$union_all2_cast.int32#60]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3_cast.float#61]
    |   |   +-expr_list=
    |   |   | +-float#61 :=
    |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.float#46], table=SimpleTypes, column_index_list=[7])
    |   +-output_column_list=[$union_all3_cast.float#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: nested set operations with type coercing.
select `uint32` AS col from SimpleTypes s1
{{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
(select `int32` AS col from SimpleTypes s2
 {{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
 (select `float` AS col from SimpleTypes s3 EXCEPT ALL CORRESPONDING select 1 AS col));
--
QueryStmt
+-output_column_list=
| +-$union_all.col#64 AS col [DOUBLE]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#64]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.uint32#65]
    | | |   +-expr_list=
    | | |   | +-uint32#65 :=
    | | |   |   +-Cast(UINT32 -> DOUBLE)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.uint32#3]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2], alias="s1")
    | | +-output_column_list=[$union_all1_cast.uint32#65]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=[$intersect_all.col#61]
    |   |   +-op_type=INTERSECT_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=[$intersect_all1_cast.int32#62]
    |   |   | | |   +-expr_list=
    |   |   | | |   | +-int32#62 :=
    |   |   | | |   |   +-Cast(INT32 -> DOUBLE)
    |   |   | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=[SimpleTypes.int32#20]
    |   |   | | |       +-input_scan=
    |   |   | | |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0], alias="s2")
    |   |   | | +-output_column_list=[$intersect_all1_cast.int32#62]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=[$intersect_all2_cast.col#63]
    |   |   |   |   +-expr_list=
    |   |   |   |   | +-col#63 :=
    |   |   |   |   |   +-Cast(FLOAT -> DOUBLE)
    |   |   |   |   |     +-ColumnRef(type=FLOAT, column=$except_all.col#59)
    |   |   |   |   +-input_scan=
    |   |   |   |     +-SetOperationScan
    |   |   |   |       +-column_list=[$except_all.col#59]
    |   |   |   |       +-op_type=EXCEPT_ALL
    |   |   |   |       +-input_item_list=
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       | | +-scan=
    |   |   |   |       | | | +-ProjectScan
    |   |   |   |       | | |   +-column_list=[SimpleTypes.float#46]
    |   |   |   |       | | |   +-input_scan=
    |   |   |   |       | | |     +-TableScan(column_list=[SimpleTypes.float#46], table=SimpleTypes, column_index_list=[7], alias="s3")
    |   |   |   |       | | +-output_column_list=[SimpleTypes.float#46]
    |   |   |   |       | +-SetOperationItem
    |   |   |   |       |   +-scan=
    |   |   |   |       |   | +-ProjectScan
    |   |   |   |       |   |   +-column_list=[$except_all2_cast.col#60]
    |   |   |   |       |   |   +-expr_list=
    |   |   |   |       |   |   | +-col#60 := Literal(type=FLOAT, value=1)
    |   |   |   |       |   |   +-input_scan=
    |   |   |   |       |   |     +-ProjectScan
    |   |   |   |       |   |       +-column_list=[$except_all2.col#58]
    |   |   |   |       |   |       +-expr_list=
    |   |   |   |       |   |       | +-col#58 := Literal(type=INT64, value=1)
    |   |   |   |       |   |       +-input_scan=
    |   |   |   |       |   |         +-SingleRowScan
    |   |   |   |       |   +-output_column_list=[$except_all2_cast.col#60]
    |   |   |   |       +-column_match_mode=CORRESPONDING
    |   |   |   |       +-column_propagation_mode=INNER
    |   |   |   +-output_column_list=[$intersect_all2_cast.col#63]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=[$intersect_all.col#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION ALL CORRESPONDING with anonymous STRUCT.
select (1, 1) AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select (1, 1) AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [STRUCT<INT64, INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=STRUCT<INT64, INT64>, value={1, 1})
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: UNION of arrays.
select [1, 1] AS col
{{union all CORRESPONDING|INNER union all BY NAME}}
select [2, 3, 4] AS col;
--
QueryStmt
+-output_column_list=
| +-$union_all.col#3 AS col [ARRAY<INT64>]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#3]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=ARRAY<INT64>, value=[1, 1])
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.col#2]
    |   |   +-expr_list=
    |   |   | +-col#2 := Literal(type=ARRAY<INT64>, value=[2, 3, 4])
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all2.col#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Subqueries with SELECT *.
select "abc" c1, cast(1 as int64) c2
{{union all CORRESPONDING|INNER union all BY NAME}}
select * from (
  select "def" c1, cast(1 as int32) c2
)
--
QueryStmt
+-output_column_list=
| +-$union_all.c1#5 AS c1 [STRING]
| +-$union_all.c2#6 AS c2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[c1#5, c2#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[c1#1, c2#2]
    | | |   +-expr_list=
    | | |   | +-c1#1 := Literal(type=STRING, value="abc")
    | | |   | +-c2#2 := Literal(type=INT64, value=1, has_explicit_type=TRUE)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[c1#1, c2#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    |   |   +-expr_list=
    |   |   | +-c2#7 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=$subquery1.c2#4)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$subquery1.[c1#3, c2#4]
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$subquery1.[c1#3, c2#4]
    |   |           +-expr_list=
    |   |           | +-c1#3 := Literal(type=STRING, value="def")
    |   |           | +-c2#4 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$subquery1.c1#3, $union_all2_cast.c2#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# CORRESPONDING: Set operation with hint.
select 1 AS col
UNION @{ key = 5 } ALL CORRESPONDING
select 2 AS col
UNION ALL CORRESPONDING
select 3 AS col
--
QueryStmt
+-output_column_list=
| +-$union_all.col#4 AS col [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.col#4]
    +-hint_list=
    | +-key := Literal(type=INT64, value=5)
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.col#1]
    | | |   +-expr_list=
    | | |   | +-col#1 := Literal(type=INT64, value=1)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.col#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all2.col#2]
    | | |   +-expr_list=
    | | |   | +-col#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all2.col#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3.col#3]
    |   |   +-expr_list=
    |   |   | +-col#3 := Literal(type=INT64, value=3)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=[$union_all3.col#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

[default language_features=NONE,+CORRESPONDING_FULL,+BY_NAME]
# CORRESPONDING: Basic FULL mode: no common columns.
SELECT 1 AS a
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#3 AS a [INT64]
| +-$union_all.b#4 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#3, b#4]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.a#1, $null_column_for_outer_set_op.b#5]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#5 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1.a#1]
    | | |       +-expr_list=
    | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.a#1, $null_column_for_outer_set_op.b#5]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.b#2]
    |   |       +-expr_list=
    |   |       | +-b#2 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Baisc FULL mode: first query misses columns.
SELECT int64 FROM SimpleTypes
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32, int64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#39 AS int64 [INT64]
| +-$union_all.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#39, int32#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, $null_column_for_outer_set_op.int32#41]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int32#41 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[SimpleTypes.int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=[SimpleTypes.int64#2, $null_column_for_outer_set_op.int32#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#21, int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#20, int64#21]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=SimpleTypes.[int64#21, int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL mode: second query misses columns.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#39 AS int64 [INT64]
| +-$union_all.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#39, int32#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#41, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#41 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.int32#20]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#41, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL mode: both queries miss columns.
SELECT 3 AS c, 1 AS a
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS a, 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.c#5 AS c [INT64]
| +-$union_all.a#6 AS a [INT64]
| +-$union_all.b#7 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[c#5, a#6, b#7]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.c#1, $union_all1.a#2, $null_column_for_outer_set_op.b#8]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-b#8 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[c#1, a#2]
    | | |       +-expr_list=
    | | |       | +-c#1 := Literal(type=INT64, value=3)
    | | |       | +-a#2 := Literal(type=INT64, value=1)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1.c#1, $union_all1.a#2, $null_column_for_outer_set_op.b#8]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.c#9, $union_all2.a#3, $union_all2.b#4]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-c#9 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[a#3, b#4]
    |   |       +-expr_list=
    |   |       | +-a#3 := Literal(type=INT64, value=1)
    |   |       | +-b#4 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.c#9, $union_all2.a#3, $union_all2.b#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic FULL no queries miss columns.
SELECT int64, int32 FROM SimpleTypes
FULL UNION DISTINCT {{CORRESPONDING|BY NAME}}
SELECT int32, int64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_distinct.int64#39 AS int64 [INT64]
| +-$union_distinct.int32#40 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[int64#39, int32#40]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#21, int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#20, int64#21]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#20, int64#21], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=SimpleTypes.[int64#21, int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: A column has incompatible types.
SELECT 1 AS a, 2 AS b
FULL UNION ALL CORRESPONDING
SELECT 1 as a
FULL UNION ALL CORRESPONDING
SELECT FALSE AS b
--
ERROR: Column b in UNION ALL has incompatible types: INT64, NULL, BOOL [at 3:1]
SELECT 1 as a
^
==

# CORRESPONDING: FULL mode multiple expressions.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
FULL UNION ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#58 AS int64 [INT64]
| +-$union_all.int32#59 AS int32 [INT32]
| +-$union_all.uint64#60 AS uint64 [UINT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#58, int32#59, uint64#60]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#61]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-uint64#61 := Literal(type=UINT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#62, SimpleTypes.int32#20, SimpleTypes.uint64#23]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#62 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#62, SimpleTypes.int32#20, SimpleTypes.uint64#23]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#63, SimpleTypes.int32#39, SimpleTypes.uint64#42]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#63 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, uint64#42]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, uint64#42], table=SimpleTypes, column_index_list=[0, 3])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#63, SimpleTypes.int32#39, SimpleTypes.uint64#42]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode multiple expressions: every query has a unique
# column.
SELECT int64, int32 FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.int64#58 AS int64 [INT64]
| +-$intersect_all.int32#59 AS int32 [INT32]
| +-$intersect_all.uint64#60 AS uint64 [UINT64]
| +-$intersect_all.float#61 AS float [FLOAT]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[int64#58, int32#59, uint64#60, float#61]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#62, $null_column_for_outer_set_op.float#63]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-uint64#62 := Literal(type=UINT64, value=NULL)
    | | |   | +-float#63 := Literal(type=FLOAT, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.uint64#62, $null_column_for_outer_set_op.float#63]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#64, SimpleTypes.int32#20, SimpleTypes.uint64#23, $null_column_for_outer_set_op.float#65]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#64 := Literal(type=INT64, value=NULL)
    | | |   | +-float#65 := Literal(type=FLOAT, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#64, SimpleTypes.int32#20, SimpleTypes.uint64#23, $null_column_for_outer_set_op.float#65]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#66, SimpleTypes.int32#39, $null_column_for_outer_set_op.uint64#67, SimpleTypes.float#46]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#66 := Literal(type=INT64, value=NULL)
    |   |   | +-uint64#67 := Literal(type=UINT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, float#46], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#66, SimpleTypes.int32#39, $null_column_for_outer_set_op.uint64#67, SimpleTypes.float#46]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with multiple expressions: Type coercion for NULL
# columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT int32 AS b FROM SimpleTypes
FULL INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#65 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.int32#62]
    | | |       +-expr_list=
    | | |       | +-int32#62 :=
    | | |       |   +-Cast(INT32 -> INT64)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[SimpleTypes.int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all3_cast.[float#64, uint32#63]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all3_cast.[uint32#63, float#64]
    |   |       +-expr_list=
    |   |       | +-uint32#63 :=
    |   |       | | +-Cast(UINT32 -> INT64)
    |   |       | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#41)
    |   |       | +-float#64 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=$intersect_all3_cast.[float#64, uint32#63]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b FROM SimpleTypes
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 AS b, int32 AS c FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, $null_column_for_outer_set_op.c#43]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-c#43 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, $null_column_for_outer_set_op.c#43]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#44, $union_all2_cast.int32#42, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#44 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#42, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#42 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#44, $union_all2_cast.int32#42, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: FULL mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b, int32 AS c, int64 AS d FROM SimpleTypes
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 AS b, int32 AS d, int32 AS e FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
| +-$union_all.d#42 AS d [INT64]
| +-$union_all.e#43 AS e [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41, d#42, e#43]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, SimpleTypes.int32#1, SimpleTypes.int64#2, $null_column_for_outer_set_op.e#46]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-e#46 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int64#2, SimpleTypes.int32#1, SimpleTypes.int64#2, $null_column_for_outer_set_op.e#46]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#47, $union_all2_cast.int32#44, $null_column_for_outer_set_op.c#48, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#47 := Literal(type=INT64, value=NULL)
    |   |   | +-c#48 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#44, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#44 :=
    |   |       | | +-Cast(INT32 -> INT64)
    |   |       | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       | +-int32#45 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#47, $union_all2_cast.int32#44, $null_column_for_outer_set_op.c#48, $union_all2_cast.int32#45, SimpleTypes.int32#20]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: nested queries.
SELECT int64, int32 FROM SimpleTypes
FULL UNION ALL {{CORRESPONDING|BY NAME}} (
  SELECT float, double, int64 FROM SimpleTypes
  FULL INTERSECT ALL {{CORRESPONDING|BY NAME}}
  SELECT bool, double AS float FROM SimpleTypes
)
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#66 AS int64 [INT64]
| +-$union_all.int32#67 AS int32 [INT32]
| +-$union_all.float#68 AS float [DOUBLE]
| +-$union_all.double#69 AS double [DOUBLE]
| +-$union_all.bool#70 AS bool [BOOL]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#66, int32#67, float#68, double#69, bool#70]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.float#71, $null_column_for_outer_set_op.double#72, $null_column_for_outer_set_op.bool#73]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-float#71 := Literal(type=DOUBLE, value=NULL)
    | | |   | +-double#72 := Literal(type=DOUBLE, value=NULL)
    | | |   | +-bool#73 := Literal(type=BOOL, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=[SimpleTypes.int64#2, SimpleTypes.int32#1, $null_column_for_outer_set_op.float#71, $null_column_for_outer_set_op.double#72, $null_column_for_outer_set_op.bool#73]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#74, $intersect_all.float#58, $intersect_all.double#59, $intersect_all.bool#61]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int32#74 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_all.[float#58, double#59, int64#60, bool#61]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21, $null_column_for_outer_set_op.bool#63]
    |   |       | | |   +-node_source="resolver_set_operation_corresponding"
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-bool#63 := Literal(type=BOOL, value=NULL)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | | |       +-expr_list=
    |   |       | | |       | +-float#62 :=
    |   |       | | |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       | | |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | | |       +-input_scan=
    |   |       | | |         +-ProjectScan
    |   |       | | |           +-column_list=SimpleTypes.[float#27, double#28, int64#21]
    |   |       | | |           +-input_scan=
    |   |       | | |             +-TableScan(column_list=SimpleTypes.[int64#21, float#27, double#28], table=SimpleTypes, column_index_list=[1, 7, 8])
    |   |       | | +-output_column_list=[$intersect_all1_cast.float#62, SimpleTypes.double#28, SimpleTypes.int64#21, $null_column_for_outer_set_op.bool#63]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#64, $null_column_for_outer_set_op.int64#65, SimpleTypes.bool#45]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-double#64 := Literal(type=DOUBLE, value=NULL)
    |   |       |   |   | +-int64#65 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=SimpleTypes.[bool#45, double#47]
    |   |       |   |       +-input_scan=
    |   |       |   |         +-TableScan(column_list=SimpleTypes.[bool#45, double#47], table=SimpleTypes, column_index_list=[6, 8])
    |   |       |   +-output_column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#64, $null_column_for_outer_set_op.int64#65, SimpleTypes.bool#45]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=FULL
    |   +-output_column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#74, $intersect_all.float#58, $intersect_all.double#59, $intersect_all.bool#61]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: nested queries.
(
  SELECT float, double, int64 FROM SimpleTypes
  FULL INTERSECT ALL {{CORRESPONDING|BY NAME}}
  SELECT bool, double AS float FROM SimpleTypes
)
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int64, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.float#66 AS float [DOUBLE]
| +-$union_all.double#67 AS double [DOUBLE]
| +-$union_all.int64#68 AS int64 [INT64]
| +-$union_all.bool#69 AS bool [BOOL]
| +-$union_all.int32#70 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[float#66, double#67, int64#68, bool#69, int32#70]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$intersect_all.float#39, $intersect_all.double#40, $intersect_all.int64#41, $intersect_all.bool#42, $null_column_for_outer_set_op.int32#71]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int32#71 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-SetOperationScan
    | | |       +-column_list=$intersect_all.[float#39, double#40, int64#41, bool#42]
    | | |       +-op_type=INTERSECT_ALL
    | | |       +-input_item_list=
    | | |       | +-SetOperationItem
    | | |       | | +-scan=
    | | |       | | | +-ProjectScan
    | | |       | | |   +-column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2, $null_column_for_outer_set_op.bool#44]
    | | |       | | |   +-node_source="resolver_set_operation_corresponding"
    | | |       | | |   +-expr_list=
    | | |       | | |   | +-bool#44 := Literal(type=BOOL, value=NULL)
    | | |       | | |   +-input_scan=
    | | |       | | |     +-ProjectScan
    | | |       | | |       +-column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |       | | |       +-expr_list=
    | | |       | | |       | +-float#43 :=
    | | |       | | |       |   +-Cast(FLOAT -> DOUBLE)
    | | |       | | |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |       | | |       +-input_scan=
    | | |       | | |         +-ProjectScan
    | | |       | | |           +-column_list=SimpleTypes.[float#8, double#9, int64#2]
    | | |       | | |           +-input_scan=
    | | |       | | |             +-TableScan(column_list=SimpleTypes.[int64#2, float#8, double#9], table=SimpleTypes, column_index_list=[1, 7, 8])
    | | |       | | +-output_column_list=[$intersect_all1_cast.float#43, SimpleTypes.double#9, SimpleTypes.int64#2, $null_column_for_outer_set_op.bool#44]
    | | |       | +-SetOperationItem
    | | |       |   +-scan=
    | | |       |   | +-ProjectScan
    | | |       |   |   +-column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#45, $null_column_for_outer_set_op.int64#46, SimpleTypes.bool#26]
    | | |       |   |   +-node_source="resolver_set_operation_corresponding"
    | | |       |   |   +-expr_list=
    | | |       |   |   | +-double#45 := Literal(type=DOUBLE, value=NULL)
    | | |       |   |   | +-int64#46 := Literal(type=INT64, value=NULL)
    | | |       |   |   +-input_scan=
    | | |       |   |     +-ProjectScan
    | | |       |   |       +-column_list=SimpleTypes.[bool#26, double#28]
    | | |       |   |       +-input_scan=
    | | |       |   |         +-TableScan(column_list=SimpleTypes.[bool#26, double#28], table=SimpleTypes, column_index_list=[6, 8])
    | | |       |   +-output_column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#45, $null_column_for_outer_set_op.int64#46, SimpleTypes.bool#26]
    | | |       +-column_match_mode=CORRESPONDING
    | | |       +-column_propagation_mode=FULL
    | | +-output_column_list=[$intersect_all.float#39, $intersect_all.double#40, $intersect_all.int64#41, $intersect_all.bool#42, $null_column_for_outer_set_op.int32#71]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.float#72, $null_column_for_outer_set_op.double#73, SimpleTypes.int64#48, $null_column_for_outer_set_op.bool#74, SimpleTypes.int32#47]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-float#72 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-double#73 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-bool#74 := Literal(type=BOOL, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int64#48, int32#47]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#47, int64#48], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=[$null_column_for_outer_set_op.float#72, $null_column_for_outer_set_op.double#73, SimpleTypes.int64#48, $null_column_for_outer_set_op.bool#74, SimpleTypes.int32#47]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# CORRESPONDING: Basic LEFT mode: no common columns.
SELECT 1 AS a
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS b
--
ALTERNATION GROUP: CORRESPONDING
--
ERROR: Query 2 of the set operation with LEFT mode does not share any common columns with query 1 [at 2:6]
LEFT UNION ALL CORRESPONDING
     ^
--
ALTERNATION GROUP: BY NAME
--
ERROR: Query 2 of the set operation with LEFT mode does not share any common columns with query 1 [at 2:6]
LEFT UNION ALL BY NAME
     ^
==

# CORRESPONDING: Basic LEFT mode: first query misses columns.
SELECT 1 AS a
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS a, 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.a#4]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1.a#1]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=[$union_all1.a#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.a#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[a#2, b#3]
    |   |       +-expr_list=
    |   |       | +-a#2 := Literal(type=INT64, value=1)
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.a#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: second query misses columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
| +-$union_all.b#5 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#4, b#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.a#3, $null_column_for_outer_set_op.b#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.a#3]
    |   |       +-expr_list=
    |   |       | +-a#3 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.a#3, $null_column_for_outer_set_op.b#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: second query misses columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 2 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#4 AS a [INT64]
| +-$union_all.b#5 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#4, b#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#6 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.b#3]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#6, $union_all2.b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: both queries miss columns
SELECT 1 AS a, 2 AS b
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 2 AS b, 3 AS c
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#7, $union_all2.b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, c#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-c#4 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#7, $union_all2.b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic LEFT mode: no queries miss columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 2 AS b, 3 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[a#4, b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, a#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-a#4 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[a#4, b#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS b, 3 AS c
LEFT UNION ALL CORRESPONDING
SELECT 2 AS c, 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#9 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[b#3, c#4]
    | | |       +-expr_list=
    | | |       | +-b#3 := Literal(type=INT64, value=2)
    | | |       | +-c#4 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all3.a#6, $null_column_for_outer_set_op.b#10]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all3.[c#5, a#6]
    |   |       +-expr_list=
    |   |       | +-c#5 := Literal(type=INT64, value=2)
    |   |       | +-a#6 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all3.a#6, $null_column_for_outer_set_op.b#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions no common columns.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 2 AS c, 3 AS d
LEFT UNION ALL CORRESPONDING
SELECT 2 AS d, 1 AS c
--
ERROR: Query 2 of the set operation with LEFT mode does not share any common columns with query 1 [at 2:6]
LEFT UNION ALL CORRESPONDING
     ^
==

# CORRESPONDING: LEFT: A column has incompatible types.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 1 as a
LEFT UNION ALL CORRESPONDING
SELECT FALSE AS b
--
ERROR: Column b in UNION ALL has incompatible types: INT64, NULL, BOOL [at 3:1]
SELECT 1 as a
^
==

# CORRESPONDING: LEFT: Not selected columns allowed to have incompatible types.
SELECT 1 AS a, 2 AS b
LEFT UNION ALL CORRESPONDING
SELECT 1 as b, FALSE AS c
LEFT UNION ALL CORRESPONDING
SELECT 100 AS c, 1 AS b
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#9 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[b#3, c#4]
    | | |       +-expr_list=
    | | |       | +-b#3 := Literal(type=INT64, value=1)
    | | |       | +-c#4 := Literal(type=BOOL, value=false)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$null_column_for_outer_set_op.a#9, $union_all2.b#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#10, $union_all3.b#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all3.[c#5, b#6]
    |   |       +-expr_list=
    |   |       | +-c#5 := Literal(type=INT64, value=100)
    |   |       | +-b#6 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.a#10, $union_all3.b#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode multiple expressions.
SELECT int64, int32 FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32, uint64 FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32, float FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.int64#58 AS int64 [INT64]
| +-$intersect_all.int32#59 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[int64#58, int32#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.int64#60, SimpleTypes.int32#20]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-int64#60 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int32#20, uint64#23]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#20, uint64#23], table=SimpleTypes, column_index_list=[0, 3])
    | | +-output_column_list=[$null_column_for_outer_set_op.int64#60, SimpleTypes.int32#20]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.int64#61, SimpleTypes.int32#39]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int64#61 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#39, float#46]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#39, float#46], table=SimpleTypes, column_index_list=[0, 7])
    |   +-output_column_list=[$null_column_for_outer_set_op.int64#61, SimpleTypes.int32#39]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with multiple expressions: Type coercion for NULL
# columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#65 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.int32#62]
    | | |       +-expr_list=
    | | |       | +-int32#62 :=
    | | |       |   +-Cast(INT32 -> INT64)
    | | |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[SimpleTypes.int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#65, $intersect_all2_cast.int32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_all3_cast.[float#64, uint32#63]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_all3_cast.[uint32#63, float#64]
    |   |       +-expr_list=
    |   |       | +-uint32#63 :=
    |   |       | | +-Cast(UINT32 -> INT64)
    |   |       | |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#41)
    |   |       | +-float#64 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=$intersect_all3_cast.[float#64, uint32#63]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with multiple expressions: Type coercion does not
# happen for non-selected columns.
SELECT int64 AS a, int32 AS b FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS b, int32 AS c FROM SimpleTypes
LEFT INTERSECT ALL CORRESPONDING
SELECT uint32 AS c, float AS a FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$intersect_all.a#58 AS a [DOUBLE]
| +-$intersect_all.b#59 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[a#58, b#59]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1_cast.[int64#60, int32#61]
    | | |   +-expr_list=
    | | |   | +-int64#60 :=
    | | |   | | +-Cast(INT64 -> DOUBLE)
    | | |   | |   +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
    | | |   | +-int32#61 :=
    | | |   |   +-Cast(INT32 -> INT64)
    | | |   |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=$intersect_all1_cast.[int64#60, int32#61]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$null_column_for_outer_set_op.a#64, $intersect_all2_cast.uint32#62]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-a#64 := Literal(type=DOUBLE, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$intersect_all2_cast.uint32#62, SimpleTypes.int32#20]
    | | |       +-expr_list=
    | | |       | +-uint32#62 :=
    | | |       |   +-Cast(UINT32 -> INT64)
    | | |       |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#22)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=SimpleTypes.[uint32#22, int32#20]
    | | |           +-input_scan=
    | | |             +-TableScan(column_list=SimpleTypes.[int32#20, uint32#22], table=SimpleTypes, column_index_list=[0, 2])
    | | +-output_column_list=[$null_column_for_outer_set_op.a#64, $intersect_all2_cast.uint32#62]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all3_cast.float#63, $null_column_for_outer_set_op.b#65]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-b#65 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[SimpleTypes.uint32#41, $intersect_all3_cast.float#63]
    |   |       +-expr_list=
    |   |       | +-float#63 :=
    |   |       |   +-Cast(FLOAT -> DOUBLE)
    |   |       |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#46)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[uint32#41, float#46]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=SimpleTypes.[uint32#41, float#46], table=SimpleTypes, column_index_list=[2, 7])
    |   +-output_column_list=[$intersect_all3_cast.float#63, $null_column_for_outer_set_op.b#65]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b FROM SimpleTypes
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 AS b, int32 AS c FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int64#2]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
    | | +-output_column_list=SimpleTypes.[int64#2, int64#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#42, $union_all2_cast.int32#41]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#42 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#41, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#41 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#42, $union_all2_cast.int32#41]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT mode with duplicate columns of different names.
SELECT int64 AS a, int64 AS b, int32 AS c, int64 AS d FROM SimpleTypes
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 AS b, int32 AS d, int32 AS e FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.a#39 AS a [INT64]
| +-$union_all.b#40 AS b [INT64]
| +-$union_all.c#41 AS c [INT32]
| +-$union_all.d#42 AS d [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#39, b#40, c#41, d#42]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int64#2, int32#1, int64#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.a#45, $union_all2_cast.int32#43, $null_column_for_outer_set_op.c#46, $union_all2_cast.int32#44]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-a#45 := Literal(type=INT64, value=NULL)
    |   |   | +-c#46 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.int32#43, $union_all2_cast.int32#44, SimpleTypes.int32#20]
    |   |       +-expr_list=
    |   |       | +-int32#43 :=
    |   |       | | +-Cast(INT32 -> INT64)
    |   |       | |   +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       | +-int32#44 :=
    |   |       |   +-Cast(INT32 -> INT64)
    |   |       |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#20)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=SimpleTypes.[int32#20, int32#20, int32#20]
    |   |           +-input_scan=
    |   |             +-TableScan(column_list=[SimpleTypes.int32#20], table=SimpleTypes, column_index_list=[0])
    |   +-output_column_list=[$null_column_for_outer_set_op.a#45, $union_all2_cast.int32#43, $null_column_for_outer_set_op.c#46, $union_all2_cast.int32#44]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries.
SELECT int64, int32 FROM SimpleTypes
LEFT UNION ALL {{CORRESPONDING|BY NAME}} (
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL {{CORRESPONDING|BY NAME}}
  SELECT bool, double AS float FROM SimpleTypes
)
--
QueryStmt
+-output_column_list=
| +-$union_all.int64#64 AS int64 [INT64]
| +-$union_all.int32#65 AS int32 [INT32]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[int64#64, int32#65]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=SimpleTypes.[int64#2, int32#1]
    | | |   +-input_scan=
    | | |     +-TableScan(column_list=SimpleTypes.[int32#1, int64#2], table=SimpleTypes, column_index_list=[0, 1])
    | | +-output_column_list=SimpleTypes.[int64#2, int32#1]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#66]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-int32#66 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_all.[float#58, double#59, int64#60]
    |   |       +-op_type=INTERSECT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_all1_cast.float#61, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-float#61 :=
    |   |       | | |   |   +-Cast(FLOAT -> DOUBLE)
    |   |       | | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#27)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=SimpleTypes.[float#27, double#28, int64#21]
    |   |       | | |       +-input_scan=
    |   |       | | |         +-TableScan(column_list=SimpleTypes.[int64#21, float#27, double#28], table=SimpleTypes, column_index_list=[1, 7, 8])
    |   |       | | +-output_column_list=[$intersect_all1_cast.float#61, SimpleTypes.double#28, SimpleTypes.int64#21]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#62, $null_column_for_outer_set_op.int64#63]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-double#62 := Literal(type=DOUBLE, value=NULL)
    |   |       |   |   | +-int64#63 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=SimpleTypes.[bool#45, double#47]
    |   |       |   |       +-input_scan=
    |   |       |   |         +-TableScan(column_list=SimpleTypes.[bool#45, double#47], table=SimpleTypes, column_index_list=[6, 8])
    |   |       |   +-output_column_list=[SimpleTypes.double#47, $null_column_for_outer_set_op.double#62, $null_column_for_outer_set_op.int64#63]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=LEFT
    |   +-output_column_list=[$intersect_all.int64#60, $null_column_for_outer_set_op.int32#66]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries.
(
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL {{CORRESPONDING|BY NAME}}
  SELECT bool, double AS float FROM SimpleTypes
)
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int64, int32 FROM SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$union_all.float#64 AS float [DOUBLE]
| +-$union_all.double#65 AS double [DOUBLE]
| +-$union_all.int64#66 AS int64 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[float#64, double#65, int64#66]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_all.[float#39, double#40, int64#41]
    | | |   +-op_type=INTERSECT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=[$intersect_all1_cast.float#42, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-float#42 :=
    | | |   | | |   |   +-Cast(FLOAT -> DOUBLE)
    | | |   | | |   |     +-ColumnRef(type=FLOAT, column=SimpleTypes.float#8)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=SimpleTypes.[float#8, double#9, int64#2]
    | | |   | | |       +-input_scan=
    | | |   | | |         +-TableScan(column_list=SimpleTypes.[int64#2, float#8, double#9], table=SimpleTypes, column_index_list=[1, 7, 8])
    | | |   | | +-output_column_list=[$intersect_all1_cast.float#42, SimpleTypes.double#9, SimpleTypes.int64#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#43, $null_column_for_outer_set_op.int64#44]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-double#43 := Literal(type=DOUBLE, value=NULL)
    | | |   |   |   | +-int64#44 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=SimpleTypes.[bool#26, double#28]
    | | |   |   |       +-input_scan=
    | | |   |   |         +-TableScan(column_list=SimpleTypes.[bool#26, double#28], table=SimpleTypes, column_index_list=[6, 8])
    | | |   |   +-output_column_list=[SimpleTypes.double#28, $null_column_for_outer_set_op.double#43, $null_column_for_outer_set_op.int64#44]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=LEFT
    | | +-output_column_list=$intersect_all.[float#39, double#40, int64#41]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.float#67, $null_column_for_outer_set_op.double#68, SimpleTypes.int64#46]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-float#67 := Literal(type=DOUBLE, value=NULL)
    |   |   | +-double#68 := Literal(type=DOUBLE, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int64#46, int32#45]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#45, int64#46], table=SimpleTypes, column_index_list=[0, 1])
    |   +-output_column_list=[$null_column_for_outer_set_op.float#67, $null_column_for_outer_set_op.double#68, SimpleTypes.int64#46]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: LEFT nested queries: no common columns.
(
  SELECT float, double, int64 FROM SimpleTypes
  LEFT INTERSECT ALL {{CORRESPONDING|BY NAME}}
  SELECT bool, double AS float FROM SimpleTypes
)
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT int32 FROM SimpleTypes
--
ALTERNATION GROUPS:
    CORRESPONDING,CORRESPONDING
    BY NAME,CORRESPONDING
--
ERROR: Query 2 of the set operation with LEFT mode does not share any common columns with query 1 [at 6:6]
LEFT UNION ALL CORRESPONDING
     ^
--
ALTERNATION GROUPS:
    CORRESPONDING,BY NAME
    BY NAME,BY NAME
--
ERROR: Query 2 of the set operation with LEFT mode does not share any common columns with query 1 [at 6:6]
LEFT UNION ALL BY NAME
     ^
==

# CORRESPONDING: LEFT first query is select distinct with duplicate columns.
SELECT DISTINCT a AS col1, a AS col2
FROM (
  SELECT 1 AS a
)
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS col1, 2 AS col2
--
QueryStmt
+-output_column_list=
| +-$union_all.col1#5 AS col1 [INT64]
| +-$union_all.col2#6 AS col2 [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[col1#5, col2#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$distinct.[a#2, a#2]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-AggregateScan
    | | |       +-column_list=[$distinct.a#2]
    | | |       +-input_scan=
    | | |       | +-ProjectScan
    | | |       |   +-column_list=[$subquery1.a#1]
    | | |       |   +-expr_list=
    | | |       |   | +-a#1 := Literal(type=INT64, value=1)
    | | |       |   +-input_scan=
    | | |       |     +-SingleRowScan
    | | |       +-group_by_list=
    | | |         +-a#2 := ColumnRef(type=INT64, column=$subquery1.a#1)
    | | +-output_column_list=$distinct.[a#2, a#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[col1#3, col2#4]
    |   |   +-expr_list=
    |   |   | +-col1#3 := Literal(type=INT64, value=1)
    |   |   | +-col2#4 := Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all2.[col1#3, col2#4]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# Literal coercion is correctly handled: INNER mode.
SELECT CAST(1 AS INT32) AS A, NULL AS B
{{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
SELECT CAST("STRING_VAL" AS STRING) AS B, 100 AS A
--
QueryStmt
+-output_column_list=
| +-$intersect_all.A#5 AS A [INT32]
| +-$intersect_all.B#6 AS B [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[A#5, B#6]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$intersect_all1.A#1, $intersect_all1_cast.B#7]
    | | |   +-expr_list=
    | | |   | +-B#7 := Literal(type=STRING, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$intersect_all1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |       | +-B#2 := Literal(type=INT64, value=NULL)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$intersect_all1.A#1, $intersect_all1_cast.B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$intersect_all2_cast.A#8, $intersect_all2.B#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$intersect_all2.B#3, $intersect_all2_cast.A#8]
    |   |       +-expr_list=
    |   |       | +-A#8 := Literal(type=INT32, value=100)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$intersect_all2.[B#3, A#4]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=STRING, value="STRING_VAL", has_explicit_type=TRUE)
    |   |           | +-A#4 := Literal(type=INT64, value=100)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$intersect_all2_cast.A#8, $intersect_all2.B#3]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=INNER
==

# Literal cocercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT NULL AS A
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS B, CAST(NULL AS ARRAY<STRUCT<STRING, STRING>>) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [ARRAY<STRUCT<STRING, STRING>>]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#6, $null_column_for_outer_set_op.B#7]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=[$union_all1_cast.A#6]
    | | |       +-expr_list=
    | | |       | +-A#6 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL)
    | | |       +-input_scan=
    | | |         +-ProjectScan
    | | |           +-column_list=[$union_all1.A#1]
    | | |           +-expr_list=
    | | |           | +-A#1 := Literal(type=INT64, value=NULL)
    | | |           +-input_scan=
    | | |             +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#6, $null_column_for_outer_set_op.B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#3, B#2]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[B#2, A#3]
    |   |       +-expr_list=
    |   |       | +-B#2 := Literal(type=INT64, value=1)
    |   |       | +-A#3 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#3, B#2]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal cocercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT NULL AS A, 1 AS B, 3 AS C
FULL UNION ALL {{CORRESPONDING|BY NAME}}
SELECT 1 AS B, CAST(NULL AS ARRAY<STRUCT<STRING, STRING>>) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#6 AS A [ARRAY<STRUCT<STRING, STRING>>]
| +-$union_all.B#7 AS B [INT64]
| +-$union_all.C#8 AS C [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#6, B#7, C#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#9, $union_all1.B#2, $union_all1.C#3]
    | | |   +-expr_list=
    | | |   | +-A#9 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[A#1, B#2, C#3]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT64, value=NULL)
    | | |       | +-B#2 := Literal(type=INT64, value=1)
    | | |       | +-C#3 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#9, $union_all1.B#2, $union_all1.C#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.A#5, $union_all2.B#4, $null_column_for_outer_set_op.C#10]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-C#10 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[B#4, A#5]
    |   |       +-expr_list=
    |   |       | +-B#4 := Literal(type=INT64, value=1)
    |   |       | +-A#5 := Literal(type=ARRAY<STRUCT<STRING, STRING>>, value=NULL, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.A#5, $union_all2.B#4, $null_column_for_outer_set_op.C#10]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT CAST(1 AS INT32) AS A, "STRING_VAL" AS B
FULL UNION DISTINCT {{CORRESPONDING|BY NAME}}
SELECT NULL AS B
--
QueryStmt
+-output_column_list=
| +-$union_distinct.A#4 AS A [INT32]
| +-$union_distinct.B#5 AS B [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[A#4, B#5]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_distinct1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |   | +-B#2 := Literal(type=STRING, value="STRING_VAL")
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_distinct1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$null_column_for_outer_set_op.A#7, $union_distinct2_cast.B#6]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-A#7 := Literal(type=INT32, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_distinct2_cast.B#6]
    |   |       +-expr_list=
    |   |       | +-B#6 := Literal(type=STRING, value=NULL)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[$union_distinct2.B#3]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=INT64, value=NULL)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$null_column_for_outer_set_op.A#7, $union_distinct2_cast.B#6]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for FULL
# mode.
SELECT CAST(1 AS INT32) AS A, "STRING_VAL" AS B
FULL UNION DISTINCT {{CORRESPONDING|BY NAME}}
SELECT NULL AS B, 1 AS A, "NO_MATCHING" AS C
--
QueryStmt
+-output_column_list=
| +-$union_distinct.A#6 AS A [INT32]
| +-$union_distinct.B#7 AS B [STRING]
| +-$union_distinct.C#8 AS C [STRING]
+-query=
  +-SetOperationScan
    +-column_list=$union_distinct.[A#6, B#7, C#8]
    +-op_type=UNION_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_distinct1.A#1, $union_distinct1.B#2, $null_column_for_outer_set_op.C#11]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-expr_list=
    | | |   | +-C#11 := Literal(type=STRING, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_distinct1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |       | +-B#2 := Literal(type=STRING, value="STRING_VAL")
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_distinct1.A#1, $union_distinct1.B#2, $null_column_for_outer_set_op.C#11]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_distinct2_cast.A#10, $union_distinct2_cast.B#9, $union_distinct2.C#5]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_distinct2_cast.B#9, $union_distinct2_cast.A#10, $union_distinct2.C#5]
    |   |       +-expr_list=
    |   |       | +-B#9 := Literal(type=STRING, value=NULL)
    |   |       | +-A#10 := Literal(type=INT32, value=1)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=$union_distinct2.[B#3, A#4, C#5]
    |   |           +-expr_list=
    |   |           | +-B#3 := Literal(type=INT64, value=NULL)
    |   |           | +-A#4 := Literal(type=INT64, value=1)
    |   |           | +-C#5 := Literal(type=STRING, value="NO_MATCHING")
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$union_distinct2_cast.A#10, $union_distinct2_cast.B#9, $union_distinct2.C#5]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=FULL
==

# Literal coercion is correctly handled when NULL columns are padded for LEFT
# mode.
SELECT NULL AS A, 2 AS B
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT CAST(1 AS INT32) AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [INT32]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$union_all1_cast.A#6, $union_all1.B#2]
    | | |   +-expr_list=
    | | |   | +-A#6 := Literal(type=INT32, value=NULL)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all1.[A#1, B#2]
    | | |       +-expr_list=
    | | |       | +-A#1 := Literal(type=INT64, value=NULL)
    | | |       | +-B#2 := Literal(type=INT64, value=2)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=[$union_all1_cast.A#6, $union_all1.B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2.A#3, $null_column_for_outer_set_op.B#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2.A#3]
    |   |       +-expr_list=
    |   |       | +-A#3 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=[$union_all2.A#3, $null_column_for_outer_set_op.B#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# Literal coercion is correctly handled when NULL columns are padded for LEFT
# mode.
SELECT CAST(1 AS INT32) AS A, 2 AS B
LEFT UNION ALL {{CORRESPONDING|BY NAME}}
SELECT NULL AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#4 AS A [INT32]
| +-$union_all.B#5 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#4, B#5]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT32, value=1, has_explicit_type=TRUE)
    | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$union_all2_cast.A#6, $null_column_for_outer_set_op.B#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-expr_list=
    |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=[$union_all2_cast.A#6]
    |   |       +-expr_list=
    |   |       | +-A#6 := Literal(type=INT32, value=NULL)
    |   |       +-input_scan=
    |   |         +-ProjectScan
    |   |           +-column_list=[$union_all2.A#3]
    |   |           +-expr_list=
    |   |           | +-A#3 := Literal(type=INT64, value=NULL)
    |   |           +-input_scan=
    |   |             +-SingleRowScan
    |   +-output_column_list=[$union_all2_cast.A#6, $null_column_for_outer_set_op.B#7]
    +-column_match_mode=CORRESPONDING
    +-column_propagation_mode=LEFT
==

# CORRESPONDING: Basic STRICT.
SELECT 1 AS a, 2 AS b
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS b, 1 AS a
--
QueryStmt
+-output_column_list=
| +-$union_all.a#5 AS a [INT64]
| +-$union_all.b#6 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#5, b#6]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[a#4, b#3]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[b#3, a#4]
    |   |       +-expr_list=
    |   |       | +-b#3 := Literal(type=INT64, value=2)
    |   |       | +-a#4 := Literal(type=INT64, value=1)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[a#4, b#3]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a, 2 AS b
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS b
--
ALTERNATION GROUP: STRICT CORRESPONDING
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [a, b] and query 2 has [b] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
--
ALTERNATION GROUP: BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [a, b] and query 2 has [b] [at 2:1]
UNION ALL BY NAME
^
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS b, 3 AS c, 2 AS a
--
ALTERNATION GROUP: STRICT CORRESPONDING
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [a] and query 2 has [b, c, a] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
--
ALTERNATION GROUP: BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [a] and query 2 has [b, c, a] [at 2:1]
UNION ALL BY NAME
^
==

# CORRESPONDING: Basic STRICT: column names must be identical.
SELECT 1 AS a, 2 AS b
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS b, 3 AS c
--
ALTERNATION GROUP: STRICT CORRESPONDING
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [a, b] and query 2 has [b, c] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
--
ALTERNATION GROUP: BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [a, b] and query 2 has [b, c] [at 2:1]
UNION ALL BY NAME
^
==

# CORRESPONDING: STRICT mode with multiple queries.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS B, 3 AS a
UNION ALL STRICT CORRESPONDING
SELECT 3 AS A, 1 AS B
--
QueryStmt
+-output_column_list=
| +-$union_all.a#7 AS a [INT64]
| +-$union_all.b#8 AS b [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[a#7, b#8]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[a#1, b#2]
    | | |   +-expr_list=
    | | |   | +-a#1 := Literal(type=INT64, value=1)
    | | |   | +-b#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[a#1, b#2]
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all2.[a#4, B#3]
    | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=$union_all2.[B#3, a#4]
    | | |       +-expr_list=
    | | |       | +-B#3 := Literal(type=INT64, value=2)
    | | |       | +-a#4 := Literal(type=INT64, value=3)
    | | |       +-input_scan=
    | | |         +-SingleRowScan
    | | +-output_column_list=$union_all2.[a#4, B#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all3.[A#5, B#6]
    |   |   +-expr_list=
    |   |   | +-A#5 := Literal(type=INT64, value=3)
    |   |   | +-B#6 := Literal(type=INT64, value=1)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all3.[A#5, B#6]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: STRICT mode with multiple queries: column lists are not the same.
SELECT 1 AS a, 2 AS b
UNION ALL STRICT CORRESPONDING
SELECT 2 AS B, 3 AS a
UNION ALL STRICT CORRESPONDING
SELECT 3 AS A, 1 AS B, 3 AS c
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [a, b] and query 3 has [A, B, c] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
==

# CORRESPONDING: nested set operations.
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 2 AS c, 3 AS b
)
EXCEPT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
SELECT 1 AS B, 3 AS c
--
QueryStmt
+-output_column_list=
| +-$except_distinct.b#10 AS b [INT64]
| +-$except_distinct.c#11 AS c [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[b#10, c#11]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$union_all.[b#6, c#7]
    | | |   +-op_type=UNION_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$union_all1.[b#2, c#3]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$union_all1.[a#1, b#2, c#3]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-a#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-b#2 := Literal(type=INT64, value=2)
    | | |   | | |       | +-c#3 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=$union_all1.[b#2, c#3]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=$union_all2.[b#5, c#4]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$union_all2.[c#4, b#5]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-c#4 := Literal(type=INT64, value=2)
    | | |   |   |       | +-b#5 := Literal(type=INT64, value=3)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=$union_all2.[b#5, c#4]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=INNER
    | | +-output_column_list=$union_all.[b#6, c#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_distinct2.[B#8, c#9]
    |   |   +-expr_list=
    |   |   | +-B#8 := Literal(type=INT64, value=1)
    |   |   | +-c#9 := Literal(type=INT64, value=3)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$except_distinct2.[B#8, c#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: nested set operations.
SELECT 1 AS B, 3 AS c
EXCEPT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 2 AS c, 3 AS b
)
--
QueryStmt
+-output_column_list=
| +-$except_distinct.B#10 AS B [INT64]
| +-$except_distinct.c#11 AS c [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$except_distinct.[B#10, c#11]
    +-op_type=EXCEPT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$except_distinct1.[B#1, c#2]
    | | |   +-expr_list=
    | | |   | +-B#1 := Literal(type=INT64, value=1)
    | | |   | +-c#2 := Literal(type=INT64, value=3)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$except_distinct1.[B#1, c#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=$union_all.[b#8, c#9]
    |   |   +-op_type=UNION_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=$union_all1.[b#4, c#5]
    |   |   | | |   +-node_source="resolver_set_operation_corresponding"
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=$union_all1.[a#3, b#4, c#5]
    |   |   | | |       +-expr_list=
    |   |   | | |       | +-a#3 := Literal(type=INT64, value=1)
    |   |   | | |       | +-b#4 := Literal(type=INT64, value=2)
    |   |   | | |       | +-c#5 := Literal(type=INT64, value=3)
    |   |   | | |       +-input_scan=
    |   |   | | |         +-SingleRowScan
    |   |   | | +-output_column_list=$union_all1.[b#4, c#5]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=$union_all2.[b#7, c#6]
    |   |   |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   |   |   +-input_scan=
    |   |   |   |     +-ProjectScan
    |   |   |   |       +-column_list=$union_all2.[c#6, b#7]
    |   |   |   |       +-expr_list=
    |   |   |   |       | +-c#6 := Literal(type=INT64, value=2)
    |   |   |   |       | +-b#7 := Literal(type=INT64, value=3)
    |   |   |   |       +-input_scan=
    |   |   |   |         +-SingleRowScan
    |   |   |   +-output_column_list=$union_all2.[b#7, c#6]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=$union_all.[b#8, c#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: nested set operations: column lists are not the same.
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 2 AS c, 3 AS b
)
EXCEPT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
SELECT 1 AS a, 3 AS C
--
ALTERNATION GROUPS:
    UNION ALL CORRESPONDING,STRICT CORRESPONDING
    INNER UNION ALL BY NAME,STRICT CORRESPONDING
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [b, c] and query 2 has [a, C] [at 6:1]
EXCEPT DISTINCT STRICT CORRESPONDING
^
--
ALTERNATION GROUPS:
    UNION ALL CORRESPONDING,BY NAME
    INNER UNION ALL BY NAME,BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [b, c] and query 2 has [a, C] [at 6:1]
EXCEPT DISTINCT BY NAME
^
==

# CORRESPONDING: nested set operations: column lists are not the same.
SELECT 1 AS a, 3 AS C
EXCEPT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS a, 2 AS b, 3 AS c
  {{UNION ALL CORRESPONDING|INNER UNION ALL BY NAME}}
  SELECT 2 AS c, 3 AS b
)
--
ALTERNATION GROUPS:
    STRICT CORRESPONDING,UNION ALL CORRESPONDING
    STRICT CORRESPONDING,INNER UNION ALL BY NAME
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [a, C] and query 2 has [b, c] [at 2:1]
EXCEPT DISTINCT STRICT CORRESPONDING
^
--
ALTERNATION GROUPS:
    BY NAME,UNION ALL CORRESPONDING
    BY NAME,INNER UNION ALL BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [a, C] and query 2 has [b, c] [at 2:1]
EXCEPT DISTINCT BY NAME
^
==

# CORRESPONDING: INNER + STRICT
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  {{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
  SELECT 2 AS B, 1 AS A
)
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 1 AS A, 2 AS B
--
QueryStmt
+-output_column_list=
| +-$union_all.A#10 AS A [INT64]
| +-$union_all.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#10, B#11]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_all.[A#6, B#7]
    | | |   +-op_type=INTERSECT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$intersect_all1.[A#1, B#2]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$intersect_all1.[A#1, B#2, C#3]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-B#2 := Literal(type=INT64, value=2)
    | | |   | | |       | +-C#3 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=$intersect_all1.[A#1, B#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=$intersect_all2.[A#5, B#4]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$intersect_all2.[B#4, A#5]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-B#4 := Literal(type=INT64, value=2)
    | | |   |   |       | +-A#5 := Literal(type=INT64, value=1)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=$intersect_all2.[A#5, B#4]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=INNER
    | | +-output_column_list=$intersect_all.[A#6, B#7]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#8, B#9]
    |   |   +-expr_list=
    |   |   | +-A#8 := Literal(type=INT64, value=1)
    |   |   | +-B#9 := Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#8, B#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: INNER + STRICT
SELECT 1 AS A, 2 AS B
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  {{INTERSECT ALL CORRESPONDING|INNER INTERSECT ALL BY NAME}}
  SELECT 2 AS B, 1 AS A
)
--
QueryStmt
+-output_column_list=
| +-$union_all.A#10 AS A [INT64]
| +-$union_all.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#10, B#11]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[A#1, B#2]
    | | |   +-expr_list=
    | | |   | +-A#1 := Literal(type=INT64, value=1)
    | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[A#1, B#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-SetOperationScan
    |   |   +-column_list=$intersect_all.[A#8, B#9]
    |   |   +-op_type=INTERSECT_ALL
    |   |   +-input_item_list=
    |   |   | +-SetOperationItem
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=$intersect_all1.[A#3, B#4]
    |   |   | | |   +-node_source="resolver_set_operation_corresponding"
    |   |   | | |   +-input_scan=
    |   |   | | |     +-ProjectScan
    |   |   | | |       +-column_list=$intersect_all1.[A#3, B#4, C#5]
    |   |   | | |       +-expr_list=
    |   |   | | |       | +-A#3 := Literal(type=INT64, value=1)
    |   |   | | |       | +-B#4 := Literal(type=INT64, value=2)
    |   |   | | |       | +-C#5 := Literal(type=INT64, value=3)
    |   |   | | |       +-input_scan=
    |   |   | | |         +-SingleRowScan
    |   |   | | +-output_column_list=$intersect_all1.[A#3, B#4]
    |   |   | +-SetOperationItem
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=$intersect_all2.[A#7, B#6]
    |   |   |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   |   |   +-input_scan=
    |   |   |   |     +-ProjectScan
    |   |   |   |       +-column_list=$intersect_all2.[B#6, A#7]
    |   |   |   |       +-expr_list=
    |   |   |   |       | +-B#6 := Literal(type=INT64, value=2)
    |   |   |   |       | +-A#7 := Literal(type=INT64, value=1)
    |   |   |   |       +-input_scan=
    |   |   |   |         +-SingleRowScan
    |   |   |   +-output_column_list=$intersect_all2.[A#7, B#6]
    |   |   +-column_match_mode=CORRESPONDING
    |   |   +-column_propagation_mode=INNER
    |   +-output_column_list=$intersect_all.[A#8, B#9]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: FULL + STRICT
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT {{CORRESPONDING|BY NAME}}
  SELECT 2 AS B
)
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
SELECT 3 AS C, 1 AS B, 2 AS A
--
QueryStmt
+-output_column_list=
| +-$union_all.A#13 AS A [INT64]
| +-$union_all.C#14 AS C [INT64]
| +-$union_all.B#15 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[A#13, C#14, B#15]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$intersect_distinct.[A#4, C#5, B#6]
    | | |   +-op_type=INTERSECT_DISTINCT
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=[$intersect_distinct1.A#1, $intersect_distinct1.C#2, $null_column_for_outer_set_op.B#7]
    | | |   | | |   +-node_source="resolver_set_operation_corresponding"
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-ProjectScan
    | | |   | | |       +-column_list=$intersect_distinct1.[A#1, C#2]
    | | |   | | |       +-expr_list=
    | | |   | | |       | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |       | +-C#2 := Literal(type=INT64, value=3)
    | | |   | | |       +-input_scan=
    | | |   | | |         +-SingleRowScan
    | | |   | | +-output_column_list=[$intersect_distinct1.A#1, $intersect_distinct1.C#2, $null_column_for_outer_set_op.B#7]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[$null_column_for_outer_set_op.A#8, $null_column_for_outer_set_op.C#9, $intersect_distinct2.B#3]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-A#8 := Literal(type=INT64, value=NULL)
    | | |   |   |   | +-C#9 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=[$intersect_distinct2.B#3]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-B#3 := Literal(type=INT64, value=2)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=[$null_column_for_outer_set_op.A#8, $null_column_for_outer_set_op.C#9, $intersect_distinct2.B#3]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=FULL
    | | +-output_column_list=$intersect_distinct.[A#4, C#5, B#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$union_all2.[A#12, C#10, B#11]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$union_all2.[C#10, B#11, A#12]
    |   |       +-expr_list=
    |   |       | +-C#10 := Literal(type=INT64, value=3)
    |   |       | +-B#11 := Literal(type=INT64, value=1)
    |   |       | +-A#12 := Literal(type=INT64, value=2)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$union_all2.[A#12, C#10, B#11]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: INNER + STRICT columns not identical.
SELECT 1 AS B, 2 AS A
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS A, 3 AS C
  {{INTERSECT DISTINCT CORRESPONDING|INNER INTERSECT DISTINCT BY NAME}}
  SELECT 2 AS B, 3 AS A
)
--
ALTERNATION GROUPS:
    STRICT CORRESPONDING,INTERSECT DISTINCT CORRESPONDING
    STRICT CORRESPONDING,INNER INTERSECT DISTINCT BY NAME
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [B, A] and query 2 has [A] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
--
ALTERNATION GROUPS:
    BY NAME,INTERSECT DISTINCT CORRESPONDING
    BY NAME,INNER INTERSECT DISTINCT BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [B, A] and query 2 has [A] [at 2:1]
UNION ALL BY NAME
^
==

# CORRESPONDING: FULL + STRICT
SELECT 3 AS C, 1 AS B, 2 AS A
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT {{CORRESPONDING|BY NAME}}
  SELECT 2 AS B
)
--
QueryStmt
+-output_column_list=
| +-$union_all.C#13 AS C [INT64]
| +-$union_all.B#14 AS B [INT64]
| +-$union_all.A#15 AS A [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$union_all.[C#13, B#14, A#15]
    +-op_type=UNION_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$union_all1.[C#1, B#2, A#3]
    | | |   +-expr_list=
    | | |   | +-C#1 := Literal(type=INT64, value=3)
    | | |   | +-B#2 := Literal(type=INT64, value=1)
    | | |   | +-A#3 := Literal(type=INT64, value=2)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$union_all1.[C#1, B#2, A#3]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_distinct.[C#8, B#9, A#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$intersect_distinct.[A#7, C#8, B#9]
    |   |       +-op_type=INTERSECT_DISTINCT
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=[$intersect_distinct1.A#4, $intersect_distinct1.C#5, $null_column_for_outer_set_op.B#10]
    |   |       | | |   +-node_source="resolver_set_operation_corresponding"
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-B#10 := Literal(type=INT64, value=NULL)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-ProjectScan
    |   |       | | |       +-column_list=$intersect_distinct1.[A#4, C#5]
    |   |       | | |       +-expr_list=
    |   |       | | |       | +-A#4 := Literal(type=INT64, value=1)
    |   |       | | |       | +-C#5 := Literal(type=INT64, value=3)
    |   |       | | |       +-input_scan=
    |   |       | | |         +-SingleRowScan
    |   |       | | +-output_column_list=[$intersect_distinct1.A#4, $intersect_distinct1.C#5, $null_column_for_outer_set_op.B#10]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[$null_column_for_outer_set_op.A#11, $null_column_for_outer_set_op.C#12, $intersect_distinct2.B#6]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-A#11 := Literal(type=INT64, value=NULL)
    |   |       |   |   | +-C#12 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=[$intersect_distinct2.B#6]
    |   |       |   |       +-expr_list=
    |   |       |   |       | +-B#6 := Literal(type=INT64, value=2)
    |   |       |   |       +-input_scan=
    |   |       |   |         +-SingleRowScan
    |   |       |   +-output_column_list=[$null_column_for_outer_set_op.A#11, $null_column_for_outer_set_op.C#12, $intersect_distinct2.B#6]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=FULL
    |   +-output_column_list=$intersect_distinct.[C#8, B#9, A#7]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: FULL + STRICT, not identical columns.
SELECT 3 AS C, 2 AS A
UNION ALL {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS A, 3 AS C
  FULL INTERSECT DISTINCT {{CORRESPONDING|BY NAME}}
  SELECT 2 AS B
)
--
ALTERNATION GROUPS:
    STRICT CORRESPONDING,CORRESPONDING
    STRICT CORRESPONDING,BY NAME
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [C, A] and query 2 has [A, C, B] [at 2:1]
UNION ALL STRICT CORRESPONDING
^
--
ALTERNATION GROUPS:
    BY NAME,CORRESPONDING
    BY NAME,BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [C, A] and query 2 has [A, C, B] [at 2:1]
UNION ALL BY NAME
^
==

# CORRESPONDING: LEFT + STRICT
(
  SELECT 1 AS A, 2 AS B
  LEFT EXCEPT ALL {{CORRESPONDING|BY NAME}}
  SELECT 2 AS A, 3 AS C
)
INTERSECT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS B, 3 AS A
--
QueryStmt
+-output_column_list=
| +-$intersect_distinct.A#10 AS A [INT64]
| +-$intersect_distinct.B#11 AS B [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_distinct.[A#10, B#11]
    +-op_type=INTERSECT_DISTINCT
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-SetOperationScan
    | | |   +-column_list=$except_all.[A#5, B#6]
    | | |   +-op_type=EXCEPT_ALL
    | | |   +-input_item_list=
    | | |   | +-SetOperationItem
    | | |   | | +-scan=
    | | |   | | | +-ProjectScan
    | | |   | | |   +-column_list=$except_all1.[A#1, B#2]
    | | |   | | |   +-expr_list=
    | | |   | | |   | +-A#1 := Literal(type=INT64, value=1)
    | | |   | | |   | +-B#2 := Literal(type=INT64, value=2)
    | | |   | | |   +-input_scan=
    | | |   | | |     +-SingleRowScan
    | | |   | | +-output_column_list=$except_all1.[A#1, B#2]
    | | |   | +-SetOperationItem
    | | |   |   +-scan=
    | | |   |   | +-ProjectScan
    | | |   |   |   +-column_list=[$except_all2.A#3, $null_column_for_outer_set_op.B#7]
    | | |   |   |   +-node_source="resolver_set_operation_corresponding"
    | | |   |   |   +-expr_list=
    | | |   |   |   | +-B#7 := Literal(type=INT64, value=NULL)
    | | |   |   |   +-input_scan=
    | | |   |   |     +-ProjectScan
    | | |   |   |       +-column_list=$except_all2.[A#3, C#4]
    | | |   |   |       +-expr_list=
    | | |   |   |       | +-A#3 := Literal(type=INT64, value=2)
    | | |   |   |       | +-C#4 := Literal(type=INT64, value=3)
    | | |   |   |       +-input_scan=
    | | |   |   |         +-SingleRowScan
    | | |   |   +-output_column_list=[$except_all2.A#3, $null_column_for_outer_set_op.B#7]
    | | |   +-column_match_mode=CORRESPONDING
    | | |   +-column_propagation_mode=LEFT
    | | +-output_column_list=$except_all.[A#5, B#6]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$intersect_distinct2.[A#9, B#8]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$intersect_distinct2.[B#8, A#9]
    |   |       +-expr_list=
    |   |       | +-B#8 := Literal(type=INT64, value=2)
    |   |       | +-A#9 := Literal(type=INT64, value=3)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-output_column_list=$intersect_distinct2.[A#9, B#8]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: LEFT + STRICT
SELECT 2 AS B, 3 AS A
INTERSECT ALL {{STRICT CORRESPONDING|BY NAME}}
(
  SELECT 1 AS A, 2 AS B
  LEFT EXCEPT ALL {{CORRESPONDING|BY NAME}}
  SELECT 2 AS A, 3 AS C
)
--
QueryStmt
+-output_column_list=
| +-$intersect_all.B#10 AS B [INT64]
| +-$intersect_all.A#11 AS A [INT64]
+-query=
  +-SetOperationScan
    +-column_list=$intersect_all.[B#10, A#11]
    +-op_type=INTERSECT_ALL
    +-input_item_list=
    | +-SetOperationItem
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=$intersect_all1.[B#1, A#2]
    | | |   +-expr_list=
    | | |   | +-B#1 := Literal(type=INT64, value=2)
    | | |   | +-A#2 := Literal(type=INT64, value=3)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-output_column_list=$intersect_all1.[B#1, A#2]
    | +-SetOperationItem
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$except_all.[B#8, A#7]
    |   |   +-node_source="resolver_set_operation_corresponding"
    |   |   +-input_scan=
    |   |     +-SetOperationScan
    |   |       +-column_list=$except_all.[A#7, B#8]
    |   |       +-op_type=EXCEPT_ALL
    |   |       +-input_item_list=
    |   |       | +-SetOperationItem
    |   |       | | +-scan=
    |   |       | | | +-ProjectScan
    |   |       | | |   +-column_list=$except_all1.[A#3, B#4]
    |   |       | | |   +-expr_list=
    |   |       | | |   | +-A#3 := Literal(type=INT64, value=1)
    |   |       | | |   | +-B#4 := Literal(type=INT64, value=2)
    |   |       | | |   +-input_scan=
    |   |       | | |     +-SingleRowScan
    |   |       | | +-output_column_list=$except_all1.[A#3, B#4]
    |   |       | +-SetOperationItem
    |   |       |   +-scan=
    |   |       |   | +-ProjectScan
    |   |       |   |   +-column_list=[$except_all2.A#5, $null_column_for_outer_set_op.B#9]
    |   |       |   |   +-node_source="resolver_set_operation_corresponding"
    |   |       |   |   +-expr_list=
    |   |       |   |   | +-B#9 := Literal(type=INT64, value=NULL)
    |   |       |   |   +-input_scan=
    |   |       |   |     +-ProjectScan
    |   |       |   |       +-column_list=$except_all2.[A#5, C#6]
    |   |       |   |       +-expr_list=
    |   |       |   |       | +-A#5 := Literal(type=INT64, value=2)
    |   |       |   |       | +-C#6 := Literal(type=INT64, value=3)
    |   |       |   |       +-input_scan=
    |   |       |   |         +-SingleRowScan
    |   |       |   +-output_column_list=[$except_all2.A#5, $null_column_for_outer_set_op.B#9]
    |   |       +-column_match_mode=CORRESPONDING
    |   |       +-column_propagation_mode=LEFT
    |   +-output_column_list=$except_all.[B#8, A#7]
    +-column_match_mode=CORRESPONDING
==

# CORRESPONDING: LEFT + STRICT, not identical columns
(
  SELECT 1 AS A, 2 AS B, 3 AS C
  LEFT EXCEPT ALL {{CORRESPONDING|BY NAME}}
  SELECT 2 AS A, 3 AS C
)
INTERSECT DISTINCT {{STRICT CORRESPONDING|BY NAME}}
SELECT 2 AS B, 3 AS A
--
ALTERNATION GROUPS:
    CORRESPONDING,STRICT CORRESPONDING
    BY NAME,STRICT CORRESPONDING
--
ERROR: STRICT CORRESPONDING requires all input queries to have identical column names, but query 1 has [A, B, C] and query 2 has [B, A] [at 6:1]
INTERSECT DISTINCT STRICT CORRESPONDING
^
--
ALTERNATION GROUPS:
    CORRESPONDING,BY NAME
    BY NAME,BY NAME
--
ERROR: BY NAME requires all input queries to have identical column names, but query 1 has [A, B, C] and query 2 has [B, A] [at 6:1]
INTERSECT DISTINCT BY NAME
^
==

SELECT 5 x
LEFT UNION ALL CORRESPONDING
SELECT 6 x
UNION ALL STRICT CORRESPONDING
SELECT 7 x
--
ERROR: Different set operation modifiers (LEFT and STRICT) cannot be used in the same query without using parentheses for grouping [at 4:11]
UNION ALL STRICT CORRESPONDING
          ^
