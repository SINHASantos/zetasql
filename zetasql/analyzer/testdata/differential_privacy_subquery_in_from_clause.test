# Tests for differential privacy queries with subqueries in the FROM clause.
[default language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS]

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
# Nested projection without $uid column
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64 from SimpleTypesWithAnonymizationUid {{a|}});
--
ALTERNATION GROUP: a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1], alias="a")
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid'
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.int64#2], table=SimpleTypesWithAnonymizationUid, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Repeated nested projection clears uid column qualifier
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64 from (
      select a.int64, a.uid from SimpleTypesWithAnonymizationUid a));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |       +-input_scan=
        |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10], alias="a")
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Updated qualifers in repeated nested projection aren't handled correctly
# TODO: figure out how we can respect re-aliased qualifiers
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select b.int64 from (
      select a.int64, a.uid from SimpleTypesWithAnonymizationUid a) b);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[SimpleTypesWithAnonymizationUid.int64#2]
        |   +-input_scan=
        |     +-ProjectScan
        |       +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |       +-input_scan=
        |         +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10], alias="a")
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid'
==

# Nested projection with $uid column
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(int64, contribution_bounds_per_group => (0,10))
from (select int64, uid from SimpleTypesWithAnonymizationUid);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |   +-input_scan=
        |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        +-aggregate_list=
          +-$agg1#13 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#13 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#13]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#13]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#15, $group_by.$uid#16]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11]
        |   |   +-input_scan=
        |   |     +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[int64#2, uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[1, 10])
        |   +-group_by_list=
        |   | +-$uid#16 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   +-aggregate_list=
        |     +-$agg1_partial#15 :=
        |       +-AggregateFunctionCall(ZetaSQL:count(INT64) -> INT64)
        |         +-ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.int64#2)
        +-aggregate_list=
        | +-$agg1#13 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#15)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 10})
        | +-$group_selection_threshold_col#19 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#19)
==

# Reject nested aggregation functions
select with differential_privacy sum(count(int64, contribution_bounds_per_group => (0,10)))
from SimpleTypesWithAnonymizationUid;
--
ERROR: Aggregations of aggregations are not allowed [at 1:34]
select with differential_privacy sum(count(int64, contribution_bounds_per_gro...
                                 ^
==

# Support basic nested aggregation scans
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with DIFFERENTIAL_PRIVACY count(*, contribution_bounds_per_group => (0,100))
from (
  SELECT count(*), uid
  from SimpleTypesWithAnonymizationUid
  group by uid);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#17, $group_by.$uid#18]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13, $groupby.uid#14]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.uid#14, $aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       +-group_by_list=
        |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |       +-aggregate_list=
        |   |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#18 := ColumnRef(type=INT64, column=$groupby.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#17 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#15 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#17)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#21 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#21)
==

# Reject nested aggregation scans that don't group by $uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#14 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-145
    +-column_list=[$aggregate.$agg1#14]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#14]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=90-144
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=111-142, table=SimpleTypesWithAnonymizationUid, alias="a")
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=97-102)
        +-aggregate_list=
          +-$agg1#14 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 2:7]
from (SELECT count(*) from SimpleTypesWithAnonymizationUid a);
      ^
==

# Reject nested aggregation scans that don't project the grouped by $uid
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid{{ a|}}
  group by uid);
--
ALTERNATION GROUP:  a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-165
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=93-164
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=116-147, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="a")
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(parse_location=161-164, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=100-105)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid a
  group by uid);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 3:3]
  SELECT count(*)
  ^
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-163
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=93-162
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=116-147, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-uid#14 := ColumnRef(parse_location=159-162, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=100-105)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (
  SELECT count(*)
  from SimpleTypesWithAnonymizationUid
  group by uid);

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 3:3]
  SELECT count(*)
  ^
==

# Projecting, aliasing, grouping don't interfere with explicitly grouping by
# $uid in nested aggregation
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
    SELECT count(*), y
    from (
      select x, y
      from (
        select uid as x, uid as y
        from SimpleTypesWithAnonymizationUid)
      group by x, y)
    group by y)
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#16 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#16]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#16]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$aggregate.$agg1#14, $groupby.y#15]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.y#15, $aggregate.$agg1#14]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=$groupby.[x#13, x#13]
        |       |   +-input_scan=
        |       |     +-AggregateScan
        |       |       +-column_list=[$groupby.x#13]
        |       |       +-input_scan=
        |       |       | +-ProjectScan
        |       |       |   +-column_list=SimpleTypesWithAnonymizationUid.[uid#11, uid#11]
        |       |       |   +-input_scan=
        |       |       |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       |       +-group_by_list=
        |       |         +-x#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-group_by_list=
        |       | +-y#15 := ColumnRef(type=INT64, column=$groupby.x#13)
        |       +-aggregate_list=
        |         +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
          +-$agg1#16 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#16 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#16]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#16]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#18, $group_by.$uid#19]
        |   +-input_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#14, $groupby.y#15]
        |   |   +-input_scan=
        |   |     +-AggregateScan
        |   |       +-column_list=[$groupby.y#15, $aggregate.$agg1#14]
        |   |       +-input_scan=
        |   |       | +-ProjectScan
        |   |       |   +-column_list=$groupby.[x#13, x#13]
        |   |       |   +-input_scan=
        |   |       |     +-AggregateScan
        |   |       |       +-column_list=[$groupby.x#13]
        |   |       |       +-input_scan=
        |   |       |       | +-ProjectScan
        |   |       |       |   +-column_list=SimpleTypesWithAnonymizationUid.[uid#11, uid#11]
        |   |       |       |   +-input_scan=
        |   |       |       |     +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |       |       +-group_by_list=
        |   |       |         +-x#13 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |       +-group_by_list=
        |   |       | +-y#15 := ColumnRef(type=INT64, column=$groupby.x#13)
        |   |       +-aggregate_list=
        |   |         +-$agg1#14 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-group_by_list=
        |   | +-$uid#19 := ColumnRef(type=INT64, column=$groupby.y#15)
        |   +-aggregate_list=
        |     +-$agg1_partial#18 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#16 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#18)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#22 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#22)
==

# Reject mutated group by $uid column in nested aggregation
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from
  (SELECT count(*), 10+uid as x
   from SimpleTypesWithAnonymizationUid{{ a|}}
   group by x)
--
ALTERNATION GROUP:  a
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-177
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=92-176
        |   +-column_list=[$aggregate.$agg1#13, $groupby.x#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.x#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=129-160, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10], alias="a")
        |       +-group_by_list=
        |       | +-x#14 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-parse_location=109-115
        |       |     +-Literal(parse_location=109-111, type=INT64, value=10)
        |       |     +-ColumnRef(parse_location=112-115, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=99-104)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from
  (SELECT count(*), @_p1_INT64+uid as x
   from SimpleTypesWithAnonymizationUid a
   group by x)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'a.uid' [at 3:4]
  (SELECT count(*), 10+uid as x
   ^
--
ALTERNATION GROUP: <empty>
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#15 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-175
    +-column_list=[$aggregate.$agg1#15]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#15]
        +-input_scan=
        | +-ProjectScan
        |   +-parse_location=92-174
        |   +-column_list=[$aggregate.$agg1#13, $groupby.x#14]
        |   +-input_scan=
        |     +-AggregateScan
        |       +-column_list=[$groupby.x#14, $aggregate.$agg1#13]
        |       +-input_scan=
        |       | +-TableScan(parse_location=129-160, column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |       +-group_by_list=
        |       | +-x#14 :=
        |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |       |     +-parse_location=109-115
        |       |     +-Literal(parse_location=109-111, type=INT64, value=10)
        |       |     +-ColumnRef(parse_location=112-115, type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |       +-aggregate_list=
        |         +-$agg1#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)(parse_location=99-104)
        +-aggregate_list=
          +-$agg1#15 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-82, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from
  (SELECT count(*), @_p1_INT64+uid as x
   from SimpleTypesWithAnonymizationUid
   group by x)

Rewrite ERROR: Subqueries of differential_privacy queries must explicitly SELECT the userid column 'uid' [at 3:4]
  (SELECT count(*), 10+uid as x
   ^
==

# Valid query using all supported per-user scan types
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
select with differential_privacy count(*, contribution_bounds_per_group => (0,100))
from (
  select a.int64, (select 1) as b
  from (
      SELECT count(*) as int64, uid
      from SimpleTypesWithAnonymizationUid
      group by uid) a,
    SimpleTypes b
  where a.int64 > 0 order by a.int64 limit 10);
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#36 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#36]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#36]
        +-input_scan=
        | +-LimitOffsetScan
        |   +-column_list=[$aggregate.int64#13, $subquery1.b#35]
        |   +-input_scan=
        |   | +-OrderByScan
        |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#35]
        |   |   +-is_ordered=TRUE
        |   |   +-input_scan=
        |   |   | +-ProjectScan
        |   |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14, $subquery1.b#35]
        |   |   |   +-expr_list=
        |   |   |   | +-b#35 :=
        |   |   |   |   +-SubqueryExpr
        |   |   |   |     +-type=INT64
        |   |   |   |     +-subquery_type=SCALAR
        |   |   |   |     +-subquery=
        |   |   |   |       +-ProjectScan
        |   |   |   |         +-column_list=[$expr_subquery.$col1#34]
        |   |   |   |         +-expr_list=
        |   |   |   |         | +-$col1#34 := Literal(type=INT64, value=1)
        |   |   |   |         +-input_scan=
        |   |   |   |           +-SingleRowScan
        |   |   |   +-input_scan=
        |   |   |     +-FilterScan
        |   |   |       +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       +-input_scan=
        |   |   |       | +-JoinScan
        |   |   |       |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       |   +-left_scan=
        |   |   |       |   | +-ProjectScan
        |   |   |       |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |       |   |   +-input_scan=
        |   |   |       |   |     +-AggregateScan
        |   |   |       |   |       +-column_list=[$groupby.uid#14, $aggregate.int64#13]
        |   |   |       |   |       +-input_scan=
        |   |   |       |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   |       |   |       +-group_by_list=
        |   |   |       |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |   |       |   |       +-aggregate_list=
        |   |   |       |   |         +-int64#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |   |       |   +-right_scan=
        |   |   |       |     +-TableScan(table=SimpleTypes, alias="b")
        |   |   |       +-filter_expr=
        |   |   |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |   |   |           +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   |           +-Literal(type=INT64, value=0)
        |   |   +-order_by_item_list=
        |   |     +-OrderByItem
        |   |       +-column_ref=
        |   |         +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   +-limit=
        |     +-Literal(type=INT64, value=10)
        +-aggregate_list=
          +-$agg1#36 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#36 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#36]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#36]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$aggregate.$agg1_partial#38, $group_by.$uid#39]
        |   +-input_scan=
        |   | +-LimitOffsetScan
        |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#35, $groupby.uid#14]
        |   |   +-input_scan=
        |   |   | +-OrderByScan
        |   |   |   +-column_list=[$aggregate.int64#13, $subquery1.b#35, $groupby.uid#14]
        |   |   |   +-is_ordered=TRUE
        |   |   |   +-input_scan=
        |   |   |   | +-ProjectScan
        |   |   |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14, $subquery1.b#35]
        |   |   |   |   +-expr_list=
        |   |   |   |   | +-b#35 :=
        |   |   |   |   |   +-SubqueryExpr
        |   |   |   |   |     +-type=INT64
        |   |   |   |   |     +-subquery_type=SCALAR
        |   |   |   |   |     +-subquery=
        |   |   |   |   |       +-ProjectScan
        |   |   |   |   |         +-column_list=[$expr_subquery.$col1#34]
        |   |   |   |   |         +-expr_list=
        |   |   |   |   |         | +-$col1#34 := Literal(type=INT64, value=1)
        |   |   |   |   |         +-input_scan=
        |   |   |   |   |           +-SingleRowScan
        |   |   |   |   +-input_scan=
        |   |   |   |     +-FilterScan
        |   |   |   |       +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       +-input_scan=
        |   |   |   |       | +-JoinScan
        |   |   |   |       |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       |   +-left_scan=
        |   |   |   |       |   | +-ProjectScan
        |   |   |   |       |   |   +-column_list=[$aggregate.int64#13, $groupby.uid#14]
        |   |   |   |       |   |   +-input_scan=
        |   |   |   |       |   |     +-AggregateScan
        |   |   |   |       |   |       +-column_list=[$groupby.uid#14, $aggregate.int64#13]
        |   |   |   |       |   |       +-input_scan=
        |   |   |   |       |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.uid#11], table=SimpleTypesWithAnonymizationUid, column_index_list=[10])
        |   |   |   |       |   |       +-group_by_list=
        |   |   |   |       |   |       | +-uid#14 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#11)
        |   |   |   |       |   |       +-aggregate_list=
        |   |   |   |       |   |         +-int64#13 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   |   |   |       |   +-right_scan=
        |   |   |   |       |     +-TableScan(table=SimpleTypes, alias="b")
        |   |   |   |       +-filter_expr=
        |   |   |   |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |   |   |   |           +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   |   |           +-Literal(type=INT64, value=0)
        |   |   |   +-order_by_item_list=
        |   |   |     +-OrderByItem
        |   |   |       +-column_ref=
        |   |   |         +-ColumnRef(type=INT64, column=$aggregate.int64#13)
        |   |   +-limit=
        |   |     +-Literal(type=INT64, value=10)
        |   +-group_by_list=
        |   | +-$uid#39 := ColumnRef(type=INT64, column=$groupby.uid#14)
        |   +-aggregate_list=
        |     +-$agg1_partial#38 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        +-aggregate_list=
        | +-$agg1#36 :=
        | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#38)
        | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        | +-$group_selection_threshold_col#42 :=
        |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |     +-Literal(type=INT64, value=1)
        |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        +-group_selection_threshold_expr=
          +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#42)
==

# Outer scan can use join, aggregation, etc. with no issues
[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
SELECT count(*) from (
  select with differential_privacy count(string, contribution_bounds_per_group => (0,100))
  from SimpleTypesWithAnonymizationUid)
cross join SimpleTypes;
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#33 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#33]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#33]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-TableScan(column_list=[SimpleTypesWithAnonymizationUid.string#5], table=SimpleTypesWithAnonymizationUid, column_index_list=[4])
        |   |       +-aggregate_list=
        |   |         +-$agg1#13 :=
        |   |           +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count(STRING, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |             +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |   |             +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#33 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#33]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#33]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=[$aggregate.$agg1#13]
        |   +-left_scan=
        |   | +-ProjectScan
        |   |   +-column_list=[$aggregate.$agg1#13]
        |   |   +-input_scan=
        |   |     +-DifferentialPrivacyAggregateScan
        |   |       +-column_list=[$aggregate.$agg1#13]
        |   |       +-input_scan=
        |   |       | +-AggregateScan
        |   |       |   +-column_list=[$aggregate.$agg1_partial#36, $group_by.$uid#37]
        |   |       |   +-input_scan=
        |   |       |   | +-TableScan(column_list=SimpleTypesWithAnonymizationUid.[string#5, uid#34], table=SimpleTypesWithAnonymizationUid, column_index_list=[4, 10])
        |   |       |   +-group_by_list=
        |   |       |   | +-$uid#37 := ColumnRef(type=INT64, column=SimpleTypesWithAnonymizationUid.uid#34)
        |   |       |   +-aggregate_list=
        |   |       |     +-$agg1_partial#36 :=
        |   |       |       +-AggregateFunctionCall(ZetaSQL:count(STRING) -> INT64)
        |   |       |         +-ColumnRef(type=STRING, column=SimpleTypesWithAnonymizationUid.string#5)
        |   |       +-aggregate_list=
        |   |       | +-$agg1#13 :=
        |   |       | | +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |       | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1_partial#36)
        |   |       | |   +-Literal(type=STRUCT<INT64, INT64>, value={0, 100})
        |   |       | +-$group_selection_threshold_col#40 :=
        |   |       |   +-AggregateFunctionCall(ZetaSQL:$differential_privacy_sum(INT64, optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
        |   |       |     +-Literal(type=INT64, value=1)
        |   |       |     +-Literal(type=STRUCT<INT64, INT64>, value={0, 1})
        |   |       +-group_selection_threshold_expr=
        |   |         +-ColumnRef(type=INT64, column=$differential_privacy.$group_selection_threshold_col#40)
        |   +-right_scan=
        |     +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#33 := AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
==
