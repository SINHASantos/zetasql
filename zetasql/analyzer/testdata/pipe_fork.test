[default language_features=MAXIMUM]
[default enabled_ast_rewrites=DEFAULTS]
[language_features=NONE,+PIPES]
FROM KeyValue
|> FORK ()
--
ERROR: Pipe FORK not supported [at 2:1]
|> FORK ()
^
==

# FORK is allowed only if both QUERY and GENERALIZED_QUERY
# statement kinds are enabled.
# TODO SQLBuilder doesn't work for pipe FORK yet.
[default no_run_sqlbuilder]
[default language_features=MAXIMUM,+PIPES,+PIPE_FORK,+PIPE_IF,+TABLE_VALUED_FUNCTIONS,+CREATE_TABLE_FUNCTION,+WITH_ON_SUBQUERY,+PIPE_STATIC_DESCRIBE,+PIPE_CREATE_TABLE,+PIPE_EXPORT_DATA,+WITH_RECURSIVE,+PIPE_LOG]
[supported_statement_kinds={{QUERY|GENERALIZED_QUERY|QUERY,GENERALIZED_QUERY|INSERT}}]
FROM KeyValue
|> FORK ()
--
ALTERNATION GROUP: QUERY
--
ERROR: Generalized query statements are not supported so pipe FORK cannot be used [at 2:1]
|> FORK ()
^
--
ALTERNATION GROUPS:
    GENERALIZED_QUERY
    INSERT
--
ERROR: Statement not supported: QueryStatement [at 1:1]
FROM KeyValue
^
--
ALTERNATION GROUP: QUERY,GENERALIZED_QUERY
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    +-query=
      +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# FORK accepts hints, but they are dropped in the rewrite.
FROM KeyValue
|> LIMIT 10
|> FORK @{hint=5}
     ( |> WHERE true ),
     ( |> WHERE false )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-hint_list=
    | +-hint := Literal(type=INT64, value=5)
    +-input_scan=
    | +-LimitOffsetScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-limit=
    |     +-Literal(type=INT64, value=10)
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-FilterScan
      | |       +-column_list=KeyValue.[Key#1, Value#2]
      | |       +-input_scan=
      | |       | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | |       +-filter_expr=
      | |         +-Literal(type=BOOL, value=true)
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Key#1 AS Key [INT64]
      |       +-KeyValue.Value#2 AS Value [STRING]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-FilterScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-input_scan=
        |       | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |       +-filter_expr=
        |         +-Literal(type=BOOL, value=false)
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-LimitOffsetScan
  |         +-column_list=KeyValue.[Key#1, Value#2]
  |         +-input_scan=
  |         | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  |         +-limit=
  |           +-Literal(type=INT64, value=10)
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS Key [INT64]
  | | +-KeyValue.Value#2 AS Value [STRING]
  | +-query=
  |   +-FilterScan
  |     +-column_list=KeyValue.[Key#1, Value#2]
  |     +-input_scan=
  |     | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  |     +-filter_expr=
  |       +-Literal(type=BOOL, value=true)
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    +-query=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
        +-filter_expr=
          +-Literal(type=BOOL, value=false)
==

FROM KeyValue
|> FORK (
    |> SELECT key
   ), (
    |> SELECT value
   ), (
    |> WHERE key = 0
    |> EXTEND key*1000 k1000
   )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-ProjectScan
      | |       +-column_list=[KeyValue.Key#1]
      | |       +-input_scan=
      | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Key#1 AS key [INT64]
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-ProjectScan
      | |       +-column_list=[KeyValue.Value#2]
      | |       +-input_scan=
      | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Value#2 AS value [STRING]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-ProjectScan
        |       +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k1000#3]
        |       +-expr_list=
        |       | +-k1000#3 :=
        |       |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
        |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       |     +-Literal(type=INT64, value=1000)
        |       +-input_scan=
        |         +-FilterScan
        |           +-column_list=KeyValue.[Key#1, Value#2]
        |           +-input_scan=
        |           | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |           +-filter_expr=
        |             +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |               +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |               +-Literal(type=INT64, value=0)
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]
              +-$pipe_extend.k1000#3 AS k1000 [INT64]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[KeyValue.Key#1]
  |     +-input_scan=
  |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Value#2 AS value [STRING]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[KeyValue.Value#2]
  |     +-input_scan=
  |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    | +-$pipe_extend.k1000#3 AS k1000 [INT64]
    +-query=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k1000#3]
        +-expr_list=
        | +-k1000#3 :=
        |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |     +-Literal(type=INT64, value=1000)
        +-input_scan=
          +-FilterScan
            +-column_list=KeyValue.[Key#1, Value#2]
            +-input_scan=
            | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
            +-filter_expr=
              +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
                +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-Literal(type=INT64, value=0)
==

FROM KeyValue
|> FORK ()
|> WHERE true
--
ERROR: Additional pipe operators cannot follow the terminal pipe operator FORK [at 3:1]
|> WHERE true
^
==

# Even STATIC_DESCRIBE isn't allowed after a terminal operator.
FROM KeyValue
|> FORK ()
|> STATIC_DESCRIBE
--
ERROR: Additional pipe operators cannot follow the terminal pipe operator FORK [at 3:1]
|> STATIC_DESCRIBE
^
==

FROM KeyValue
|> FORK (), ()
|> WHERE true
--
ERROR: Additional pipe operators cannot follow the terminal pipe operator FORK [at 3:1]
|> WHERE true
^
==

# FORK in table subquery.
FROM (
  FROM KeyValue
  |> FORK ()
)
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 3:3]
  |> FORK ()
  ^
==

# FORK in a parenthesized query.
# This is okay because the parentheses don't make it a subquery.
(
FROM KeyValue
|> FORK ()
)
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    +-query=
      +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# FORK in expression subquery.
FROM KeyValue
|> SELECT (
     FROM KeyValue
     |> FORK ()
   )
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 4:6]
     |> FORK ()
     ^
==

# FORK in non-query-statement.
CREATE {{VIEW|TABLE}} vt AS
FROM KeyValue
|> FORK ()
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 3:1]
|> FORK ()
^
==

# FORK in CREATE TVF.
# This also shows the error messages when various statement kinds are
# enabled, for this non-query statement.
[supported_statement_kinds={{QUERY|GENERALIZED_QUERY|QUERY,GENERALIZED_QUERY|INSERT}},CREATE_TABLE_FUNCTION]
CREATE TABLE FUNCTION tvf() AS
FROM KeyValue
|> FORK ()
--
ALTERNATION GROUPS:
    QUERY
    INSERT
--
ERROR: Generalized query statements are not supported so pipe FORK cannot be used [at 3:1]
|> FORK ()
^
--
ALTERNATION GROUPS:
    GENERALIZED_QUERY
    QUERY,GENERALIZED_QUERY
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 3:1]
|> FORK ()
^
==

# FORK in a CTE definition.
WITH cte AS (
  FROM KeyValue
  |> FORK ()
)
FROM cte
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 3:3]
  |> FORK ()
  ^
==

# FORK used in the final query of a CTE,
# with the CTE reference in the main query before the FORK.
# We also have an unused CTE.
WITH cte AS (FROM KeyValue),
     unused_cte AS (SELECT 1 unused)
FROM cte
|> FORK ( |> SELECT key ),
        ( |> SELECT value )
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="cte"
    | | +-with_subquery=
    | |   +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | +-WithEntry
    |   +-with_query_name="unused_cte"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[unused_cte.unused#3]
    |       +-expr_list=
    |       | +-unused#3 := Literal(type=INT64, value=1)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-PipeForkScan
        +-input_scan=
        | +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="cte")
        +-subpipeline_list=
          +-GeneralizedQuerySubpipeline
          | +-subpipeline=
          | | +-Subpipeline
          | |   +-scan=
          | |     +-ProjectScan
          | |       +-column_list=[cte.Key#4]
          | |       +-input_scan=
          | |         +-SubpipelineInputScan(column_list=cte.[Key#4, Value#5])
          | +-output_schema=
          |   +-OutputSchema
          |     +-output_column_list=
          |       +-cte.Key#4 AS key [INT64]
          +-GeneralizedQuerySubpipeline
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-ProjectScan
            |       +-column_list=[cte.Value#5]
            |       +-input_scan=
            |         +-SubpipelineInputScan(column_list=cte.[Key#4, Value#5])
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-cte.Value#5 AS value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="cte"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="unused_cte"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=[unused_cte.unused#3]
  |         +-expr_list=
  |         | +-unused#3 := Literal(type=INT64, value=1)
  |         +-input_scan=
  |           +-SingleRowScan
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="cte")
  +-QueryStmt
  | +-output_column_list=
  | | +-cte.Key#4 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[cte.Key#4]
  |     +-input_scan=
  |       +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-cte.Value#5 AS value [STRING]
    +-query=
      +-ProjectScan
        +-column_list=[cte.Value#5]
        +-input_scan=
          +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="$fork_cte_1")
==

# CTE references in the FORKs.
WITH cte AS (FROM KeyValue)
SELECT 1 key
|> FORK ( |> JOIN cte USING (key) ),
        ( |> LEFT JOIN cte USING (key) )
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="cte"
    |   +-with_subquery=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-query=
      +-PipeForkScan
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$query.key#3]
        |   +-expr_list=
        |   | +-key#3 := Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-SingleRowScan
        +-subpipeline_list=
          +-GeneralizedQuerySubpipeline
          | +-subpipeline=
          | | +-Subpipeline
          | |   +-scan=
          | |     +-JoinScan
          | |       +-column_list=[$query.key#3, cte.Key#4, cte.Value#5]
          | |       +-left_scan=
          | |       | +-SubpipelineInputScan(column_list=[$query.key#3])
          | |       +-right_scan=
          | |       | +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="cte")
          | |       +-join_expr=
          | |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
          | |       |   +-ColumnRef(type=INT64, column=$query.key#3)
          | |       |   +-ColumnRef(type=INT64, column=cte.Key#4)
          | |       +-has_using=TRUE
          | +-output_schema=
          |   +-OutputSchema
          |     +-output_column_list=
          |       +-$query.key#3 AS key [INT64]
          |       +-cte.Value#5 AS Value [STRING]
          +-GeneralizedQuerySubpipeline
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-JoinScan
            |       +-column_list=[$query.key#3, cte.Key#6, cte.Value#7]
            |       +-join_type=LEFT
            |       +-left_scan=
            |       | +-SubpipelineInputScan(column_list=[$query.key#3])
            |       +-right_scan=
            |       | +-WithRefScan(column_list=cte.[Key#6, Value#7], with_query_name="cte")
            |       +-join_expr=
            |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |       |   +-ColumnRef(type=INT64, column=$query.key#3)
            |       |   +-ColumnRef(type=INT64, column=cte.Key#6)
            |       +-has_using=TRUE
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-$query.key#3 AS key [INT64]
                  +-cte.Value#7 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="cte"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=[$query.key#3]
  |         +-expr_list=
  |         | +-key#3 := Literal(type=INT64, value=1)
  |         +-input_scan=
  |           +-SingleRowScan
  +-QueryStmt
  | +-output_column_list=
  | | +-$query.key#3 AS key [INT64]
  | | +-cte.Value#5 AS Value [STRING]
  | +-query=
  |   +-JoinScan
  |     +-column_list=[$query.key#3, cte.Key#4, cte.Value#5]
  |     +-left_scan=
  |     | +-WithRefScan(column_list=[$query.key#3], with_query_name="$fork_cte_1")
  |     +-right_scan=
  |     | +-WithRefScan(column_list=cte.[Key#4, Value#5], with_query_name="cte")
  |     +-join_expr=
  |     | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
  |     |   +-ColumnRef(type=INT64, column=$query.key#3)
  |     |   +-ColumnRef(type=INT64, column=cte.Key#4)
  |     +-has_using=TRUE
  +-QueryStmt
    +-output_column_list=
    | +-$query.key#3 AS key [INT64]
    | +-cte.Value#7 AS Value [STRING]
    +-query=
      +-JoinScan
        +-column_list=[$query.key#3, cte.Key#6, cte.Value#7]
        +-join_type=LEFT
        +-left_scan=
        | +-WithRefScan(column_list=[$query.key#3], with_query_name="$fork_cte_1")
        +-right_scan=
        | +-WithRefScan(column_list=cte.[Key#6, Value#7], with_query_name="cte")
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   +-ColumnRef(type=INT64, column=$query.key#3)
        |   +-ColumnRef(type=INT64, column=cte.Key#6)
        +-has_using=TRUE
==

# CTE references in both before FORK and in one of the forks.
WITH cte AS (FROM KeyValue)
FROM cte
|> FORK ( |> SELECT key ),
        ( |> JOIN cte AS cte2 USING (key) )
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="cte"
    |   +-with_subquery=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-query=
      +-PipeForkScan
        +-input_scan=
        | +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="cte")
        +-subpipeline_list=
          +-GeneralizedQuerySubpipeline
          | +-subpipeline=
          | | +-Subpipeline
          | |   +-scan=
          | |     +-ProjectScan
          | |       +-column_list=[cte.Key#3]
          | |       +-input_scan=
          | |         +-SubpipelineInputScan(column_list=cte.[Key#3, Value#4])
          | +-output_schema=
          |   +-OutputSchema
          |     +-output_column_list=
          |       +-cte.Key#3 AS key [INT64]
          +-GeneralizedQuerySubpipeline
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-JoinScan
            |       +-column_list=cte.[Key#3, Value#4, Key#5, Value#6]
            |       +-left_scan=
            |       | +-SubpipelineInputScan(column_list=cte.[Key#3, Value#4])
            |       +-right_scan=
            |       | +-WithRefScan(column_list=cte.[Key#5, Value#6], with_query_name="cte")
            |       +-join_expr=
            |       | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            |       |   +-ColumnRef(type=INT64, column=cte.Key#3)
            |       |   +-ColumnRef(type=INT64, column=cte.Key#5)
            |       +-has_using=TRUE
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-cte.Key#3 AS key [INT64]
                  +-cte.Value#4 AS Value [STRING]
                  +-cte.Value#6 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="cte"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="cte")
  +-QueryStmt
  | +-output_column_list=
  | | +-cte.Key#3 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[cte.Key#3]
  |     +-input_scan=
  |       +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-cte.Key#3 AS key [INT64]
    | +-cte.Value#4 AS Value [STRING]
    | +-cte.Value#6 AS Value [STRING]
    +-query=
      +-JoinScan
        +-column_list=cte.[Key#3, Value#4, Key#5, Value#6]
        +-left_scan=
        | +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="$fork_cte_1")
        +-right_scan=
        | +-WithRefScan(column_list=cte.[Key#5, Value#6], with_query_name="cte")
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   +-ColumnRef(type=INT64, column=cte.Key#3)
        |   +-ColumnRef(type=INT64, column=cte.Key#5)
        +-has_using=TRUE
==

# FORK isn't allowed under a CTE inside a subquery.
FROM (
  WITH cte AS (FROM KeyValue)
  FROM cte
  |> FORK ( |> SELECT key ),
          ( |> SELECT value )
)
--
ERROR: FORK is only allowed as part of the outermost query in a statement [at 4:3]
  |> FORK ( |> SELECT key ),
  ^
==

# FORK after a WITH RECURSIVE.  This one doesn't have any recursion, but uses
# the fact that RECURSIVE enables the CTE definitions to be out of order.
# The resolver reorders them into execution order so they still work as
# sequential statements in the rewrite.
WITH{{| RECURSIVE}}
  q1 AS (FROM q2),
  q2 AS (FROM KeyValue)
FROM q1
|> EXTEND key*2 AS k2
|> FORK (
     |> SELECT key
    ), (
     |> SELECT k2
    )
--
ALTERNATION GROUP: <empty>
--
ERROR: Table not found: q2 [at 2:15]
  q1 AS (FROM q2),
              ^
--
ALTERNATION GROUP:  RECURSIVE
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="q2"
    | | +-with_subquery=
    | |   +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | +-WithEntry
    |   +-with_query_name="q1"
    |   +-with_subquery=
    |     +-WithRefScan(column_list=q2.[Key#3, Value#4], with_query_name="q2")
    +-query=
    | +-PipeForkScan
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7]
    |   |   +-expr_list=
    |   |   | +-k2#7 :=
    |   |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=q1.Key#5)
    |   |   |     +-Literal(type=INT64, value=2)
    |   |   +-input_scan=
    |   |     +-WithRefScan(column_list=q1.[Key#5, Value#6], with_query_name="q1")
    |   +-subpipeline_list=
    |     +-GeneralizedQuerySubpipeline
    |     | +-subpipeline=
    |     | | +-Subpipeline
    |     | |   +-scan=
    |     | |     +-ProjectScan
    |     | |       +-column_list=[q1.Key#5]
    |     | |       +-input_scan=
    |     | |         +-SubpipelineInputScan(column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7])
    |     | +-output_schema=
    |     |   +-OutputSchema
    |     |     +-output_column_list=
    |     |       +-q1.Key#5 AS key [INT64]
    |     +-GeneralizedQuerySubpipeline
    |       +-subpipeline=
    |       | +-Subpipeline
    |       |   +-scan=
    |       |     +-ProjectScan
    |       |       +-column_list=[$pipe_extend.k2#7]
    |       |       +-input_scan=
    |       |         +-SubpipelineInputScan(column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7])
    |       +-output_schema=
    |         +-OutputSchema
    |           +-output_column_list=
    |             +-$pipe_extend.k2#7 AS k2 [INT64]
    +-recursive=TRUE


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="q2"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="q1"
  |     +-with_subquery=
  |       +-WithRefScan(column_list=q2.[Key#3, Value#4], with_query_name="q2")
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7]
  |         +-expr_list=
  |         | +-k2#7 :=
  |         |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
  |         |     +-ColumnRef(type=INT64, column=q1.Key#5)
  |         |     +-Literal(type=INT64, value=2)
  |         +-input_scan=
  |           +-WithRefScan(column_list=q1.[Key#5, Value#6], with_query_name="q1")
  +-QueryStmt
  | +-output_column_list=
  | | +-q1.Key#5 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[q1.Key#5]
  |     +-input_scan=
  |       +-WithRefScan(column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-$pipe_extend.k2#7 AS k2 [INT64]
    +-query=
      +-ProjectScan
        +-column_list=[$pipe_extend.k2#7]
        +-input_scan=
          +-WithRefScan(column_list=[q1.Key#5, q1.Value#6, $pipe_extend.k2#7], with_query_name="$fork_cte_1")
==

# WITH RECURSIVE with a recursive CTE.  In the rewrite, the
# ResolvedCreateWithEntryStmt includes a ResolvedRecursiveScan.
WITH RECURSIVE
  q1 AS (SELECT key, cnt FROM q2),
  q2 AS (SELECT *, 1 cnt FROM q3
         UNION ALL
         SELECT key, value, cnt+1 FROM q2 WHERE cnt<10),
  q3 AS (FROM KeyValue)
FROM q1
|> EXTEND key*cnt AS kc
|> FORK (
     |> SELECT key
    ), (
     |> SELECT kc
    )
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="q3"
    | | +-with_subquery=
    | |   +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | +-WithEntry
    | | +-with_query_name="q2"
    | | +-with_subquery=
    | |   +-RecursiveScan
    | |     +-column_list=$union_all.[Key#6, Value#7, cnt#8]
    | |     +-op_type=UNION_ALL
    | |     +-non_recursive_term=
    | |     | +-SetOperationItem
    | |     |   +-scan=
    | |     |   | +-ProjectScan
    | |     |   |   +-column_list=[q3.Key#3, q3.Value#4, $union_all1.cnt#5]
    | |     |   |   +-expr_list=
    | |     |   |   | +-cnt#5 := Literal(type=INT64, value=1)
    | |     |   |   +-input_scan=
    | |     |   |     +-WithRefScan(column_list=q3.[Key#3, Value#4], with_query_name="q3")
    | |     |   +-output_column_list=[q3.Key#3, q3.Value#4, $union_all1.cnt#5]
    | |     +-recursive_term=
    | |       +-SetOperationItem
    | |         +-scan=
    | |         | +-ProjectScan
    | |         |   +-column_list=[q2.Key#9, q2.Value#10, $union_all2.$col3#12]
    | |         |   +-expr_list=
    | |         |   | +-$col3#12 :=
    | |         |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
    | |         |   |     +-ColumnRef(type=INT64, column=q2.cnt#11)
    | |         |   |     +-Literal(type=INT64, value=1)
    | |         |   +-input_scan=
    | |         |     +-FilterScan
    | |         |       +-column_list=q2.[Key#9, Value#10, cnt#11]
    | |         |       +-input_scan=
    | |         |       | +-RecursiveRefScan(column_list=q2.[Key#9, Value#10, cnt#11])
    | |         |       +-filter_expr=
    | |         |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    | |         |           +-ColumnRef(type=INT64, column=q2.cnt#11)
    | |         |           +-Literal(type=INT64, value=10)
    | |         +-output_column_list=[q2.Key#9, q2.Value#10, $union_all2.$col3#12]
    | +-WithEntry
    |   +-with_query_name="q1"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=q2.[Key#13, cnt#15]
    |       +-input_scan=
    |         +-WithRefScan(column_list=q2.[Key#13, Value#14, cnt#15], with_query_name="q2")
    +-query=
    | +-PipeForkScan
    |   +-input_scan=
    |   | +-ProjectScan
    |   |   +-column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18]
    |   |   +-expr_list=
    |   |   | +-kc#18 :=
    |   |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |   |   |     +-ColumnRef(type=INT64, column=q1.key#16)
    |   |   |     +-ColumnRef(type=INT64, column=q1.cnt#17)
    |   |   +-input_scan=
    |   |     +-WithRefScan(column_list=q1.[key#16, cnt#17], with_query_name="q1")
    |   +-subpipeline_list=
    |     +-GeneralizedQuerySubpipeline
    |     | +-subpipeline=
    |     | | +-Subpipeline
    |     | |   +-scan=
    |     | |     +-ProjectScan
    |     | |       +-column_list=[q1.key#16]
    |     | |       +-input_scan=
    |     | |         +-SubpipelineInputScan(column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18])
    |     | +-output_schema=
    |     |   +-OutputSchema
    |     |     +-output_column_list=
    |     |       +-q1.key#16 AS key [INT64]
    |     +-GeneralizedQuerySubpipeline
    |       +-subpipeline=
    |       | +-Subpipeline
    |       |   +-scan=
    |       |     +-ProjectScan
    |       |       +-column_list=[$pipe_extend.kc#18]
    |       |       +-input_scan=
    |       |         +-SubpipelineInputScan(column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18])
    |       +-output_schema=
    |         +-OutputSchema
    |           +-output_column_list=
    |             +-$pipe_extend.kc#18 AS kc [INT64]
    +-recursive=TRUE


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="q3"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="q2"
  |     +-with_subquery=
  |       +-RecursiveScan
  |         +-column_list=$union_all.[Key#6, Value#7, cnt#8]
  |         +-op_type=UNION_ALL
  |         +-non_recursive_term=
  |         | +-SetOperationItem
  |         |   +-scan=
  |         |   | +-ProjectScan
  |         |   |   +-column_list=[q3.Key#3, q3.Value#4, $union_all1.cnt#5]
  |         |   |   +-expr_list=
  |         |   |   | +-cnt#5 := Literal(type=INT64, value=1)
  |         |   |   +-input_scan=
  |         |   |     +-WithRefScan(column_list=q3.[Key#3, Value#4], with_query_name="q3")
  |         |   +-output_column_list=[q3.Key#3, q3.Value#4, $union_all1.cnt#5]
  |         +-recursive_term=
  |           +-SetOperationItem
  |             +-scan=
  |             | +-ProjectScan
  |             |   +-column_list=[q2.Key#9, q2.Value#10, $union_all2.$col3#12]
  |             |   +-expr_list=
  |             |   | +-$col3#12 :=
  |             |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  |             |   |     +-ColumnRef(type=INT64, column=q2.cnt#11)
  |             |   |     +-Literal(type=INT64, value=1)
  |             |   +-input_scan=
  |             |     +-FilterScan
  |             |       +-column_list=q2.[Key#9, Value#10, cnt#11]
  |             |       +-input_scan=
  |             |       | +-RecursiveRefScan(column_list=q2.[Key#9, Value#10, cnt#11])
  |             |       +-filter_expr=
  |             |         +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
  |             |           +-ColumnRef(type=INT64, column=q2.cnt#11)
  |             |           +-Literal(type=INT64, value=10)
  |             +-output_column_list=[q2.Key#9, q2.Value#10, $union_all2.$col3#12]
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="q1"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=q2.[Key#13, cnt#15]
  |         +-input_scan=
  |           +-WithRefScan(column_list=q2.[Key#13, Value#14, cnt#15], with_query_name="q2")
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18]
  |         +-expr_list=
  |         | +-kc#18 :=
  |         |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
  |         |     +-ColumnRef(type=INT64, column=q1.key#16)
  |         |     +-ColumnRef(type=INT64, column=q1.cnt#17)
  |         +-input_scan=
  |           +-WithRefScan(column_list=q1.[key#16, cnt#17], with_query_name="q1")
  +-QueryStmt
  | +-output_column_list=
  | | +-q1.key#16 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[q1.key#16]
  |     +-input_scan=
  |       +-WithRefScan(column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-$pipe_extend.kc#18 AS kc [INT64]
    +-query=
      +-ProjectScan
        +-column_list=[$pipe_extend.kc#18]
        +-input_scan=
          +-WithRefScan(column_list=[q1.key#16, q1.cnt#17, $pipe_extend.kc#18], with_query_name="$fork_cte_1")
==

# We have an outer CTE and also a inner CTE with the same name inside a FORK.
# This works.  The analyzer is renaming CTEs to globally unique names.
WITH cte AS (FROM KeyValue)
FROM cte AS t1
|> FORK (
    |> CROSS JOIN (
          WITH cte AS (select 1 x)
          FROM cte AS t2
        )
   )
--
GeneralizedQueryStmt
+-query=
  +-WithScan
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="cte"
    |   +-with_subquery=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-query=
      +-PipeForkScan
        +-input_scan=
        | +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="cte")
        +-subpipeline_list=
          +-GeneralizedQuerySubpipeline
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-JoinScan
            |       +-column_list=[cte.Key#3, cte.Value#4, cte_1.x#6]
            |       +-left_scan=
            |       | +-SubpipelineInputScan(column_list=cte.[Key#3, Value#4])
            |       +-right_scan=
            |         +-WithScan
            |           +-column_list=[cte_1.x#6]
            |           +-with_entry_list=
            |           | +-WithEntry
            |           |   +-with_query_name="cte_1"
            |           |   +-with_subquery=
            |           |     +-ProjectScan
            |           |       +-column_list=[cte.x#5]
            |           |       +-expr_list=
            |           |       | +-x#5 := Literal(type=INT64, value=1)
            |           |       +-input_scan=
            |           |         +-SingleRowScan
            |           +-query=
            |             +-WithRefScan(column_list=[cte_1.x#6], with_query_name="cte_1")
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-cte.Key#3 AS Key [INT64]
                  +-cte.Value#4 AS Value [STRING]
                  +-cte_1.x#6 AS x [INT64]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="cte"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="cte")
  +-QueryStmt
    +-output_column_list=
    | +-cte.Key#3 AS Key [INT64]
    | +-cte.Value#4 AS Value [STRING]
    | +-cte_1.x#6 AS x [INT64]
    +-query=
      +-JoinScan
        +-column_list=[cte.Key#3, cte.Value#4, cte_1.x#6]
        +-left_scan=
        | +-WithRefScan(column_list=cte.[Key#3, Value#4], with_query_name="$fork_cte_1")
        +-right_scan=
          +-WithScan
            +-column_list=[cte_1.x#6]
            +-with_entry_list=
            | +-WithEntry
            |   +-with_query_name="cte_1"
            |   +-with_subquery=
            |     +-ProjectScan
            |       +-column_list=[cte.x#5]
            |       +-expr_list=
            |       | +-x#5 := Literal(type=INT64, value=1)
            |       +-input_scan=
            |         +-SingleRowScan
            +-query=
              +-WithRefScan(column_list=[cte_1.x#6], with_query_name="cte_1")
==

# Nested FORKs.
# Note that the subpipeline with the nested FORK does not itself
# have an OutputSchema, since it ends with a terminal operator
# (the nested FORK).
# The rewrite has a second ResolvedCreateWithEntryStmt for the second FORK.
FROM KeyValue
|> FORK (
     |> SELECT value
   ), (
     |> EXTEND 10 ten
     |> FORK (
          |> SELECT key+ten k10
        ), (
          |> WHERE true
        )
   ), (
     |> SELECT key,key,key
   )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-ProjectScan
      | |       +-column_list=[KeyValue.Value#2]
      | |       +-input_scan=
      | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Value#2 AS value [STRING]
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      |   +-Subpipeline
      |     +-scan=
      |       +-PipeForkScan
      |         +-input_scan=
      |         | +-ProjectScan
      |         |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3]
      |         |   +-expr_list=
      |         |   | +-ten#3 := Literal(type=INT64, value=10)
      |         |   +-input_scan=
      |         |     +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      |         +-subpipeline_list=
      |           +-GeneralizedQuerySubpipeline
      |           | +-subpipeline=
      |           | | +-Subpipeline
      |           | |   +-scan=
      |           | |     +-ProjectScan
      |           | |       +-column_list=[$pipe_select.k10#4]
      |           | |       +-expr_list=
      |           | |       | +-k10#4 :=
      |           | |       |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
      |           | |       |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
      |           | |       |     +-ColumnRef(type=INT64, column=$pipe_extend.ten#3)
      |           | |       +-input_scan=
      |           | |         +-SubpipelineInputScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3])
      |           | +-output_schema=
      |           |   +-OutputSchema
      |           |     +-output_column_list=
      |           |       +-$pipe_select.k10#4 AS k10 [INT64]
      |           +-GeneralizedQuerySubpipeline
      |             +-subpipeline=
      |             | +-Subpipeline
      |             |   +-scan=
      |             |     +-FilterScan
      |             |       +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3]
      |             |       +-input_scan=
      |             |       | +-SubpipelineInputScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3])
      |             |       +-filter_expr=
      |             |         +-Literal(type=BOOL, value=true)
      |             +-output_schema=
      |               +-OutputSchema
      |                 +-output_column_list=
      |                   +-KeyValue.Key#1 AS Key [INT64]
      |                   +-KeyValue.Value#2 AS Value [STRING]
      |                   +-$pipe_extend.ten#3 AS ten [INT64]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-ProjectScan
        |       +-column_list=KeyValue.[Key#1, Key#1, Key#1]
        |       +-input_scan=
        |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS key [INT64]
              +-KeyValue.Key#1 AS key [INT64]
              +-KeyValue.Key#1 AS key [INT64]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Value#2 AS value [STRING]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[KeyValue.Value#2]
  |     +-input_scan=
  |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_2"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3]
  |         +-expr_list=
  |         | +-ten#3 := Literal(type=INT64, value=10)
  |         +-input_scan=
  |           +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
  | +-output_column_list=
  | | +-$pipe_select.k10#4 AS k10 [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[$pipe_select.k10#4]
  |     +-expr_list=
  |     | +-k10#4 :=
  |     |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
  |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  |     |     +-ColumnRef(type=INT64, column=$pipe_extend.ten#3)
  |     +-input_scan=
  |       +-WithRefScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3], with_query_name="$fork_cte_2")
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS Key [INT64]
  | | +-KeyValue.Value#2 AS Value [STRING]
  | | +-$pipe_extend.ten#3 AS ten [INT64]
  | +-query=
  |   +-FilterScan
  |     +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3]
  |     +-input_scan=
  |     | +-WithRefScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.ten#3], with_query_name="$fork_cte_2")
  |     +-filter_expr=
  |       +-Literal(type=BOOL, value=true)
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS key [INT64]
    | +-KeyValue.Key#1 AS key [INT64]
    | +-KeyValue.Key#1 AS key [INT64]
    +-query=
      +-ProjectScan
        +-column_list=KeyValue.[Key#1, Key#1, Key#1]
        +-input_scan=
          +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# is_value_table propagates to subpipeline OutputSchemas.
FROM KeyValue
|> FORK
     ( |> SELECT key ),
     ( |> SELECT AS VALUE value )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-ProjectScan
      | |       +-column_list=[KeyValue.Key#1]
      | |       +-input_scan=
      | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Key#1 AS key [INT64]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-ProjectScan
        |       +-column_list=[KeyValue.Value#2]
        |       +-input_scan=
        |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
            | +-KeyValue.Value#2 AS `$value_column` [STRING]
            +-is_value_table=TRUE


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[KeyValue.Key#1]
  |     +-input_scan=
  |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Value#2 AS `$value_column` [STRING]
    +-is_value_table=TRUE
    +-query=
      +-ProjectScan
        +-column_list=[KeyValue.Value#2]
        +-input_scan=
          +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# Ordering is represented by `is_ordered` on the outermost scan
# inside each subpipeline.
FROM KeyValue
|> FORK
     ( ),
     ( |> ORDER BY key )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Key#1 AS Key [INT64]
      |       +-KeyValue.Value#2 AS Value [STRING]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-OrderByScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-is_ordered=TRUE
        |       +-input_scan=
        |       | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |       +-order_by_item_list=
        |         +-OrderByItem
        |           +-column_ref=
        |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS Key [INT64]
  | | +-KeyValue.Value#2 AS Value [STRING]
  | +-query=
  |   +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    +-query=
      +-OrderByScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-is_ordered=TRUE
        +-input_scan=
        | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
        +-order_by_item_list=
          +-OrderByItem
            +-column_ref=
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# When input is ordered, subpipelines still don't get is_ordered.
FROM KeyValue
|> ORDER BY key
|> FORK
     ( |> LIMIT 1 )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-OrderByScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-is_ordered=TRUE
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-order_by_item_list=
    |     +-OrderByItem
    |       +-column_ref=
    |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-LimitOffsetScan
        |       +-column_list=KeyValue.[Key#1, Value#2]
        |       +-input_scan=
        |       | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |       +-limit=
        |         +-Literal(type=INT64, value=1)
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS Key [INT64]
              +-KeyValue.Value#2 AS Value [STRING]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-OrderByScan
  |         +-column_list=KeyValue.[Key#1, Value#2]
  |         +-is_ordered=TRUE
  |         +-input_scan=
  |         | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  |         +-order_by_item_list=
  |           +-OrderByItem
  |             +-column_ref=
  |               +-ColumnRef(type=INT64, column=KeyValue.Key#1)
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS Key [INT64]
    | +-KeyValue.Value#2 AS Value [STRING]
    +-query=
      +-LimitOffsetScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
        +-limit=
          +-Literal(type=INT64, value=1)
==

# With FORK in IF, we only get a GeneralizedQueryStmt if the IF is actually
# taken and runs a FORK.
# Literal replacement doesn't work for constants in pipe IF.
[no_enable_literal_replacement]
FROM KeyValue
|> IF {{true|false}} THEN (
     |> FORK ( |> SELECT key )
   )
--
ALTERNATION GROUP: true
--
GeneralizedQueryStmt
+-query=
  +-PipeIfScan
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="(\n     |> FORK ( |> SELECT key )\n   )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-PipeForkScan
                +-input_scan=
                | +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
                +-subpipeline_list=
                  +-GeneralizedQuerySubpipeline
                    +-subpipeline=
                    | +-Subpipeline
                    |   +-scan=
                    |     +-ProjectScan
                    |       +-column_list=[KeyValue.Key#1]
                    |       +-input_scan=
                    |         +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
                    +-output_schema=
                      +-OutputSchema
                        +-output_column_list=
                          +-KeyValue.Key#1 AS key [INT64]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS key [INT64]
    +-query=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1]
        +-input_scan=
          +-WithRefScan(column_list=[KeyValue.Key#1], with_query_name="$fork_cte_1")
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=-1
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=false)
        +-subpipeline_sql="(\n     |> FORK ( |> SELECT key )\n   )"


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

# IF is terminal if it hit the case with FORK. Then more operators cannot follow.
[no_enable_literal_replacement]
FROM KeyValue
|> IF {{true|false}} THEN (
     |> FORK ( |> WHERE true )
   )
|> WHERE false
--
ALTERNATION GROUP: true
--
ERROR: Additional pipe operators cannot follow the terminal pipe operator IF (with terminal operators inside) [at 5:1]
|> WHERE false
^
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-selected_case=-1
    |   +-if_case_list=
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=false)
    |       +-subpipeline_sql="(\n     |> FORK ( |> WHERE true )\n   )"
    +-filter_expr=
      +-Literal(type=BOOL, value=false)


[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-filter_expr=
      +-Literal(type=BOOL, value=false)
==

# FORK with other terminal operators inside
FROM KeyValue
|> FORK (
    |> EXPORT DATA
  ), (
    |> SELECT key
  ), (
    |> SELECT value
    |> CREATE TABLE t2
  )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      |   +-Subpipeline
      |     +-scan=
      |       +-PipeExportDataScan
      |         +-export_data_stmt=
      |           +-ExportDataStmt
      |             +-output_column_list=
      |             | +-KeyValue.Key#1 AS Key [INT64]
      |             | +-KeyValue.Value#2 AS Value [STRING]
      |             +-query=
      |               +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      +-GeneralizedQuerySubpipeline
      | +-subpipeline=
      | | +-Subpipeline
      | |   +-scan=
      | |     +-ProjectScan
      | |       +-column_list=[KeyValue.Key#1]
      | |       +-input_scan=
      | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
      | +-output_schema=
      |   +-OutputSchema
      |     +-output_column_list=
      |       +-KeyValue.Key#1 AS key [INT64]
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-PipeCreateTableScan
                +-create_table_as_select_stmt=
                  +-CreateTableAsSelectStmt
                    +-name_path=t2
                    +-column_definition_list=
                    | +-ColumnDefinition(name="value", type=STRING, column=t2.value#3)
                    +-output_column_list=
                    | +-KeyValue.Value#2 AS value [STRING]
                    +-query=
                      +-ProjectScan
                        +-column_list=[KeyValue.Value#2]
                        +-input_scan=
                          +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-ExportDataStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS Key [INT64]
  | | +-KeyValue.Value#2 AS Value [STRING]
  | +-query=
  |   +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-QueryStmt
  | +-output_column_list=
  | | +-KeyValue.Key#1 AS key [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[KeyValue.Key#1]
  |     +-input_scan=
  |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
  +-CreateTableAsSelectStmt
    +-name_path=t2
    +-column_definition_list=
    | +-ColumnDefinition(name="value", type=STRING, column=t2.value#3)
    +-output_column_list=
    | +-KeyValue.Value#2 AS value [STRING]
    +-query=
      +-ProjectScan
        +-column_list=[KeyValue.Value#2]
        +-input_scan=
          +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# FORK with EXPLAIN
EXPLAIN
FROM KeyValue
|> FORK (
    |> SELECT key
  ), (
    |> SELECT value
  )
--
ExplainStmt
+-statement=
  +-GeneralizedQueryStmt
    +-query=
      +-PipeForkScan
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-subpipeline_list=
          +-GeneralizedQuerySubpipeline
          | +-subpipeline=
          | | +-Subpipeline
          | |   +-scan=
          | |     +-ProjectScan
          | |       +-column_list=[KeyValue.Key#1]
          | |       +-input_scan=
          | |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
          | +-output_schema=
          |   +-OutputSchema
          |     +-output_column_list=
          |       +-KeyValue.Key#1 AS key [INT64]
          +-GeneralizedQuerySubpipeline
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-ProjectScan
            |       +-column_list=[KeyValue.Value#2]
            |       +-input_scan=
            |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-KeyValue.Value#2 AS value [STRING]


[REWRITTEN AST]
ExplainStmt
+-statement=
  +-MultiStmt
    +-statement_list=
      +-CreateWithEntryStmt
      | +-with_entry=
      |   +-WithEntry
      |     +-with_query_name="$fork_cte_1"
      |     +-with_subquery=
      |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
      +-QueryStmt
      | +-output_column_list=
      | | +-KeyValue.Key#1 AS key [INT64]
      | +-query=
      |   +-ProjectScan
      |     +-column_list=[KeyValue.Key#1]
      |     +-input_scan=
      |       +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
      +-QueryStmt
        +-output_column_list=
        | +-KeyValue.Value#2 AS value [STRING]
        +-query=
          +-ProjectScan
            +-column_list=[KeyValue.Value#2]
            +-input_scan=
              +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
==

# FORK with LOG inside, containing another nested subpipeline.
# This exercises nested subpiplines in the rewriter.
from KeyValue
|> FORK (
     |> LOG ( |> SELECT value )
     |> SELECT key
    )
--
GeneralizedQueryStmt
+-query=
  +-PipeForkScan
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-subpipeline_list=
      +-GeneralizedQuerySubpipeline
        +-subpipeline=
        | +-Subpipeline
        |   +-scan=
        |     +-ProjectScan
        |       +-column_list=[KeyValue.Key#1]
        |       +-input_scan=
        |         +-LogScan
        |           +-column_list=KeyValue.[Key#1, Value#2]
        |           +-input_scan=
        |           | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |           +-subpipeline=
        |           | +-Subpipeline
        |           |   +-scan=
        |           |     +-ProjectScan
        |           |       +-column_list=[KeyValue.Value#2]
        |           |       +-input_scan=
        |           |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |           +-output_schema=
        |             +-OutputSchema
        |               +-output_column_list=
        |                 +-KeyValue.Value#2 AS value [STRING]
        +-output_schema=
          +-OutputSchema
            +-output_column_list=
              +-KeyValue.Key#1 AS key [INT64]


[REWRITTEN AST]
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
  +-QueryStmt
    +-output_column_list=
    | +-KeyValue.Key#1 AS key [INT64]
    +-query=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1]
        +-input_scan=
          +-LogScan
            +-column_list=KeyValue.[Key#1, Value#2]
            +-input_scan=
            | +-WithRefScan(column_list=KeyValue.[Key#1, Value#2], with_query_name="$fork_cte_1")
            +-subpipeline=
            | +-Subpipeline
            |   +-scan=
            |     +-ProjectScan
            |       +-column_list=[KeyValue.Value#2]
            |       +-input_scan=
            |         +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
            +-output_schema=
              +-OutputSchema
                +-output_column_list=
                  +-KeyValue.Value#2 AS value [STRING]
