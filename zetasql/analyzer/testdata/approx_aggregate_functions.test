[default language_features=NONE]
select approx_count_distinct(key), approx_quantiles(key, 100) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [INT64]
| +-$aggregate.$agg2#4 AS `$col2` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#3, $agg2#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#3, $agg2#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
          | +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(INT64) -> INT64)
          |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$agg2#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=100)
==

select approx_count_distinct(KitchenSink) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:30]
select approx_count_distinct(KitchenSink) from TestTable
                             ^
==

select approx_count_distinct(TestEnum) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ENUM<zetasql_test__.TestEnum>) -> INT64)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
==

# A literal ARRAY of groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_count_distinct([10]) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<INT64> does not [at 1:30]
select approx_count_distinct([10]) from TestTable
                             ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ARRAY<INT64>) -> INT64)
              +-Literal(type=ARRAY<INT64>, value=[10])
==

# A non-literal ARRAY of groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_count_distinct([string, 'a']) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<STRING> does not [at 1:30]
select approx_count_distinct([string, 'a']) from SimpleTypes
                             ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(ARRAY<STRING>) -> INT64)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
                +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
                +-Literal(type=STRING, value="a")
==

# ARRAY of non-groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_count_distinct([KitchenSink]) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type ARRAY<zetasql_test__.KitchenSinkPB> does not [at 1:30]
select approx_count_distinct([KitchenSink]) from TestTable
                             ^
==

# A literal STRUCT with groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_count_distinct((1,2)) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, INT64> does not [at 1:30]
select approx_count_distinct((1,2)) from TestTable
                             ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(STRUCT<INT64, INT64>) -> INT64)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
==

# A non-literal STRUCT with groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_count_distinct((1,string)) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, STRING> does not [at 1:30]
select approx_count_distinct((1,string)) from SimpleTypes
                             ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_count_distinct(STRUCT<INT64, STRING>) -> INT64)
              +-MakeStruct
                +-type=STRUCT<INT64, STRING>
                +-field_list=
                  +-Literal(type=INT64, value=1)
                  +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
==

# STRUCT with non-groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_count_distinct((1,2, KitchenSink)) from TestTable
--
ERROR: The argument to APPROX_COUNT_DISTINCT must support grouping; Type STRUCT<INT64, INT64, zetasql_test__.KitchenSinkPB> does not [at 1:30]
select approx_count_distinct((1,2, KitchenSink)) from TestTable
                             ^
==

select approx_quantiles(key, @test_param_int64) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Parameter(type=INT64, name="test_param_int64")
==

# Script variables should work with approx_quantiles.
select approx_quantiles(key, int_variable_foo)
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Constant(int_variable_foo, type=INT32, value=4)

==

# Cast of a param still counts as a constant argument.
select approx_quantiles(key, cast(cast(@test_param_uint32 as string) as int64))
from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(STRING -> INT64)
                +-Cast(UINT32 -> STRING)
                  +-Parameter(type=UINT32, name="test_param_uint32")
==

# During unparsing, this parameter has a widening cast to int64 added.
# We still want this to pass parameter checks after unparsing.
select approx_quantiles(key, @test_param_int32) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

select approx_quantiles(KitchenSink, 10) from TestTable
--
ERROR: Argument 1 to APPROX_QUANTILES must support ordering; Type zetasql_test__.KitchenSinkPB does not [at 1:25]
select approx_quantiles(KitchenSink, 10) from TestTable
                        ^
==

select approx_quantiles(key, NULL) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be non-NULL [at 1:30]
select approx_quantiles(key, NULL) from KeyValue
                             ^
==

select approx_quantiles(key, 0) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be at least 1 [at 1:30]
select approx_quantiles(key, 0) from KeyValue
                             ^
==

select approx_quantiles(key, -1) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be at least 1 [at 1:30]
select approx_quantiles(key, -1) from KeyValue
                             ^
==

select approx_quantiles(key, 1+0) from KeyValue
--
ERROR: Argument 2 to APPROX_QUANTILES must be a literal or query parameter [at 1:30]
select approx_quantiles(key, 1+0) from KeyValue
                             ^
==

select approx_quantiles(key, cast(1 as int32)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

select approx_quantiles(key, cast(@test_param_int64 as int32)) from KeyValue
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Cast(INT32 -> INT64)
                +-Cast(INT64 -> INT32)
                  +-Parameter(type=INT64, name="test_param_int64")
==

# IGNORE NULLS are allowed.
[language_features=NONE,{{+NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select approx_quantiles(key, 10 ignore nulls) from KeyValue
--
ALTERNATION GROUP: +NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=10)
              +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select approx_quantiles(key, 10 ignore nulls) from KeyValue
       ^
==

# RESPECT NULLS are allowed.
[language_features=NONE,{{+NULL_HANDLING_MODIFIER_IN_AGGREGATE|}}]
select approx_quantiles(key, 10 respect nulls) from KeyValue
--
ALTERNATION GROUP: +NULL_HANDLING_MODIFIER_IN_AGGREGATE
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#3 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#3]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#3 :=
            +-AggregateFunctionCall(ZetaSQL:approx_quantiles(INT64, INT64) -> ARRAY<INT64>)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=10)
              +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in aggregate functions are not supported [at 1:8]
select approx_quantiles(key, 10 respect nulls) from KeyValue
       ^
==

select approx_quantiles(key, @test_param_string) from KeyValue
--
ERROR: No matching signature for aggregate function APPROX_QUANTILES
  Argument types: INT64, STRING
  Signature: APPROX_QUANTILES(T1, INT64)
    Argument 2: Unable to coerce type STRING to expected type INT64 [at 1:8]
select approx_quantiles(key, @test_param_string) from KeyValue
       ^
==

select approx_quantiles() from KeyValue
--
ERROR: No matching signature for aggregate function APPROX_QUANTILES with no arguments
  Signature: APPROX_QUANTILES(T1, INT64)
    Signature requires at least 2 arguments, found 0 arguments [at 1:8]
select approx_quantiles() from KeyValue
       ^
==

select approx_quantiles(key) from KeyValue
--
ERROR: No matching signature for aggregate function APPROX_QUANTILES
  Argument types: INT64
  Signature: APPROX_QUANTILES(T1, INT64)
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select approx_quantiles(key) from KeyValue
       ^
==

select approx_top_count(int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value INT64, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(INT64, INT64) -> ARRAY<STRUCT<value INT64, count INT64>>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

select approx_top_count(string, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value STRING, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRING, INT64) -> ARRAY<STRUCT<value STRING, count INT64>>)
              +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_count(string, null) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be non-NULL [at 1:33]
select approx_top_count(string, null) from SimpleTypes
                                ^
==

select approx_top_count(string, 0) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be at least 1 [at 1:33]
select approx_top_count(string, 0) from SimpleTypes
                                ^
==

select approx_top_count(string, -1) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be at least 1 [at 1:33]
select approx_top_count(string, -1) from SimpleTypes
                                ^
==

select approx_top_count(string, 1+1) from SimpleTypes
--
ERROR: Argument 2 to APPROX_TOP_COUNT must be a literal or query parameter [at 1:33]
select approx_top_count(string, 1+1) from SimpleTypes
                                ^
==

select approx_top_count(string, 'abc') from SimpleTypes
--
ERROR: No matching signature for aggregate function APPROX_TOP_COUNT
  Argument types: STRING, STRING
  Signature: APPROX_TOP_COUNT(T1, INT64)
    Argument 2: Unable to coerce type STRING to expected type INT64 [at 1:8]
select approx_top_count(string, 'abc') from SimpleTypes
       ^
==

select approx_top_count(string) from SimpleTypes
--
ERROR: No matching signature for aggregate function APPROX_TOP_COUNT
  Argument types: STRING
  Signature: APPROX_TOP_COUNT(T1, INT64)
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select approx_top_count(string) from SimpleTypes
       ^
==

select approx_top_count() from SimpleTypes
--
ERROR: No matching signature for aggregate function APPROX_TOP_COUNT with no arguments
  Signature: APPROX_TOP_COUNT(T1, INT64)
    Signature requires at least 2 arguments, found 0 arguments [at 1:8]
select approx_top_count() from SimpleTypes
       ^
==

select approx_top_count(string, 10, 11) from SimpleTypes
--
ERROR: No matching signature for aggregate function APPROX_TOP_COUNT
  Argument types: STRING, INT64, INT64
  Signature: APPROX_TOP_COUNT(T1, INT64)
    Signature accepts at most 2 arguments, found 3 arguments [at 1:8]
select approx_top_count(string, 10, 11) from SimpleTypes
       ^
==

select approx_top_count(KitchenSink, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:25]
select approx_top_count(KitchenSink, 10) from TestTable
                        ^
==

select approx_top_count(TestEnum, 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.TestEnum#2], table=TestTable, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ENUM<zetasql_test__.TestEnum>, INT64) -> ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, count INT64>>)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
              +-Literal(type=INT64, value=10)
==

# A literal ARRAY with groupable elements
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_count([1,2], 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<INT64> does not [at 1:25]
select approx_top_count([1,2], 10) from TestTable
                        ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ARRAY<INT64>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ARRAY<INT64>, INT64) -> ARRAY<STRUCT<value ARRAY<INT64>, count INT64>>)
              +-Literal(type=ARRAY<INT64>, value=[1, 2])
              +-Literal(type=INT64, value=10)
==

# A non-literal ARRAY with groupable elements
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_count(['a',string], 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<STRING> does not [at 1:25]
select approx_top_count(['a',string], 10) from SimpleTypes
                        ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value ARRAY<STRING>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(ARRAY<STRING>, INT64) -> ARRAY<STRUCT<value ARRAY<STRING>, count INT64>>)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
              | +-Literal(type=STRING, value="a")
              | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=INT64, value=10)
==

# An ARRAY with non-groupable elements
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_count([KitchenSink], 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type ARRAY<zetasql_test__.KitchenSinkPB> does not [at 1:25]
select approx_top_count([KitchenSink], 10) from TestTable
                        ^
==

# A literal STRUCT with groupable fields
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_count((1,2), 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, INT64> does not [at 1:25]
select approx_top_count((1,2), 10) from TestTable
                        ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, INT64>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRUCT<INT64, INT64>, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, INT64>, count INT64>>)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
              +-Literal(type=INT64, value=10)
==

# A non-literal STRUCT with groupable fields
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_count((1,string), 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, STRING> does not [at 1:25]
select approx_top_count((1,string), 10) from SimpleTypes
                        ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, STRING>, count INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.string#5], table=SimpleTypes, column_index_list=[4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_count(STRUCT<INT64, STRING>, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, STRING>, count INT64>>)
              +-MakeStruct
              | +-type=STRUCT<INT64, STRING>
              | +-field_list=
              |   +-Literal(type=INT64, value=1)
              |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-Literal(type=INT64, value=10)
==

# A STRUCT with non-groupable fields
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_count((1,KitchenSink), 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_COUNT must support grouping; Type STRUCT<INT64, zetasql_test__.KitchenSinkPB> does not [at 1:25]
select approx_top_count((1,KitchenSink), 10) from TestTable
                        ^
==

select approx_top_sum(int64, int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value INT64, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=[SimpleTypes.int64#2], table=SimpleTypes, column_index_list=[1])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT64, INT64, INT64) -> ARRAY<STRUCT<value INT64, sum INT64>>)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

select approx_top_sum(bytes, double, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value BYTES, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[bytes#6, double#9], table=SimpleTypes, column_index_list=[5, 8])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(BYTES, DOUBLE, INT64) -> ARRAY<STRUCT<value BYTES, sum DOUBLE>>)
              +-ColumnRef(type=BYTES, column=SimpleTypes.bytes#6)
              +-ColumnRef(type=DOUBLE, column=SimpleTypes.double#9)
              +-Literal(type=INT64, value=10)
==

select approx_top_sum(TestEnum, KitchenSink.double_val, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=TestTable.[TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[1, 2])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ENUM<zetasql_test__.TestEnum>, DOUBLE, INT64) -> ARRAY<STRUCT<value ENUM<zetasql_test__.TestEnum>, sum DOUBLE>>)
              +-ColumnRef(type=ENUM<zetasql_test__.TestEnum>, column=TestTable.TestEnum#2)
              +-GetProtoField
              | +-type=DOUBLE
              | +-expr=
              | | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
              | +-field_descriptor=double_val
              | +-default_value=0
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(null, 1.6, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT64, sum DOUBLE>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(table=TestTable)
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT64, DOUBLE, INT64) -> ARRAY<STRUCT<value INT64, sum DOUBLE>>)
              +-Literal(type=INT64, value=NULL)
              +-Literal(type=DOUBLE, value=1.6)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(key, null, @test_param_int64) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT32, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, INT64, INT64) -> ARRAY<STRUCT<value INT32, sum INT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=NULL)
              +-Parameter(type=INT64, name="test_param_int64")
==

select approx_top_sum(key, 1.6, null) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be non-NULL [at 1:33]
select approx_top_sum(key, 1.6, null) from TestTable
                                ^
==

select approx_top_sum(key, 1.5, 0) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be at least 1 [at 1:33]
select approx_top_sum(key, 1.5, 0) from TestTable
                                ^
==

select approx_top_sum(key, 1.4, -1) from TestTable
--
ERROR: Argument 3 to APPROX_TOP_SUM must be at least 1 [at 1:33]
select approx_top_sum(key, 1.4, -1) from TestTable
                                ^
==

select approx_top_sum(KitchenSink, key, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type zetasql_test__.KitchenSinkPB does not [at 1:23]
select approx_top_sum(KitchenSink, key, 10) from TestTable
                      ^
==

# A literal ARRAY with groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_sum([1], key, 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type ARRAY<INT64> does not [at 1:23]
select approx_top_sum([1], key, 10) from TestTable
                      ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value ARRAY<INT64>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ARRAY<INT64>, INT64, INT64) -> ARRAY<STRUCT<value ARRAY<INT64>, sum INT64>>)
              +-Literal(type=ARRAY<INT64>, value=[1])
              +-Cast(INT32 -> INT64)
              | +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=10)
==

# A non-literal ARRAY with groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_sum(['a', string], int64, 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type ARRAY<STRING> does not [at 1:23]
select approx_top_sum(['a', string], int64, 10) from SimpleTypes
                      ^
--
ALTERNATION GROUP: +GROUP_BY_ARRAY
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value ARRAY<STRING>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(ARRAY<STRING>, INT64, INT64) -> ARRAY<STRUCT<value ARRAY<STRING>, sum INT64>>)
              +-FunctionCall(ZetaSQL:$make_array(repeated(2) STRING) -> ARRAY<STRING>)
              | +-Literal(type=STRING, value="a")
              | +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

# An ARRAY with non-groupable elements.
[language_features=NONE,{{|+GROUP_BY_ARRAY}}]
select approx_top_sum([KitchenSink], int64, 10) from TestTable
--
ERROR: Unrecognized name: int64 [at 1:38]
select approx_top_sum([KitchenSink], int64, 10) from TestTable
                                     ^
==

# A literal STRUCT with groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_sum((1,2), key, 10) from TestTable
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, INT64> does not [at 1:23]
select approx_top_sum((1,2), key, 10) from TestTable
                      ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, INT64>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(STRUCT<INT64, INT64>, INT64, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, INT64>, sum INT64>>)
              +-Literal(type=STRUCT<INT64, INT64>, value={1, 2})
              +-Cast(INT32 -> INT64)
              | +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=10)
==

# A non-literal STRUCT with groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_sum((1, string), int64, 10) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, STRING> does not [at 1:23]
select approx_top_sum((1, string), int64, 10) from SimpleTypes
                      ^
--
ALTERNATION GROUP: +GROUP_BY_STRUCT
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<STRUCT<value STRUCT<INT64, STRING>, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(STRUCT<INT64, STRING>, INT64, INT64) -> ARRAY<STRUCT<value STRUCT<INT64, STRING>, sum INT64>>)
              +-MakeStruct
              | +-type=STRUCT<INT64, STRING>
              | +-field_list=
              |   +-Literal(type=INT64, value=1)
              |   +-ColumnRef(type=STRING, column=SimpleTypes.string#5)
              +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
              +-Literal(type=INT64, value=10)
==

# A STRUCT with non-groupable fields.
[language_features=NONE,{{|+GROUP_BY_STRUCT}}]
select approx_top_sum((1, KitchenSink), key, 10) from TestTable
--
ERROR: Argument 1 to APPROX_TOP_SUM must support grouping; Type STRUCT<INT64, zetasql_test__.KitchenSinkPB> does not [at 1:23]
select approx_top_sum((1, KitchenSink), key, 10) from TestTable
                      ^
==

select approx_top_sum(key, 'abc', 10) from TestTable
--
ERROR: No matching signature for aggregate function APPROX_TOP_SUM
  Argument types: INT32, STRING, INT64
  Signature: APPROX_TOP_SUM(T1, INT64, INT64)
    Argument 2: Unable to coerce type STRING to expected type INT64
  Signature: APPROX_TOP_SUM(T1, UINT64, INT64)
    Argument 2: Unable to coerce type STRING to expected type UINT64
  Signature: APPROX_TOP_SUM(T1, DOUBLE, INT64)
    Argument 2: Unable to coerce type STRING to expected type DOUBLE [at 1:8]
select approx_top_sum(key, 'abc', 10) from TestTable
       ^
==

select approx_top_sum(key, cast(5 as int32), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [ARRAY<STRUCT<value INT32, sum INT64>>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#4]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#4]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, INT64, INT64) -> ARRAY<STRUCT<value INT32, sum INT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=INT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

select sum(cast(5 as uint64)), approx_top_sum(key, cast(5 as uint64), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [UINT64]
| +-$aggregate.$agg2#5 AS `$col2` [ARRAY<STRUCT<value INT32, sum UINT64>>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
          |   +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
          +-$agg2#5 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, UINT64, INT64) -> ARRAY<STRUCT<value INT32, sum UINT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

# UINT32 widens to UINT64, not INT64.
select sum(cast(5 as uint32)), approx_top_sum(key, cast(5 as uint32), 10) from TestTable
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#4 AS `$col1` [UINT64]
| +-$aggregate.$agg2#5 AS `$col2` [ARRAY<STRUCT<value INT32, sum UINT64>>]
+-query=
  +-ProjectScan
    +-column_list=$aggregate.[$agg1#4, $agg2#5]
    +-input_scan=
      +-AggregateScan
        +-column_list=$aggregate.[$agg1#4, $agg2#5]
        +-input_scan=
        | +-TableScan(column_list=[TestTable.key#1], table=TestTable, column_index_list=[0])
        +-aggregate_list=
          +-$agg1#4 :=
          | +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
          |   +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
          +-$agg2#5 :=
            +-AggregateFunctionCall(ZetaSQL:approx_top_sum(INT32, UINT64, INT64) -> ARRAY<STRUCT<value INT32, sum UINT64>>)
              +-ColumnRef(type=INT32, column=TestTable.key#1)
              +-Literal(type=UINT64, value=5, has_explicit_type=TRUE)
              +-Literal(type=INT64, value=10)
==

select hll_count.merge(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.merge(BYTES) -> INT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select hll_count.extract(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:hll_count.extract(BYTES) -> INT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select hll_count.init(@test_param_int64, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=10)
==

select hll_count.init(@test_param_int64, 24) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=24)
==

select hll_count.init(@test_param_int64, @test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Parameter(type=INT64, name="test_param_int64")
==

select hll_count.init(@test_param_int64, key) from KeyValue
--
ERROR: Argument 2 to HLL_COUNT.INIT must be a literal or query parameter [at 1:42]
select hll_count.init(@test_param_int64, key) from KeyValue
                                         ^
==

select hll_count.init(@test_param_int64, null) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be non-NULL [at 1:42]
select hll_count.init(@test_param_int64, null) from SimpleTypes
                                         ^
==

select hll_count.init(@test_param_int64, 9) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 1:42]
select hll_count.init(@test_param_int64, 9) from SimpleTypes
                                         ^
==

# Value range checking should happen even if we start from an int32
# and have to widen to int64.
select hll_count.init(@test_param_int64, cast(12 as int32)),
       hll_count.init(@test_param_int64, cast(9 as int32))
from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 2:42]
       hll_count.init(@test_param_int64, cast(9 as int32))
                                         ^
==

select hll_count.init(@test_param_int64, 25) from SimpleTypes
--
ERROR: Argument 2 to HLL_COUNT.INIT must be between 10 and 24 [at 1:42]
select hll_count.init(@test_param_int64, 25) from SimpleTypes
                                         ^
==

select hll_count.init(@test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
==

# INT32 widens to INT64
select hll_count.init(@test_param_int32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(INT64, optional(0) INT64) -> BYTES)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

select hll_count.init(@test_param_uint64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
==

# UINT32 widens to UINT64
select hll_count.init(@test_param_uint32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(UINT64, optional(0) INT64) -> BYTES)
              +-Cast(UINT32 -> UINT64)
                +-Parameter(type=UINT32, name="test_param_uint32")
==

select hll_count.init(@test_param_string) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(STRING, optional(0) INT64) -> BYTES)
              +-Parameter(type=STRING, name="test_param_string")
==

select hll_count.init(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.init(BYTES, optional(0) INT64) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

select hll_count.init(@test_param_proto) from SimpleTypes
--
ERROR: No matching signature for aggregate function HLL_COUNT.INIT
  Argument types: zetasql_test__.KitchenSinkPB
  Signature: HLL_COUNT.INIT(INT64, [INT64])
    Argument 1: Unable to coerce type zetasql_test__.KitchenSinkPB to expected type INT64
  Signature: HLL_COUNT.INIT(UINT64, [INT64])
    Argument 1: Unable to coerce type zetasql_test__.KitchenSinkPB to expected type UINT64
  Signature: HLL_COUNT.INIT(STRING, [INT64])
    Argument 1: Unable to coerce type zetasql_test__.KitchenSinkPB to expected type STRING
  Signature: HLL_COUNT.INIT(BYTES, [INT64])
    Argument 1: Unable to coerce type zetasql_test__.KitchenSinkPB to expected type BYTES [at 1:8]
select hll_count.init(@test_param_proto) from SimpleTypes
       ^
==

select hll_count.merge_partial(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:hll_count.merge_partial(BYTES) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

[product_mode={{|internal|external}}]
select kll_quantiles.init_int64(@test_param_int64) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
==

[product_mode={{|internal|external}}]
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_WEIGHTS]
select kll_quantiles.init_int64(@test_param_int64, 10, weight => NULL ) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=10)
              +-Literal(type=INT64, value=NULL)
==

[product_mode={{|internal|external}}]
select kll_quantiles.init_uint64(@test_param_uint64) from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.init_uint64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64) from SimpleTypes
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.init_double(@test_param_double) from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(0) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
--
ALTERNATION GROUPS:
    external
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.init_double [at 1:8]
select kll_quantiles.init_double(@test_param_double) from SimpleTypes
       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(0) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.init_float64(@test_param_double) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.init_float64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_float64(@test_param_double) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(0) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
==

select kll_quantiles.init_int64(@test_param_int64, 100) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=100)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.init_double(@test_param_double, 10000) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=10000)
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=10000)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.init_float64(@test_param_double, 10000) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.init_float64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_float64(@test_param_double, 10000) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=10000)
==

select kll_quantiles.init_int64(@test_param_int64, 1) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=INT64, name="test_param_int64")
              +-Literal(type=INT64, value=1)
==

select kll_quantiles.init_uint64(@test_param_uint64, 0) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=0)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.init_double(@test_param_double, @test_param_int64)
from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Parameter(type=INT64, name="test_param_int64")
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(1) INT64) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Parameter(type=INT64, name="test_param_int64")
==

select kll_quantiles.init_int64(@test_param_int64, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_INT64 must be a literal or query parameter [at 1:52]
select kll_quantiles.init_int64(@test_param_int64, key) from KeyValue
                                                   ^
==

select kll_quantiles.init_uint64(@test_param_uint64, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_UINT64 must be a literal or query parameter [at 1:54]
select kll_quantiles.init_uint64(@test_param_uint64, key) from KeyValue
                                                     ^
==

select kll_quantiles.init_int64(@test_param_int64, null) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_INT64 must be non-NULL [at 1:52]
select kll_quantiles.init_int64(@test_param_int64, null) from SimpleTypes
                                                   ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.init_double(@test_param_double, null) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_DOUBLE must be non-NULL [at 1:54]
select kll_quantiles.init_double(@test_param_double, null) from SimpleTypes
                                                     ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
ERROR: Argument 2 to KLL_QUANTILES.INIT_FLOAT64 must be non-NULL [at 1:54]
select kll_quantiles.init_double(@test_param_double, null) from SimpleTypes
                                                     ^
==

[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.init_double(@test_param_double, 100, weight => @test_param_int64 ) from SimpleTypes
--
ALTERNATION GROUP: internal
--
ERROR: Named arguments are not supported [at 1:59]
...kll_quantiles.init_double(@test_param_double, 100, weight => @test_param_i...
                                                      ^
--
ALTERNATION GROUPS:
    external
    +NAMED_ARGUMENTS,external
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,external
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.init_double [at 1:8]
select kll_quantiles.init_double(@test_param_double, 100, weight => @test_par...
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,internal
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_DOUBLE
  Argument types: DOUBLE, INT64, weight => INT64
  Signature: KLL_QUANTILES.INIT_DOUBLE(DOUBLE, [INT64])
    Named argument `weight` does not exist in signature [at 1:8]
select kll_quantiles.init_double(@test_param_double, 100, weight => @test_par...
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_double(DOUBLE, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=100)
              +-Parameter(type=INT64, name="test_param_int64")
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=100)
              +-Parameter(type=INT64, name="test_param_int64")
==

[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.init_float64(@test_param_double, 100, weight => @test_param_int64 ) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
    +NAMED_ARGUMENTS,internal
    +NAMED_ARGUMENTS,external
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,internal
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,external
--
ERROR: Function not found: kll_quantiles.init_float64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_float64(@test_param_double, 100, weight => @test_pa...
       ^
--
ALTERNATION GROUPS:
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_float64(DOUBLE, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=DOUBLE, name="test_param_double")
              +-Literal(type=INT64, value=100)
              +-Parameter(type=INT64, name="test_param_int64")
==

# INT32 widens to INT64
select kll_quantiles.init_int64(@test_param_int32) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_int64(INT64, optional(0) INT64) -> BYTES)
              +-Cast(INT32 -> INT64)
                +-Parameter(type=INT32, name="test_param_int32")
==

# UINT32 widens to UINT64
[product_mode={{|internal|external}}]
select kll_quantiles.init_uint64(@test_param_uint32) from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Cast(UINT32 -> UINT64)
                +-Parameter(type=UINT32, name="test_param_uint32")
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.init_uint64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint32) from SimpleTypes
       ^
==

# BYTES cannot be cast to INT64
select kll_quantiles.init_int64(@test_param_bytes) from SimpleTypes
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_INT64
  Argument types: BYTES
  Signature: KLL_QUANTILES.INIT_INT64(INT64, [INT64])
    Argument 1: Unable to coerce type BYTES to expected type INT64 [at 1:8]
select kll_quantiles.init_int64(@test_param_bytes) from SimpleTypes
       ^
==

select kll_quantiles.merge_partial(@test_param_bytes) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_partial(BYTES) -> BYTES)
              +-Parameter(type=BYTES, name="test_param_bytes")
==

[product_mode={{|internal|external}}]
select kll_quantiles.merge_int64(@test_param_bytes, 5) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_int64(BYTES, INT64) -> ARRAY<INT64>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=5)
==

[product_mode={{|internal|external}}]
select kll_quantiles.merge_uint64(@test_param_bytes, 2) from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<UINT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_uint64(BYTES, INT64) -> ARRAY<UINT64>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=2)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.merge_uint64; Did you mean kll_quantiles.merge_int64? [at 1:8]
select kll_quantiles.merge_uint64(@test_param_bytes, 2) from SimpleTypes
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.merge_double(@test_param_bytes, 50) from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_double(BYTES, INT64) -> ARRAY<DOUBLE>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=50)
--
ALTERNATION GROUPS:
    external
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.merge_double [at 1:8]
select kll_quantiles.merge_double(@test_param_bytes, 50) from SimpleTypes
       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=50)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.merge_float64(@test_param_bytes, 50) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.merge_float64; Did you mean kll_quantiles.merge_int64? [at 1:8]
select kll_quantiles.merge_float64(@test_param_bytes, 50) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=50)
==

select kll_quantiles.merge_int64(@test_param_bytes) from SimpleTypes
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.MERGE_INT64
  Argument types: BYTES
  Signature: KLL_QUANTILES.MERGE_INT64(BYTES, INT64)
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select kll_quantiles.merge_int64(@test_param_bytes) from SimpleTypes
       ^
==

select kll_quantiles.merge_int64(@test_param_bytes, key) from KeyValue
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_INT64 must be a literal or query parameter [at 1:53]
select kll_quantiles.merge_int64(@test_param_bytes, key) from KeyValue
                                                    ^

==

select kll_quantiles.merge_int64(@test_param_bytes, 0) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_INT64 must be at least 1 [at 1:53]
select kll_quantiles.merge_int64(@test_param_bytes, 0) from SimpleTypes
                                                    ^
==

select kll_quantiles.merge_int64(@test_param_bytes, 1) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_int64(BYTES, INT64) -> ARRAY<INT64>)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=1)
==

[product_mode={{|internal|external}}]
select kll_quantiles.extract_int64(@test_param_bytes, 10) from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_int64(BYTES, INT64) -> ARRAY<INT64>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=10)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

[product_mode={{|internal|external}}]
select kll_quantiles.extract_uint64(@test_param_bytes, 20) from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<UINT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_uint64(BYTES, INT64) -> ARRAY<UINT64>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=20)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.extract_uint64; Did you mean kll_quantiles.extract_int64? [at 1:8]
select kll_quantiles.extract_uint64(@test_param_bytes, 20) from SimpleTypes
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_double(@test_param_bytes, 5) from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_double(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUPS:
    external
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.extract_double [at 1:8]
select kll_quantiles.extract_double(@test_param_bytes, 5) from SimpleTypes
       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_float64(@test_param_bytes, 5) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.extract_float64; Did you mean kll_quantiles.extract_int64? [at 1:8]
select kll_quantiles.extract_float64(@test_param_bytes, 5) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_double(@test_param_bytes, key) from KeyValue
--
ALTERNATION GROUP: <empty>

--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_double(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_double(@test_param_bytes, 0) from SimpleTypes
--

ALTERNATION GROUP: <empty>
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_DOUBLE must be at least 1 [at 1:56]
select kll_quantiles.extract_double(@test_param_bytes, 0) from SimpleTypes
                                                       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_FLOAT64 must be at least 1 [at 1:56]
select kll_quantiles.extract_double(@test_param_bytes, 0) from SimpleTypes
                                                       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_double(@test_param_bytes, 1) from SimpleTypes
--

ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_double(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [ARRAY<DOUBLE>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_float64(BYTES, INT64) -> ARRAY<DOUBLE>)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=1)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

select kll_quantiles.extract_double(@test_param_bytes, NULL) from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_DOUBLE must be non-NULL [at 1:56]
select kll_quantiles.extract_double(@test_param_bytes, NULL) from SimpleTypes
                                                       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_float64(@test_param_bytes, NULL) from SimpleTypes
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.extract_float64; Did you mean kll_quantiles.extract_int64? [at 1:8]
select kll_quantiles.extract_float64(@test_param_bytes, NULL) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_FLOAT64 must be non-NULL [at 1:57]
select kll_quantiles.extract_float64(@test_param_bytes, NULL) from SimpleTypes
                                                        ^
==

[product_mode={{|internal|external}}]
select kll_quantiles.merge_point_int64(@test_param_bytes, 0.99)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_int64(BYTES, DOUBLE) -> INT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=0.99)
==

[product_mode={{|internal|external}}]
select kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5)
from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_uint64(BYTES, DOUBLE) -> UINT64)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=0.5)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.merge_point_uint64; Did you mean kll_quantiles.merge_point_int64? [at 1:8]
select kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5)
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.merge_point_double(@test_param_bytes, 1) from SimpleTypes
--

ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_double(BYTES, DOUBLE) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=1)
--
ALTERNATION GROUPS:
    external
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.merge_point_double [at 1:8]
select kll_quantiles.merge_point_double(@test_param_bytes, 1) from SimpleTypes
       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_float64(BYTES, DOUBLE) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=1)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.merge_point_float64(@test_param_bytes, 1) from SimpleTypes
--

ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.merge_point_float64; Did you mean kll_quantiles.merge_point_int64? [at 1:8]
select kll_quantiles.merge_point_float64(@test_param_bytes, 1) from SimpleTypes
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_point_float64(BYTES, DOUBLE) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=1)
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5+0.1) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be a literal or query parameter [at 1:60]
...kll_quantiles.merge_point_uint64(@test_param_bytes, 0.5+0.1) from SimpleTypes
                                                       ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, key) from KeyValue
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be a literal or query parameter [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, key) from KeyValue
                                                           ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, 5) from SimpleTypes
--

ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be between 0 and 1 [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, 5) from SimpleTypes
                                                           ^
==

select kll_quantiles.merge_point_uint64(@test_param_bytes, NULL)
from SimpleTypes
--
ERROR: Argument 2 to KLL_QUANTILES.MERGE_POINT_UINT64 must be non-NULL [at 1:60]
select kll_quantiles.merge_point_uint64(@test_param_bytes, NULL)
                                                           ^
==

[product_mode={{|internal|external}}]
select kll_quantiles.extract_point_int64(@test_param_bytes, 0) from SimpleTypes
--

QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_int64(BYTES, DOUBLE) -> INT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

[product_mode={{|internal|external}}]
select kll_quantiles.extract_point_uint64(@test_param_bytes, 0.75)
from SimpleTypes
--
ALTERNATION GROUPS:
    <empty>
    internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_uint64(BYTES, DOUBLE) -> UINT64)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0.75)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.extract_point_uint64; Did you mean kll_quantiles.extract_point_int64? [at 1:8]
select kll_quantiles.extract_point_uint64(@test_param_bytes, 0.75)
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_point_double(@test_param_bytes, 0.995)
from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0.995)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.extract_point_double; Did you mean kll_quantiles.extract_point_int64? [at 1:8]
select kll_quantiles.extract_point_double(@test_param_bytes, 0.995)
       ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_float64(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=0.995)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.extract_point_double; Did you mean kll_quantiles.extract_point_float64? [at 1:8]
select kll_quantiles.extract_point_double(@test_param_bytes, 0.995)
       ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_point_double(@test_param_bytes, 0.5+0.1) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |       +-Literal(type=DOUBLE, value=0.5)
    |       +-Literal(type=DOUBLE, value=0.1)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_float64(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-FunctionCall(ZetaSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
    |       +-Literal(type=DOUBLE, value=0.5)
    |       +-Literal(type=DOUBLE, value=0.1)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_point_double(@test_param_bytes, key) from KeyValue
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_double(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_float64(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_point_float64(@test_param_bytes, key) from KeyValue
--
ALTERNATION GROUPS:
    internal
    external
--
ERROR: Function not found: kll_quantiles.extract_point_float64; Did you mean kll_quantiles.extract_point_int64? [at 1:8]
select kll_quantiles.extract_point_float64(@test_param_bytes, key) from KeyValue
       ^
--
ALTERNATION GROUPS:
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
    +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
QueryStmt
+-output_column_list=
| +-$query.$col1#3 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#3]
    +-expr_list=
    | +-$col1#3 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_point_float64(BYTES, DOUBLE) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Cast(INT64 -> DOUBLE)
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_point_double(@test_param_bytes, 1.1) from SimpleTypes
--

ALTERNATION GROUP: <empty>
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_DOUBLE must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, 1.1) from SimpleTypes
                                           ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_FLOAT64 must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, 1.1) from SimpleTypes
                                           ^
==

[language_features=NONE,{{|+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_point_double(@test_param_bytes, -1) from SimpleTypes
--
ALTERNATION GROUP: <empty>
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_DOUBLE must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, -1) from SimpleTypes
                                           ^
--
ALTERNATION GROUP: +KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
ERROR: Argument 2 to KLL_QUANTILES.EXTRACT_POINT_FLOAT64 must be between 0 and 1 [at 1:62]
...extract_point_double(@test_param_bytes, -1) from SimpleTypes
                                           ^
==

# Compare behavior when the feature is enabled vs. not enabled.  Tests
[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64)
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    +NAMED_ARGUMENTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(0) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=1000)
              +-Literal(type=INT64, value=1)
==

[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS}}]
[product_mode={{|internal|external}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100)
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    internal
    +NAMED_ARGUMENTS,
    +NAMED_ARGUMENTS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
--
ALTERNATION GROUPS:
    external
    +NAMED_ARGUMENTS,external
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,external
--
ERROR: Function not found: kll_quantiles.init_uint64; Did you mean kll_quantiles.init_int64? [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100)
       ^
--
ALTERNATION GROUPS:
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,
    +NAMED_ARGUMENTS,+KLL_WEIGHTS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
              +-Literal(type=INT64, value=1)
==

# The 'weight' argument has a mandatory name, so the query fails when
# expressing it positionally.
[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
                                 IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUPS:
    <empty>
    +NAMED_ARGUMENTS
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_UINT64
  Argument types: UINT64, INT64, INT64
  Signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64])
    Signature accepts at most 2 arguments, found 3 arguments [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_UINT64
  Argument types: UINT64, INT64, INT64
  Signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64], [weight => INT64])
    Positional argument at 3 is invalid because argument `weight` can only be referred to by name [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
       ^
==

[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Named arguments are not supported [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_UINT64
  Argument types: UINT64, INT64, weight => INT64
  Signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64])
    Named argument `weight` does not exist in signature [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64, 100,
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=100)
              +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
                | +-Parameter(type=UINT64, name="test_param_uint64")
                | +-Literal(type=INT64, value=5)
                +-Literal(type=INT64, value=2)
                +-Literal(type=INT64, value=1)
==

# The second optional 'precision' argument is omitted.
[language_features=NONE,{{|+NAMED_ARGUMENTS|+NAMED_ARGUMENTS,+KLL_WEIGHTS}}]
select kll_quantiles.init_uint64(@test_param_uint64,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ALTERNATION GROUP: <empty>
--
ERROR: Named arguments are not supported [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.INIT_UINT64
  Argument types: UINT64, weight => INT64
  Signature: KLL_QUANTILES.INIT_UINT64(UINT64, [INT64])
    Named argument `weight` does not exist in signature [at 1:8]
select kll_quantiles.init_uint64(@test_param_uint64,
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_WEIGHTS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [BYTES]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.init_uint64(UINT64, optional(1) INT64, optional(1) INT64 weight) -> BYTES)
              +-Parameter(type=UINT64, name="test_param_uint64")
              +-Literal(type=INT64, value=1000)
              +-FunctionCall(ZetaSQL:if(BOOL, INT64, INT64) -> INT64)
                +-FunctionCall(ZetaSQL:$greater(UINT64, INT64) -> BOOL)
                | +-Parameter(type=UINT64, name="test_param_uint64")
                | +-Literal(type=INT64, value=5)
                +-Literal(type=INT64, value=2)
                +-Literal(type=INT64, value=1)
==

# Same as the above, but without the NAMED_ARGUMENTS feature, to ensure we
# get a reasonable error message.
[language_features=NONE,+KLL_WEIGHTS]
select kll_quantiles.init_uint64(@test_param_uint64,
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
from SimpleTypes;
--
ERROR: Named arguments are not supported [at 2:34]
                                 weight => IF(@test_param_uint64 > 5, 2, 1))
                                 ^
==

# Test for basic INT64 usage with a named required argument 'value'.
# The 'rank_type' argument is optional and defaults to 'first'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
[product_mode={{internal|external}}]
select kll_quantiles.merge_relative_rank_int64(
    @test_param_bytes, value => 2)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
==

# Test for the UINT64 version with the optional 'rank_type' argument specified as 'FRACTION_LESS_THAN_OR_EQUAL'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
[product_mode={{internal|external}}]
select kll_quantiles.merge_relative_rank_uint64(
    @test_param_bytes, value => 2, rank_type => 'FRACTION_LESS_THAN_OR_EQUAL')
from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_uint64(BYTES, UINT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=UINT64, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN_OR_EQUAL)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.merge_relative_rank_uint64; Did you mean kll_quantiles.merge_relative_rank_int64? [at 1:8]
select kll_quantiles.merge_relative_rank_uint64(
       ^
==

# Test for the DOUBLE version with 'rank_type' as MIDPOINT.
# Also test that the double version is not supported in external mode.
[language_features=NONE,{{+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK|+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.merge_relative_rank_double(
    @test_param_bytes, value => 2, rank_type => 'MIDPOINT')
from SimpleTypes
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_double(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,external
--
ERROR: Function not found: kll_quantiles.merge_relative_rank_double; Did you mean kll_quantiles.merge_relative_rank_int64? [at 1:8]
select kll_quantiles.merge_relative_rank_double(
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_float64(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.merge_relative_rank_double; Did you mean kll_quantiles.merge_relative_rank_float64? [at 1:8]
select kll_quantiles.merge_relative_rank_double(
       ^
==

[language_features=NONE,{{+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK|+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.merge_relative_rank_float64(
    @test_param_bytes, value => 2, rank_type => 'MIDPOINT')
from SimpleTypes
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK
--
ERROR: Function not found: kll_quantiles.merge_relative_rank_float64; Did you mean kll_quantiles.merge_relative_rank_int64? [at 1:8]
select kll_quantiles.merge_relative_rank_float64(
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_float64(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=DOUBLE, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
==

# Test with a NULL 'value' parameter.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.merge_relative_rank_int64(
    @test_param_bytes, value => NULL)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=NULL)
              +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
==

# Test with a NULL 'rank_type'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.merge_relative_rank_int64(
    @test_param_bytes, value => 2, rank_type => NULL)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Parameter(type=BYTES, name="test_param_bytes")
              +-Literal(type=INT64, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=NULL)
==

# Test with only NULL sketch values as input.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.merge_relative_rank_int64(
    NULL, value => 2)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$aggregate.$agg1#20]
    +-input_scan=
      +-AggregateScan
        +-column_list=[$aggregate.$agg1#20]
        +-input_scan=
        | +-TableScan(table=SimpleTypes)
        +-aggregate_list=
          +-$agg1#20 :=
            +-AggregateFunctionCall(ZetaSQL:kll_quantiles.merge_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
              +-Literal(type=BYTES, value=NULL)
              +-Literal(type=INT64, value=2)
              +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
==

# Error case: Test with an invalid string for 'rank_type'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.merge_relative_rank_int64(
    @test_param_bytes, value => 2, rank_type => SOME_INVALID_RANK_TYPE)
from SimpleTypes
--
ERROR: Unrecognized name: SOME_INVALID_RANK_TYPE [at 2:49]
    @test_param_bytes, value => 2, rank_type => SOME_INVALID_RANK_TYPE)
                                                ^
==

# Error case: Test with the required named argument 'value' missing.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.merge_relative_rank_int64(
    @test_param_bytes)
from SimpleTypes
--
ERROR: No matching signature for aggregate function KLL_QUANTILES.MERGE_RELATIVE_RANK_INT64
  Argument types: BYTES
  Signature: KLL_QUANTILES.MERGE_RELATIVE_RANK_INT64(BYTES, value => INT64, [rank_type => RANK_TYPE])
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select kll_quantiles.merge_relative_rank_int64(
       ^
==

# Test for basic INT64 usage with a named required argument 'value'.
# The 'rank_type' argument is optional and defaults to 'FRACTION_LESS_THAN'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
[product_mode={{internal|external}}]
select kll_quantiles.extract_relative_rank_int64(
    @test_param_bytes, value => 2)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# Test for the UINT64 version with the optional 'rank_type' argument specified as 'FRACTION_LESS_THAN_OR_EQUAL'.
# Also test that the uint64 version is not supported in external mode.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
[product_mode={{internal|external}}]
select kll_quantiles.extract_relative_rank_uint64(
    @test_param_bytes, value => 2, rank_type => 'FRACTION_LESS_THAN_OR_EQUAL')
from SimpleTypes
--
ALTERNATION GROUP: internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_uint64(BYTES, UINT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=UINT64, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN_OR_EQUAL)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: external
--
ERROR: Function not found: kll_quantiles.extract_relative_rank_uint64; Did you mean kll_quantiles.extract_relative_rank_int64? [at 1:8]
select kll_quantiles.extract_relative_rank_uint64(
       ^
==

# Test for the DOUBLE version with 'rank_type' as MIDPOINT.
# Also test that the double version is not supported in external mode.
[language_features=NONE,{{+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK|+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
[product_mode={{internal|external}}]
select kll_quantiles.extract_relative_rank_double(
    @test_param_bytes, value => 2, rank_type => 'MIDPOINT')
from SimpleTypes
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_double(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,external
--
ERROR: Function not found: kll_quantiles.extract_relative_rank_double; Did you mean kll_quantiles.extract_relative_rank_int64? [at 1:8]
select kll_quantiles.extract_relative_rank_double(
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,internal
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_float64(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS,external
--
ERROR: Function not found: kll_quantiles.extract_relative_rank_double; Did you mean kll_quantiles.extract_relative_rank_float64? [at 1:8]
select kll_quantiles.extract_relative_rank_double(
       ^
==

[language_features=NONE,{{+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK|+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS}}]
select kll_quantiles.extract_relative_rank_float64(
    @test_param_bytes, value => 2, rank_type => 'MIDPOINT')
from SimpleTypes
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK
--
ERROR: Function not found: kll_quantiles.extract_relative_rank_float64; Did you mean kll_quantiles.extract_relative_rank_int64? [at 1:8]
select kll_quantiles.extract_relative_rank_float64(
       ^
--
ALTERNATION GROUP: +NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK,+KLL_FLOAT64_PRIMARY_WITH_DOUBLE_ALIAS
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_float64(BYTES, DOUBLE value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=DOUBLE, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=MIDPOINT)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# Test with a NULL 'value' parameter.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.extract_relative_rank_int64(
    @test_param_bytes, value => NULL)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=NULL)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# Test with a NULL 'rank_type'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.extract_relative_rank_int64(
    @test_param_bytes, value => 2, rank_type => NULL)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Parameter(type=BYTES, name="test_param_bytes")
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=NULL)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# Test with only NULL sketch values as input.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.extract_relative_rank_int64(
    NULL, value => 2)
from SimpleTypes
--
QueryStmt
+-output_column_list=
| +-$query.$col1#20 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#20]
    +-expr_list=
    | +-$col1#20 :=
    |   +-FunctionCall(ZetaSQL:kll_quantiles.extract_relative_rank_int64(BYTES, INT64 value, optional(1) ENUM<RANK_TYPE> rank_type) -> DOUBLE)
    |     +-Literal(type=BYTES, value=NULL)
    |     +-Literal(type=INT64, value=2)
    |     +-Literal(type=ENUM<RANK_TYPE>, value=FRACTION_LESS_THAN)
    +-input_scan=
      +-TableScan(table=SimpleTypes)
==

# Error case: Test with an invalid string for 'rank_type'.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.extract_relative_rank_int64(
    @test_param_bytes, value => 2, rank_type => SOME_INVALID_RANK_TYPE)
from SimpleTypes
--
ERROR: Unrecognized name: SOME_INVALID_RANK_TYPE [at 2:49]
    @test_param_bytes, value => 2, rank_type => SOME_INVALID_RANK_TYPE)
                                                ^
==

# Error case: Test with the required named argument 'value' missing.
[language_features=NONE,+NAMED_ARGUMENTS,+KLL_QUANTILES_EXTRACT_RELATIVE_RANK]
select kll_quantiles.extract_relative_rank_int64(
    @test_param_bytes)
from SimpleTypes
--
ERROR: No matching signature for function KLL_QUANTILES.EXTRACT_RELATIVE_RANK_INT64
  Argument types: BYTES
  Signature: KLL_QUANTILES.EXTRACT_RELATIVE_RANK_INT64(BYTES, value => INT64, [rank_type => RANK_TYPE])
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select kll_quantiles.extract_relative_rank_int64(
       ^
