[default language_features=MAXIMUM,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS,+CREATE_TABLE_FUNCTION,+TEMPLATE_FUNCTIONS,+FUNCTION_ARGUMENTS_WITH_DEFAULTS,+PIPE_CALL_INPUT_TABLE]

[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
select *
from tvf_two_relation_args_return_proto_value_table(TABLE KeyValue, INPUT TABLE)
--
ALTERNATION GROUP: <empty>
--
ERROR: INPUT TABLE arguments are not supported [at 2:69]
from tvf_two_relation_args_return_proto_value_table(TABLE KeyValue, INPUT TABLE)
                                                                    ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: INPUT TABLE arguments are only allowed when using pipe CALL to call TVFs [at 2:69]
from tvf_two_relation_args_return_proto_value_table(TABLE KeyValue, INPUT TABLE)
                                                                    ^
==

[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
select *
from tvf_optional_scalars_named_table(123, foobar => INPUT TABLE)
--
ALTERNATION GROUP: <empty>
--
ERROR: INPUT TABLE arguments are not supported [at 2:54]
from tvf_optional_scalars_named_table(123, foobar => INPUT TABLE)
                                                     ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: INPUT TABLE arguments are only allowed when using pipe CALL to call TVFs [at 2:54]
from tvf_optional_scalars_named_table(123, foobar => INPUT TABLE)
                                                     ^
==

[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
select 1 x
|> call tvf_no_args(INPUT TABLE)
--
ALTERNATION GROUP: <empty>
--
ERROR: INPUT TABLE arguments are not supported [at 2:21]
|> call tvf_no_args(INPUT TABLE)
                    ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: No matching signature for tvf_no_args
  Argument types: TABLE<x INT64> (from pipe input)
  Signature: TVF_NO_ARGS()
    Signature accepts at most 0 arguments, found 1 argument (including pipe input table) [at 2:9]
|> call tvf_no_args(INPUT TABLE)
        ^
==

select 1 x
|> call tvf_exactly_3_int64_args(INPUT TABLE, 1, 2)
--
ERROR: No matching signature for tvf_exactly_3_int64_args
  Argument types: TABLE<x INT64> (from pipe input), INT64, INT64
  Signature: TVF_EXACTLY_3_INT64_ARGS(INT64, INT64, INT64)
    Argument 1: expected INT64, found TABLE<x INT64> [at 2:9]
|> call tvf_exactly_3_int64_args(INPUT TABLE, 1, 2)
        ^
==

select 1 x
|> call tvf_exactly_3_int64_args(1, INPUT TABLE, 2)
--
ERROR: No matching signature for tvf_exactly_3_int64_args
  Argument types: INT64, TABLE<x INT64> (from pipe input), INT64
  Signature: TVF_EXACTLY_3_INT64_ARGS(INT64, INT64, INT64)
    Argument 2: expected INT64, found TABLE<x INT64> [at 2:9]
|> call tvf_exactly_3_int64_args(1, INPUT TABLE, 2)
        ^
==

# The SQLBuilder uses the default pipe CALL form regardless of whether the
# query used INPUT TABLE syntax.
[show_sqlbuilder_output]
select "abc"
|> call tvf_two_relation_args_return_proto_value_table(
      {{|INPUT TABLE,}} TABLE KeyValue)
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#4 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#4]
    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    +-signature=(TABLE<$col1 STRING>, TABLE<Key INT64, Value STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.$col1#1]
    | | |   +-expr_list=
    | | |   | +-$col1#1 := Literal(type=STRING, value="abc")
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-argument_column_list=[$query.$col1#1]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#2, Value#3], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#2, Value#3]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT AS VALUE
  tvfscan_6 AS a_7
FROM
  TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE((
    SELECT
      a_1 AS a_1
    FROM
      (
        SELECT
          "abc" AS a_1
      ) AS projectscan_2
  ), (
    SELECT
      a_3 AS Key,
      a_4 AS Value
    FROM
      (
        SELECT
          KeyValue.Key AS a_3,
          KeyValue.Value AS a_4
        FROM
          KeyValue
      ) AS keyvalue_5
  )) AS tvfscan_6;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
SELECT
  "abc" AS a_1
|> AS projectscan_2
|> SELECT
     a_1 AS a_1
|> CALL TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE((
     FROM
       KeyValue
     |> SELECT
          KeyValue.Key AS a_3,
          KeyValue.Value AS a_4
     |> AS keyvalue_5
     |> SELECT
          a_3 AS Key,
          a_4 AS Value
   )) AS tvfscan_6
|> SELECT AS VALUE
     tvfscan_6 AS a_7;
==

# The SQLBuilder uses the default pipe CALL form without INPUT TABLE, but the
# first TVF argument becomes the pipe input, and the original pipe input
# becomes a subquery input passed to the second TVF argument.
[show_sqlbuilder_output]
select "abc"
|> call tvf_two_relation_args_return_proto_value_table(TABLE KeyValue, INPUT TABLE)
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#4 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#4]
    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    +-signature=(TABLE<Key INT64, Value STRING>, TABLE<$col1 STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#2, Value#3], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#2, Value#3]
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.$col1#1]
    |   |   +-expr_list=
    |   |   | +-$col1#1 := Literal(type=STRING, value="abc")
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=[$query.$col1#1]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT AS VALUE
  tvfscan_6 AS a_7
FROM
  TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE((
    SELECT
      a_1 AS Key,
      a_2 AS Value
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ), (
    SELECT
      a_4 AS a_4
    FROM
      (
        SELECT
          "abc" AS a_4
      ) AS projectscan_5
  )) AS tvfscan_6;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  KeyValue
|> SELECT
     KeyValue.Key AS a_1,
     KeyValue.Value AS a_2
|> AS keyvalue_3
|> SELECT
     a_1 AS Key,
     a_2 AS Value
|> CALL TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE((
     SELECT
       "abc" AS a_4
     |> AS projectscan_5
     |> SELECT
          a_4 AS a_4
   )) AS tvfscan_6
|> SELECT AS VALUE
     tvfscan_6 AS a_7;
==

select "abc"
|> call tvf_two_relation_args_return_proto_value_table(INPUT TABLE, INPUT TABLE)
--
ERROR: TVF calls cannot have multiple INPUT TABLE arguments [at 2:69]
|> call tvf_two_relation_args_return_proto_value_table(INPUT TABLE, INPUT TABLE)
                                                                    ^
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(123, INPUT TABLE)
--
ERROR: No matching signature for tvf_optional_scalars_named_table
  Argument types: INT64, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_OPTIONAL_SCALARS_NAMED_TABLE([ANY], [ANY], [foobar => TABLE])
    Argument 2: expected ANY, found TABLE<Key INT64, Value STRING> [at 2:9]
|> CALL tvf_optional_scalars_named_table(123, INPUT TABLE)
        ^
==

# This actually works, because the third argument is optionally named,
# after the two optional scalar arguments.
FROM KeyValue
|> CALL tvf_optional_scalars_named_table(123, 456, INPUT TABLE)
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#3, column_bytes#4]
    +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(literal INT64, literal INT64, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=123)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=456)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(optional(1) INT64, optional(1) INT64, optional(1) ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The SQLBuilder uses standard syntax for this call.  It doesn't use
# INPUT TABLE syntax in pipe CALL yet.
[show_sqlbuilder_output]
FROM KeyValue
|> CALL tvf_optional_scalars_named_table(123, foobar => INPUT TABLE)
--
QueryStmt
+-output_column_list=
| +-tvf_optional_scalars_named_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_optional_scalars_named_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_optional_scalars_named_table.[column_bool#3, column_bytes#4]
    +-tvf=tvf_optional_scalars_named_table((optional ANY TYPE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(literal INT64, null INT64, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=123)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=NULL)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(optional(1) INT64, optional(1) INT64, optional(1) ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  tvfscan_4.column_bool AS column_bool,
  tvfscan_4.column_bytes AS column_bytes
FROM
  TVF_OPTIONAL_SCALARS_NAMED_TABLE(123, CAST(NULL AS INT64), (
    SELECT
      a_1 AS Key,
      a_2 AS Value
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  )) AS tvfscan_4;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  TVF_OPTIONAL_SCALARS_NAMED_TABLE(123, CAST(NULL AS INT64), (
    FROM
      KeyValue
    |> SELECT
         KeyValue.Key AS a_1,
         KeyValue.Value AS a_2
    |> AS keyvalue_3
    |> SELECT
         a_1 AS Key,
         a_2 AS Value
  )) AS tvfscan_4
|> SELECT
     tvfscan_4.column_bool AS column_bool,
     tvfscan_4.column_bytes AS column_bytes;
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(123, bad_name => INPUT TABLE)
--
ERROR: No matching signature for tvf_optional_scalars_named_table
  Argument types: INT64, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_OPTIONAL_SCALARS_NAMED_TABLE([ANY], [ANY], [foobar => TABLE])
    Named argument `bad_name` does not exist in signature [at 2:9]
|> CALL tvf_optional_scalars_named_table(123, bad_name => INPUT TABLE)
        ^
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(
            123, foobar => INPUT TABLE, foobar => INPUT TABLE)
--
ERROR: TVF calls cannot have multiple INPUT TABLE arguments [at 3:51]
            123, foobar => INPUT TABLE, foobar => INPUT TABLE)
                                                  ^
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(
            123, foobar => INPUT TABLE, foobar => 123)
--
ERROR: Table-valued function tvf_optional_scalars_named_table argument 3 ('foobar') must be a relation (i.e. table subquery) [at 3:51]
            123, foobar => INPUT TABLE, foobar => 123)
                                                  ^
==

# Maybe not an ideal message, but it's still okay, and if we make it
# past this, we'd get other errors.
FROM KeyValue
|> CALL tvf_optional_scalars_named_table(
            123, foobar => INPUT TABLE, 456)
--
ERROR: Table-valued function tvf_optional_scalars_named_table argument 3 ('foobar') must be a relation (i.e. table subquery) [at 3:41]
            123, foobar => INPUT TABLE, 456)
                                        ^
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(
            foobar => INPUT TABLE, 456)
--
ERROR: Call to function tvf_optional_scalars_named_table must not specify positional arguments after named arguments; named arguments must be specified last in the argument list [at 3:13]
            foobar => INPUT TABLE, 456)
            ^
==

FROM KeyValue
|> call tvf_two_relation_args_return_proto_value_table(
              {{INPUT TABLE, |}} TABLE TestTable )
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#6 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#6]
    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    +-signature=(TABLE<Key INT64, Value STRING>, TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, KitchenSink PROTO<zetasql_test__.KitchenSinkPB>>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5], table=TestTable, column_index_list=[0, 1, 2])
    |   +-argument_column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
==

FROM KeyValue
|> call tvf_two_relation_args_return_proto_value_table(
            TABLE TestTable, INPUT TABLE )
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#6 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#6]
    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    +-signature=(TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, KitchenSink PROTO<zetasql_test__.KitchenSinkPB>>, TABLE<Key INT64, Value STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5], table=TestTable, column_index_list=[0, 1, 2])
    | | +-argument_column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
==

[prepare_database=db]
create table xy (x INT64, y INT64);
--
CreateTableStmt
+-name_path=xy
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=xy.x#1)
  +-ColumnDefinition(name="y", type=INT64, column=xy.y#2)
==

[prepare_database=db]
create table xz (x INT64, z INT64);
--
CreateTableStmt
+-name_path=xz
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=xz.x#1)
  +-ColumnDefinition(name="z", type=INT64, column=xz.z#2)
==

# This TVF joins `t1` and `t2` using `x`.
# Output column order will vary based on which table is `t1` or `t2`.
[prepare_database=db]
create table function tvf_joinx(t1 ANY TABLE, t2 ANY TABLE)
AS (FROM t1 JOIN t2 USING (x));
--
CreateTableFunctionStmt(name_path=tvf_joinx, argument_name_list=[t1, t2], signature=(ANY TABLE t1, ANY TABLE t2) -> ANY TABLE, language="SQL", code="FROM t1 JOIN t2 USING (x)")
==

# Use two-table TVF in plain CALL syntax, or with INPUT TABLE.
# Optionally use the name for the second table arg.
[default use_database=db]
FROM xy
|> call tvf_joinx( {{INPUT TABLE,|}} {{t2=>|}}(FROM xz) )
--
QueryStmt
+-output_column_list=
| +-tvf_joinx.x#5 AS x [INT64]
| +-tvf_joinx.y#6 AS y [INT64]
| +-tvf_joinx.z#7 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=tvf_joinx.[x#5, y#6, z#7]
    +-tvf=tvf_joinx((ANY TABLE t1, ANY TABLE t2) -> ANY TABLE)
    +-signature=(TABLE<x INT64, y INT64>, TABLE<x INT64, z INT64>) -> TABLE<x INT64, y INT64, z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=xy.[x#1, y#2], table=xy, column_index_list=[0, 1])
    | | +-argument_column_list=xy.[x#1, y#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=xz.[x#3, z#4], table=xz, column_index_list=[0, 1])
    |   +-argument_column_list=xz.[x#3, z#4]
    +-column_index_list=[0, 1, 2]
    +-function_call_signature=(ANY TABLE t1, ANY TABLE t2) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_joinx(TABLE<x INT64, y INT64>, TABLE<x INT64, z INT64>) -> TABLE<x INT64, y INT64, z INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
| +-t1.y#2 AS y [INT64]
| +-t2.z#4 AS z [INT64]
+-query=
  +-JoinScan
    +-column_list=[t1.x#1, t1.y#2, t2.x#3, t2.z#4]
    +-left_scan=
    | +-RelationArgumentScan(column_list=t1.[x#1, y#2], name="t1")
    +-right_scan=
    | +-RelationArgumentScan(column_list=t2.[x#3, z#4], name="t2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t1.x#1)
    |   +-ColumnRef(type=INT64, column=t2.x#3)
    +-has_using=TRUE
==


# Use INPUT TABLE for the second table argument, optionally with a name.
# `t1` is `xz` so we get columns [x,z,y].
# Optionally use the name for the second table arg.
[default use_database=db]
FROM xy
|> call tvf_joinx(TABLE xz, {{t2=>|}}INPUT TABLE )
--
QueryStmt
+-output_column_list=
| +-tvf_joinx.x#5 AS x [INT64]
| +-tvf_joinx.z#6 AS z [INT64]
| +-tvf_joinx.y#7 AS y [INT64]
+-query=
  +-TVFScan
    +-column_list=tvf_joinx.[x#5, z#6, y#7]
    +-tvf=tvf_joinx((ANY TABLE t1, ANY TABLE t2) -> ANY TABLE)
    +-signature=(TABLE<x INT64, z INT64>, TABLE<x INT64, y INT64>) -> TABLE<x INT64, z INT64, y INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=xz.[x#3, z#4], table=xz, column_index_list=[0, 1])
    | | +-argument_column_list=xz.[x#3, z#4]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=xy.[x#1, y#2], table=xy, column_index_list=[0, 1])
    |   +-argument_column_list=xy.[x#1, y#2]
    +-column_index_list=[0, 1, 2]
    +-function_call_signature=(ANY TABLE t1, ANY TABLE t2) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_joinx(TABLE<x INT64, z INT64>, TABLE<x INT64, y INT64>) -> TABLE<x INT64, z INT64, y INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
| +-t1.z#2 AS z [INT64]
| +-t2.y#4 AS y [INT64]
+-query=
  +-JoinScan
    +-column_list=[t1.x#1, t1.z#2, t2.x#3, t2.y#4]
    +-left_scan=
    | +-RelationArgumentScan(column_list=t1.[x#1, z#2], name="t1")
    +-right_scan=
    | +-RelationArgumentScan(column_list=t2.[x#3, y#4], name="t2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t1.x#1)
    |   +-ColumnRef(type=INT64, column=t2.x#3)
    +-has_using=TRUE
==

# Two tables args in their natural order, with names for both, and INPUT TABLE
# for the second one.
# `t1` is `xz` so we get columns [x,z,y].
FROM xy
|> call tvf_joinx(t1=>(FROM xz), t2=>INPUT TABLE )
--
QueryStmt
+-output_column_list=
| +-tvf_joinx.x#5 AS x [INT64]
| +-tvf_joinx.z#6 AS z [INT64]
| +-tvf_joinx.y#7 AS y [INT64]
+-query=
  +-TVFScan
    +-column_list=tvf_joinx.[x#5, z#6, y#7]
    +-tvf=tvf_joinx((ANY TABLE t1, ANY TABLE t2) -> ANY TABLE)
    +-signature=(TABLE<x INT64, z INT64>, TABLE<x INT64, y INT64>) -> TABLE<x INT64, z INT64, y INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=xz.[x#3, z#4], table=xz, column_index_list=[0, 1])
    | | +-argument_column_list=xz.[x#3, z#4]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=xy.[x#1, y#2], table=xy, column_index_list=[0, 1])
    |   +-argument_column_list=xy.[x#1, y#2]
    +-column_index_list=[0, 1, 2]
    +-function_call_signature=(ANY TABLE t1, ANY TABLE t2) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_joinx(TABLE<x INT64, z INT64>, TABLE<x INT64, y INT64>) -> TABLE<x INT64, z INT64, y INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
| +-t1.z#2 AS z [INT64]
| +-t2.y#4 AS y [INT64]
+-query=
  +-JoinScan
    +-column_list=[t1.x#1, t1.z#2, t2.x#3, t2.y#4]
    +-left_scan=
    | +-RelationArgumentScan(column_list=t1.[x#1, z#2], name="t1")
    +-right_scan=
    | +-RelationArgumentScan(column_list=t2.[x#3, y#4], name="t2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t1.x#1)
    |   +-ColumnRef(type=INT64, column=t2.x#3)
    +-has_using=TRUE
==

# Two table args in their reversed order, with names for both, and INPUT TABLE
# for the second one.
# `t1` is `xy` so we get columns [x,y,z].
FROM xy
|> call tvf_joinx(t2=>(FROM xz), t1=>INPUT TABLE )
--
QueryStmt
+-output_column_list=
| +-tvf_joinx.x#5 AS x [INT64]
| +-tvf_joinx.y#6 AS y [INT64]
| +-tvf_joinx.z#7 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=tvf_joinx.[x#5, y#6, z#7]
    +-tvf=tvf_joinx((ANY TABLE t1, ANY TABLE t2) -> ANY TABLE)
    +-signature=(TABLE<x INT64, y INT64>, TABLE<x INT64, z INT64>) -> TABLE<x INT64, y INT64, z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=xy.[x#1, y#2], table=xy, column_index_list=[0, 1])
    | | +-argument_column_list=xy.[x#1, y#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=xz.[x#3, z#4], table=xz, column_index_list=[0, 1])
    |   +-argument_column_list=xz.[x#3, z#4]
    +-column_index_list=[0, 1, 2]
    +-function_call_signature=(ANY TABLE t1, ANY TABLE t2) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_joinx(TABLE<x INT64, y INT64>, TABLE<x INT64, z INT64>) -> TABLE<x INT64, y INT64, z INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
| +-t1.y#2 AS y [INT64]
| +-t2.z#4 AS z [INT64]
+-query=
  +-JoinScan
    +-column_list=[t1.x#1, t1.y#2, t2.x#3, t2.z#4]
    +-left_scan=
    | +-RelationArgumentScan(column_list=t1.[x#1, y#2], name="t1")
    +-right_scan=
    | +-RelationArgumentScan(column_list=t2.[x#3, z#4], name="t2")
    +-join_expr=
    | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   +-ColumnRef(type=INT64, column=t1.x#1)
    |   +-ColumnRef(type=INT64, column=t2.x#3)
    +-has_using=TRUE
==

# A call with INPUT TABLE where expanding the templated TVF fails.
FROM xy
|> call tvf_joinx(TABLE KeyValue, INPUT TABLE)
--
ERROR: Invalid table-valued function tvf_joinx [at 2:9]
|> call tvf_joinx(TABLE KeyValue, INPUT TABLE)
        ^
Analysis of table-valued function tvf_joinx failed [at 1:24]
FROM t1 JOIN t2 USING (x)
                       ^
Column x in USING clause not found on left side of join [at 1:24]
FROM t1 JOIN t2 USING (x)
                       ^
==

# A call with INPUT TABLE named args where expanding the templated TVF fails.
FROM xy
|> call tvf_joinx(t2=>(FROM KeyValue), t1=>INPUT TABLE)
--
ERROR: Invalid table-valued function tvf_joinx [at 2:9]
|> call tvf_joinx(t2=>(FROM KeyValue), t1=>INPUT TABLE)
        ^
Analysis of table-valued function tvf_joinx failed [at 1:24]
FROM t1 JOIN t2 USING (x)
                       ^
Column x in USING clause not found on right side of join [at 1:24]
FROM t1 JOIN t2 USING (x)
                       ^
