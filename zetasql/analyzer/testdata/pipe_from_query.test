[default language_features=NONE]
from TestTable
--
ERROR: Syntax error: Unexpected FROM [at 1:1]
from TestTable
^
==

select (from TestTable)
--
ERROR: Syntax error: Unexpected FROM [at 1:9]
select (from TestTable)
        ^
==

select EXISTS(from TestTable)
--
ERROR: Syntax error: Unexpected FROM [at 1:15]
select EXISTS(from TestTable)
              ^
==

select ARRAY(from TestTable)
--
ERROR: Syntax error: Unexpected FROM [at 1:14]
select ARRAY(from TestTable)
             ^
==

[default language_features=NONE,+PIPES,+PIPE_STATIC_DESCRIBE]
from TestTable
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
==

from (from TestTable)
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
==

from unnest([1,2,3])
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-$array.$unnest1#1 AS `$unnest1` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$array.$unnest1#1]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     <unnamed> INT64 $array.$unnest1#1 (value table)
    |   NameScope:
    |     Value table columns:
    |       $array.$unnest1#1
    |   """
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.$unnest1#1]
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        +-element_column_list=[$array.$unnest1#1]
==

from TestTable, TestTable t2
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-TestTable.key#4 AS key [INT32]
| +-TestTable.TestEnum#5 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#6 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3, key#4, TestEnum#5, KitchenSink#6]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT32 TestTable.key#1
    |     TestEnum zetasql_test__.TestEnum TestTable.TestEnum#2
    |     KitchenSink zetasql_test__.KitchenSinkPB TestTable.KitchenSink#3
    |     key INT32 TestTable.key#4
    |     TestEnum zetasql_test__.TestEnum TestTable.TestEnum#5
    |     KitchenSink zetasql_test__.KitchenSinkPB TestTable.KitchenSink#6
    |   NameScope:
    |     Names:
    |       KitchenSink -> ambiguous
    |       TestEnum -> ambiguous
    |       key -> ambiguous
    |     Range variables:
    |       TestTable -> RANGE_VARIABLE<key,TestEnum,KitchenSink>
    |       t2 -> RANGE_VARIABLE<key,TestEnum,KitchenSink>
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3, key#4, TestEnum#5, KitchenSink#6]
        +-left_scan=
        | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2])
        +-right_scan=
          +-TableScan(column_list=TestTable.[key#4, TestEnum#5, KitchenSink#6], table=TestTable, column_index_list=[0, 1, 2], alias="t2")
==

# FROM of a value table produces an output value table (is_value_table=true).
from TestExtraValueTable
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
==

# Still get a value table from a subquery.
from (from TestExtraValueTable)
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
==

# Value table subquery, with or without a name.
from (select as value new zetasql_test__.TestExtraPB()){{ named|}}
|> STATIC_DESCRIBE
--
ALTERNATION GROUP:  named
--
QueryStmt
+-output_column_list=
| +-named.$col1#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[named.$col1#1]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     named zetasql_test__.TestExtraPB named.$col1#1 (value table)
    |   NameScope:
    |     Range variables:
    |       named -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       named.$col1#1
    |   """
    +-input_scan=
      +-ProjectScan
        +-column_list=[named.$col1#1]
        +-expr_list=
        | +-$col1#1 := MakeProto(type=PROTO<zetasql_test__.TestExtraPB>)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$subquery1.$col1#1 AS `$value_column` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$subquery1.$col1#1]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     <unnamed> zetasql_test__.TestExtraPB $subquery1.$col1#1 (value table)
    |   NameScope:
    |     Value table columns:
    |       $subquery1.$col1#1
    |   """
    +-input_scan=
      +-ProjectScan
        +-column_list=[$subquery1.$col1#1]
        +-expr_list=
        | +-$col1#1 := MakeProto(type=PROTO<zetasql_test__.TestExtraPB>)
        +-input_scan=
          +-SingleRowScan
==

# Struct value table subquery, with or without a name.
from (select as struct 1 x, 3){{ named|}}
--
ALTERNATION GROUP:  named
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#3 AS `$value` [STRUCT<x INT64, INT64>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#3]
    +-expr_list=
    | +-$struct#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<x INT64, INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=named.x#1)
    |       +-ColumnRef(type=INT64, column=named.$col2#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=named.[x#1, $col2#2]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=1)
        | +-$col2#2 := Literal(type=INT64, value=3)
        +-input_scan=
          +-SingleRowScan
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#3 AS `$struct` [STRUCT<x INT64, INT64>]
+-is_value_table=TRUE
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#3]
    +-expr_list=
    | +-$struct#3 :=
    |   +-MakeStruct
    |     +-type=STRUCT<x INT64, INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=$subquery1.x#1)
    |       +-ColumnRef(type=INT64, column=$subquery1.$col2#2)
    +-input_scan=
      +-ProjectScan
        +-column_list=$subquery1.[x#1, $col2#2]
        +-expr_list=
        | +-x#1 := Literal(type=INT64, value=1)
        | +-$col2#2 := Literal(type=INT64, value=3)
        +-input_scan=
          +-SingleRowScan
==

# Value table inputs, but the output with two columns is not a value table.
from TestExtraValueTable, unnest([1]) ar
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-$array.ar#4 AS ar [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[TestExtraValueTable.value#1, $array.ar#4]
    +-describe_text=
    |   """
    |   NameList:
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |     ar INT64 $array.ar#4 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |       ar -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |       $array.ar#4
    |   """
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestExtraValueTable.value#1, $array.ar#4]
        +-input_scan=
        | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1])
        +-element_column_list=[$array.ar#4]
==

from Int32ArrayValueTable t
--
QueryStmt
+-output_column_list=
| +-Int32ArrayValueTable.value#1 AS `$value` [ARRAY<INT32>]
+-is_value_table=TRUE
+-query=
  +-TableScan(column_list=[Int32ArrayValueTable.value#1], table=Int32ArrayValueTable, column_index_list=[0], alias="t")
==

from Int32ArrayValueTable t, t
--
ERROR: Table not found: t (Unqualified identifiers in a FROM clause are always resolved as tables. Identifier t is in scope but unqualified names cannot be resolved here.) [at 1:30]
from Int32ArrayValueTable t, t
                             ^
==

from Int32ArrayValueTable t, unnest(t) tt
--
QueryStmt
+-output_column_list=
| +-Int32ArrayValueTable.value#1 AS t [ARRAY<INT32>]
| +-$array.tt#2 AS tt [INT32]
+-query=
  +-ArrayScan
    +-column_list=[Int32ArrayValueTable.value#1, $array.tt#2]
    +-input_scan=
    | +-TableScan(column_list=[Int32ArrayValueTable.value#1], table=Int32ArrayValueTable, column_index_list=[0], alias="t")
    +-array_expr_list=
    | +-ColumnRef(type=ARRAY<INT32>, column=Int32ArrayValueTable.value#1)
    +-element_column_list=[$array.tt#2]
==

# Pseudo-columns from value table inputs are visible after the FROM.
# The output is still a value table.
from TestExtraValueTable
|> STATIC_DESCRIBE
|> where filename=''
|> where TestExtraValueTable.filename=''
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=TestExtraValueTable.[value#1, Filename#2]
    |   +-input_scan=
    |   | +-StaticDescribeScan
    |   |   +-column_list=TestExtraValueTable.[value#1, Filename#2]
    |   |   +-describe_text=
    |   |   |   """
    |   |   |   NameList (is_value_table = true):
    |   |   |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |   |   |   NameScope:
    |   |   |     Names:
    |   |   |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |   |   |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |   |   |     Range variables:
    |   |   |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |   |   |     Value table columns:
    |   |   |       TestExtraValueTable.value#1
    |   |   |   """
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1])
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |       +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
    |       +-Literal(type=STRING, value="")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
        +-Literal(type=STRING, value="")
==

# Read a pseudo-column from a single-table FROM with an alias.
from TestExtraValueTable v
|> where filename=''
|> where v.filename=''
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=TestExtraValueTable.[value#1, Filename#2]
    |   +-input_scan=
    |   | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="v")
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |       +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
    |       +-Literal(type=STRING, value="")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
        +-Literal(type=STRING, value="")
==

# The table name is not visible from underneath its alias.
from TestExtraValueTable v
|> where TestExtraValueTable.filename=''
--
ERROR: Unrecognized name: TestExtraValueTable [at 2:10]
|> where TestExtraValueTable.filename=''
         ^
==

# SELECT * after FROM does not produce the pseudo-columns.
from TestExtraValueTable
|> select *
--
QueryStmt
+-output_column_list=
| +-$pipe_select.int32_val1#4 AS int32_val1 [INT32]
| +-$pipe_select.int32_val2#5 AS int32_val2 [INT32]
| +-$pipe_select.str_value#6 AS str_value [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=$pipe_select.[int32_val1#4, int32_val2#5, str_value#6]
    +-expr_list=
    | +-int32_val1#4 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val1
    | |   +-default_value=0
    | +-int32_val2#5 :=
    | | +-GetProtoField
    | |   +-type=INT32
    | |   +-expr=
    | |   | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    | |   +-field_descriptor=int32_val2
    | |   +-default_value=0
    | +-str_value#6 :=
    |   +-GetProtoField
    |     +-type=ARRAY<STRING>
    |     +-expr=
    |     | +-ColumnRef(type=PROTO<zetasql_test__.TestExtraPB>, column=TestExtraValueTable.value#1)
    |     +-field_descriptor=str_value
    |     +-default_value=[]
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
==

# Projecting an extra column makes the result no longer a value table.
# The output column from the value table still has its name.
from TestExtraValueTable
|> STATIC_DESCRIBE
|> extend 1 x
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-$pipe_extend.x#4 AS x [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[TestExtraValueTable.value#1, $pipe_extend.x#4]
    +-describe_text=
    |   """
    |   NameList:
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |     x INT64 $pipe_extend.x#4
    |   NameScope:
    |     Names:
    |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |       x -> INT64 ($pipe_extend.x#4)
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |   """
    +-input_scan=
      +-ProjectScan
        +-column_list=[TestExtraValueTable.value#1, $pipe_extend.x#4]
        +-expr_list=
        | +-x#4 := Literal(type=INT64, value=1)
        +-input_scan=
          +-StaticDescribeScan
            +-column_list=[TestExtraValueTable.value#1]
            +-describe_text=
            |   """
            |   NameList (is_value_table = true):
            |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
            |   NameScope:
            |     Names:
            |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
            |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
            |     Range variables:
            |       TestExtraValueTable -> RANGE_VARIABLE<$value>
            |     Value table columns:
            |       TestExtraValueTable.value#1
            |   """
            +-input_scan=
              +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
==

# Projecting an extra column makes the result not a value table.
# Since the value table had no alias, its output column is anonymous.
from (select as struct 1 y, 2 z)
|> extend 1 x
--
QueryStmt
+-output_column_list=
| +-$make_struct.$struct#3 AS `$struct` [STRUCT<y INT64, z INT64>]
| +-$pipe_extend.x#4 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$make_struct.$struct#3, $pipe_extend.x#4]
    +-expr_list=
    | +-x#4 := Literal(type=INT64, value=1)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$make_struct.$struct#3]
        +-expr_list=
        | +-$struct#3 :=
        |   +-MakeStruct
        |     +-type=STRUCT<y INT64, z INT64>
        |     +-field_list=
        |       +-ColumnRef(type=INT64, column=$subquery1.y#1)
        |       +-ColumnRef(type=INT64, column=$subquery1.z#2)
        +-input_scan=
          +-ProjectScan
            +-column_list=$subquery1.[y#1, z#2]
            +-expr_list=
            | +-y#1 := Literal(type=INT64, value=1)
            | +-z#2 := Literal(type=INT64, value=2)
            +-input_scan=
              +-SingleRowScan
==

# Read pseudo-columns from a multi-table FROM.
from TestExtraValueTable v1, TestExtraValueTable v2
|> where v1.filename = v2.filename
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS v1 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#4 AS v2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-FilterScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2, value#4, Filename#5]
    +-input_scan=
    | +-JoinScan
    |   +-column_list=TestExtraValueTable.[value#1, Filename#2, value#4, Filename#5]
    |   +-left_scan=
    |   | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="v1")
    |   +-right_scan=
    |     +-TableScan(column_list=TestExtraValueTable.[value#4, Filename#5], table=TestExtraValueTable, column_index_list=[0, 1], alias="v2")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
        +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#5)
==

from TestExtraValueTable v1, TestExtraValueTable v2
|> where v1.filename = ''
|> where filename = ''
--
ERROR: Column name filename is ambiguous [at 3:10]
|> where filename = ''
         ^
==

# All of these value table columns keep their names in the output,
# except the last one, which is an anonymous value table.
from TestExtraValueTable v1,
     (from TestExtraValueTable),
     (from TestExtraValueTable) AS row,
     (from UNNEST([1]))
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS v1 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#4 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#7 AS `row` [PROTO<zetasql_test__.TestExtraPB>]
| +-$array.$unnest1#10 AS `$unnest1` [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[TestExtraValueTable.value#1, TestExtraValueTable.value#4, TestExtraValueTable.value#7, $array.$unnest1#10]
    +-describe_text=
    |   """
    |   NameList:
    |     v1 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#4 (value table)
    |     `row` zetasql_test__.TestExtraPB TestExtraValueTable.value#7 (value table)
    |     <unnamed> INT64 $array.$unnest1#10 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> ambiguous
    |       RowId -> ambiguous
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |       row -> RANGE_VARIABLE<$value>
    |       v1 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |       TestExtraValueTable.value#4
    |       TestExtraValueTable.value#7
    |       $array.$unnest1#10
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=[TestExtraValueTable.value#1, TestExtraValueTable.value#4, TestExtraValueTable.value#7, $array.$unnest1#10]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=TestExtraValueTable.[value#1, value#4, value#7]
        |   +-left_scan=
        |   | +-JoinScan
        |   |   +-column_list=TestExtraValueTable.[value#1, value#4]
        |   |   +-left_scan=
        |   |   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="v1")
        |   |   +-right_scan=
        |   |     +-TableScan(column_list=[TestExtraValueTable.value#4], table=TestExtraValueTable, column_index_list=[0])
        |   +-right_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#7], table=TestExtraValueTable, column_index_list=[0])
        +-right_scan=
          +-ArrayScan
            +-column_list=[$array.$unnest1#10]
            +-array_expr_list=
            | +-Literal(type=ARRAY<INT64>, value=[1])
            +-element_column_list=[$array.$unnest1#10]
==

from TestExtraValueTable v1, (from TestExtraValueTable)
|> where v1.filename = ''
|> where TestExtraValueTable.filename = ''
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS v1 [PROTO<zetasql_test__.TestExtraPB>]
| +-TestExtraValueTable.value#4 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-FilterScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2, value#4, Filename#5]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=TestExtraValueTable.[value#1, Filename#2, value#4, Filename#5]
    |   +-input_scan=
    |   | +-JoinScan
    |   |   +-column_list=TestExtraValueTable.[value#1, Filename#2, value#4, Filename#5]
    |   |   +-left_scan=
    |   |   | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="v1")
    |   |   +-right_scan=
    |   |     +-TableScan(column_list=TestExtraValueTable.[value#4, Filename#5], table=TestExtraValueTable, column_index_list=[0, 1])
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |       +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
    |       +-Literal(type=STRING, value="")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
        +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#5)
        +-Literal(type=STRING, value="")
==

# Both tables have the `filename` pseudo-column, so it's ambiguous
# when unqualified.
from TestExtraValueTable v1, (from TestExtraValueTable)
|> STATIC_DESCRIBE
|> where v1.filename = ''
|> where filename = ''
--
ERROR: Column name filename is ambiguous [at 4:10]
|> where filename = ''
         ^
==

WITH q1 AS (from KeyValue)
FROM q1
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-q1.Key#3 AS Key [INT64]
| +-q1.Value#4 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=q1.[Key#3, Value#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="q1"
    |   +-with_subquery=
    |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-query=
      +-StaticDescribeScan
        +-column_list=q1.[Key#3, Value#4]
        +-describe_text=
        |   """
        |   NameList:
        |     Key INT64 q1.Key#3
        |     Value STRING q1.Value#4
        |   NameScope:
        |     Names:
        |       Key -> INT64 (q1.Key#3) (implicit)
        |       Value -> STRING (q1.Value#4) (implicit)
        |     Range variables:
        |       q1 -> RANGE_VARIABLE<Key,Value>
        |
        |   **Common table expressions**:
        |   Name  Columns
        |   ----  ----------
        |   q1    Key, Value
        |   """
        +-input_scan=
          +-WithRefScan(column_list=q1.[Key#3, Value#4], with_query_name="q1")
==

# FROM queries in both places in a WITH clause.
WITH q1 AS (from KeyValue),
     q2 AS (select 5 key, "abc" abc)
FROM q1 JOIN q2 USING (key)
--
QueryStmt
+-output_column_list=
| +-q1.Key#5 AS key [INT64]
| +-q1.Value#6 AS Value [STRING]
| +-q2.abc#8 AS abc [STRING]
+-query=
  +-WithScan
    +-column_list=[q1.Key#5, q1.Value#6, q2.key#7, q2.abc#8]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="q1"
    | | +-with_subquery=
    | |   +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | +-WithEntry
    |   +-with_query_name="q2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=q2.[key#3, abc#4]
    |       +-expr_list=
    |       | +-key#3 := Literal(type=INT64, value=5)
    |       | +-abc#4 := Literal(type=STRING, value="abc")
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-JoinScan
        +-column_list=[q1.Key#5, q1.Value#6, q2.key#7, q2.abc#8]
        +-left_scan=
        | +-WithRefScan(column_list=q1.[Key#5, Value#6], with_query_name="q1")
        +-right_scan=
        | +-WithRefScan(column_list=q2.[key#7, abc#8], with_query_name="q2")
        +-join_expr=
        | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   +-ColumnRef(type=INT64, column=q1.Key#5)
        |   +-ColumnRef(type=INT64, column=q2.key#7)
        +-has_using=TRUE
==

# FROM queries with pipes around a WITH.
with q1 as (from KeyValue |> where key=5)
from q1 join q1 q1b using (key)
|> where q1.value = q1b.value
--
QueryStmt
+-output_column_list=
| +-q1.Key#3 AS key [INT64]
| +-q1.Value#4 AS Value [STRING]
| +-q1.Value#6 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=q1.[Key#3, Value#4, Key#5, Value#6]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="q1"
    |   +-with_subquery=
    |     +-FilterScan
    |       +-column_list=KeyValue.[Key#1, Value#2]
    |       +-input_scan=
    |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |           +-Literal(type=INT64, value=5)
    +-query=
      +-FilterScan
        +-column_list=q1.[Key#3, Value#4, Key#5, Value#6]
        +-input_scan=
        | +-JoinScan
        |   +-column_list=q1.[Key#3, Value#4, Key#5, Value#6]
        |   +-left_scan=
        |   | +-WithRefScan(column_list=q1.[Key#3, Value#4], with_query_name="q1")
        |   +-right_scan=
        |   | +-WithRefScan(column_list=q1.[Key#5, Value#6], with_query_name="q1")
        |   +-join_expr=
        |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   +-ColumnRef(type=INT64, column=q1.Key#3)
        |   |   +-ColumnRef(type=INT64, column=q1.Key#5)
        |   +-has_using=TRUE
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=q1.Value#4)
            +-ColumnRef(type=STRING, column=q1.Value#6)
==

# Test FROM query with hinted value table.
FROM TestExtraValueTable @{hint=1}
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TableScan
    +-column_list=[TestExtraValueTable.value#1]
    +-hint_list=
    | +-hint := Literal(type=INT64, value=1)
    +-table=TestExtraValueTable
    +-column_index_list=[0]
==

[language_features=NONE,+PIPES,+TABLESAMPLE]
# Test FROM query with TABLESAMPLE on a value table.
FROM TestExtraValueTable TABLESAMPLE bernoulli(5 ROWS)
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-SampleScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-method="bernoulli"
    +-size=
    | +-Literal(type=INT64, value=5)
    +-unit=ROWS
==

[language_features=NONE,+PIPES,+PIVOT]
# Test FROM query with PIVOT postfix operator.
FROM KeyValue PIVOT(sum(key) FOR value IN ('x'))
--
QueryStmt
+-output_column_list=
| +-$pivot.x#4 AS x [INT64]
+-query=
  +-PivotScan
    +-column_list=[$pivot.x#4]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-pivot_expr_list=
    | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |   +-parse_location=67-75
    |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    +-for_expr=
    | +-ColumnRef(parse_location=80-85, type=STRING, column=KeyValue.Value#2)
    +-pivot_value_list=
    | +-Literal(type=STRING, value="x", preserve_in_literal_remover=TRUE)
    +-pivot_column_list=
      +-PivotColumn(column=$pivot.x#4, pivot_expr_index=0, pivot_value_index=0)
==

# CTAS is another statement with a different code path for handling
# output_column_list and is_value_table.
create table T as
from TestExtraValueTable
|> where true
--
CreateTableAsSelectStmt
+-name_path=T
+-column_definition_list=
| +-ColumnDefinition(name="$value", type=PROTO<zetasql_test__.TestExtraPB>, column=T.TestExtraValueTable#4)
+-is_value_table=TRUE
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-FilterScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-filter_expr=
      +-Literal(type=BOOL, value=true)
==

# CTAS with a column list is a different case, but does not support
# value tables.
[language_features=NONE,+PIPES,+CREATE_TABLE_AS_SELECT_COLUMN_LIST]
create table T (col zetasql_test__.TestExtraPB) as
from TestExtraValueTable v
|> select v
--
CreateTableAsSelectStmt
+-name_path=T
+-column_definition_list=
| +-ColumnDefinition(name="col", type=PROTO<zetasql_test__.TestExtraPB>, column=T.col#1)
+-output_column_list=
| +-TestExtraValueTable.value#2 AS col [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[TestExtraValueTable.value#2]
    +-input_scan=
      +-TableScan(column_list=[TestExtraValueTable.value#2], table=TestExtraValueTable, column_index_list=[0], alias="v")
==

# CREATE VIEW is another statement with a different code path for handling
# output_column_list and is_value_table.
create view V as
from TestExtraValueTable
|> where true
--
CreateViewStmt
+-name_path=V
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
| +-FilterScan
|   +-column_list=[TestExtraValueTable.value#1]
|   +-input_scan=
|   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
|   +-filter_expr=
|     +-Literal(type=BOOL, value=true)
+-sql="from TestExtraValueTable\n|> where true"
+-is_value_table=TRUE
+-column_definition_list=
  +-ColumnDefinition(name="$value", type=PROTO<zetasql_test__.TestExtraPB>, column=V.TestExtraValueTable#4)
==

# EXPORT DATA is another statement with a different code path for handling
# output_column_list and is_value_table.
export data options() as
from TestExtraValueTable
|> where true
--
ExportDataStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-filter_expr=
      +-Literal(type=BOOL, value=true)
==

# CREATE MODEL is another statement with a different code path for handling
# output_column_list.  It does not record is_value_table.
create model M as
from TestExtraValueTable
|> where true
--
CreateModelStmt
+-name_path=M
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-FilterScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-filter_expr=
      +-Literal(type=BOOL, value=true)
==

# CREATE TVF is another statement with a different code path for handling
# output_column_list and is_value_table.
[language_features=NONE,+PIPES,+CREATE_TABLE_FUNCTION]
create table function TVF() AS (
  from TestExtraValueTable
  |> where true
)
--
CreateTableFunctionStmt
+-name_path=TVF
+-signature=() -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
+-language="SQL"
+-code="from TestExtraValueTable\n  |> where true"
+-query=
| +-FilterScan
|   +-column_list=[TestExtraValueTable.value#1]
|   +-input_scan=
|   | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
|   +-filter_expr=
|     +-Literal(type=BOOL, value=true)
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
==

# CREATE TVF with a non-value-table.
[language_features=NONE,+PIPES,+CREATE_TABLE_FUNCTION]
create table function TVF() AS (
  from KeyValue
  |> where true
)
--
CreateTableFunctionStmt
+-name_path=TVF
+-signature=() -> TABLE<Key INT64, Value STRING>
+-language="SQL"
+-code="from KeyValue\n  |> where true"
+-query=
| +-FilterScan
|   +-column_list=KeyValue.[Key#1, Value#2]
|   +-input_scan=
|   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
|   +-filter_expr=
|     +-Literal(type=BOOL, value=true)
+-output_column_list=
  +-KeyValue.Key#1 AS Key [INT64]
  +-KeyValue.Value#2 AS Value [STRING]
==

# There's no way for range variables to escape a table subquery
# with SELECT, since SELECT removes them.
SELECT kv.key FROM (SELECT * FROM KeyValue kv)
--
ERROR: Unrecognized name: kv [at 1:8]
SELECT kv.key FROM (SELECT * FROM KeyValue kv)
       ^
==

# With FROM in a table subquery, the range variable escapes.
SELECT key, kv.key FROM (FROM KeyValue kv)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#1]
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv")
==

# Inner range variable is hidden if we have an outer one.
SELECT {{key, kv2.key, kv2|kv.key|kv}} FROM (FROM KeyValue kv) kv2
--
ALTERNATION GROUP: key, kv2.key, kv2
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key [INT64]
| +-$query.kv2#4 AS kv2 [STRUCT<Key INT64, Value STRING>]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Key#1, $query.kv2#4]
    +-expr_list=
    | +-kv2#4 :=
    |   +-MakeStruct
    |     +-type=STRUCT<Key INT64, Value STRING>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv")
--
ALTERNATION GROUP: kv.key
--
ERROR: Unrecognized name: kv [at 1:8]
SELECT kv.key FROM (FROM KeyValue kv) kv2
       ^
--
ALTERNATION GROUP: kv
--
ERROR: Unrecognized name: kv [at 1:8]
SELECT kv FROM (FROM KeyValue kv) kv2
       ^
==

# Nested range variable does not work.
SELECT kv2.key, {{kv2.kv|kv2.kv.key}} FROM (FROM KeyValue kv) kv2
--
ALTERNATION GROUP: kv2.kv
--
ERROR: Name kv not found inside kv2 [at 1:21]
SELECT kv2.key, kv2.kv FROM (FROM KeyValue kv) kv2
                    ^
--
ALTERNATION GROUP: kv2.kv.key
--
ERROR: Name kv not found inside kv2 [at 1:21]
SELECT kv2.key, kv2.kv.key FROM (FROM KeyValue kv) kv2
                    ^
==

# Range variables come out even if we have multiple tables.
SELECT kv1.key, kv2.key
FROM (FROM KeyValue kv1, KeyValue kv2)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#3 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#3]
    +-input_scan=
      +-JoinScan
        +-column_list=KeyValue.[Key#1, Key#3]
        +-left_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0], alias="kv1")
        +-right_scan=
          +-TableScan(column_list=[KeyValue.Key#3], table=KeyValue, column_index_list=[0], alias="kv2")
==

# Same thing visible in pipe operators.
(FROM KeyValue kv1, KeyValue kv2)
|> WHERE kv1.key = kv2.key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-KeyValue.Key#3 AS Key [INT64]
| +-KeyValue.Value#4 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    +-input_scan=
    | +-JoinScan
    |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
    |   +-left_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
    |   +-right_scan=
    |     +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="kv2")
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-ColumnRef(type=INT64, column=KeyValue.Key#3)
==

# Case with inner range variable, an outer range variable, and
# pseudo-columns (`Filename`).
SELECT row.value, value, filename, row.filename
FROM (FROM EnumTable t1, KeyValue kv) row
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#7 AS value [STRING]
| +-KeyValue.Value#7 AS value [STRING]
| +-EnumTable.Filename#4 AS filename [STRING]
| +-EnumTable.Filename#4 AS filename [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Value#7, KeyValue.Value#7, EnumTable.Filename#4, EnumTable.Filename#4]
    +-input_scan=
      +-JoinScan
        +-column_list=[EnumTable.Filename#4, KeyValue.Value#7]
        +-left_scan=
        | +-TableScan(column_list=[EnumTable.Filename#4], table=EnumTable, column_index_list=[3], alias="t1")
        +-right_scan=
          +-TableScan(column_list=[KeyValue.Value#7], table=KeyValue, column_index_list=[1], alias="kv")
==

# Same thing in pipe syntax.
FROM (FROM EnumTable t1, KeyValue kv) row
|> SELECT row.value, value, filename, row.filename
--
[SAME AS PREVIOUS]
==

# Error cases from above query.
SELECT {{t1.filename|kv.value}}
FROM (FROM EnumTable t1, KeyValue kv) row
--
ALTERNATION GROUP: t1.filename
--
ERROR: Unrecognized name: t1 [at 1:8]
SELECT t1.filename
       ^
--
ALTERNATION GROUP: kv.value
--
ERROR: Unrecognized name: kv [at 1:8]
SELECT kv.value
       ^
==

# Same error cases in pipe syntax.
FROM (FROM EnumTable t1, KeyValue kv) row
|> SELECT {{t1.filename|kv.value}}
--
ALTERNATION GROUP: t1.filename
--
ERROR: Unrecognized name: t1 [at 2:11]
|> SELECT t1.filename
          ^
--
ALTERNATION GROUP: kv.value
--
ERROR: Unrecognized name: kv [at 2:11]
|> SELECT kv.value
          ^
==

# Test for ExtractTableNames, that it identifies all of these
# range variables correctly as array references rather than tables.
FROM (FROM TestTable tt, (FROM ArrayTypes ar))
|> JOIN tt.KitchenSink.repeated_bool_val b1
|> JOIN ar.Int32Array i1
|> SELECT b1, i1, tt.key, ar.FloatArray
--
QueryStmt
+-output_column_list=
| +-$array.b1#24 AS b1 [BOOL]
| +-$array.i1#25 AS i1 [INT32]
| +-TestTable.key#1 AS key [INT32]
| +-ArrayTypes.FloatArray#11 AS FloatArray [ARRAY<FLOAT>]
+-query=
  +-ProjectScan
    +-column_list=[$array.b1#24, $array.i1#25, TestTable.key#1, ArrayTypes.FloatArray#11]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11, $array.b1#24, $array.i1#25]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11, $array.b1#24]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11]
        |   |   +-left_scan=
        |   |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   |   +-right_scan=
        |   |     +-TableScan(column_list=ArrayTypes.[Int32Array#4, FloatArray#11], table=ArrayTypes, column_index_list=[0, 7], alias="ar")
        |   +-array_expr_list=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<BOOL>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=repeated_bool_val
        |   |   +-default_value=[]
        |   +-element_column_list=[$array.b1#24]
        +-array_expr_list=
        | +-ColumnRef(type=ARRAY<INT32>, column=ArrayTypes.Int32Array#4)
        +-element_column_list=[$array.i1#25]
==

# Same thing, but with a table alias.
FROM (FROM TestTable tt, (FROM ArrayTypes ar)) AS row
|> JOIN row.KitchenSink.repeated_bool_val b1
|> JOIN row.Int32Array i1
|> SELECT b1, i1, row.key, row.FloatArray
--
QueryStmt
+-output_column_list=
| +-$array.b1#24 AS b1 [BOOL]
| +-$array.i1#25 AS i1 [INT32]
| +-TestTable.key#1 AS key [INT32]
| +-ArrayTypes.FloatArray#11 AS FloatArray [ARRAY<FLOAT>]
+-query=
  +-ProjectScan
    +-column_list=[$array.b1#24, $array.i1#25, TestTable.key#1, ArrayTypes.FloatArray#11]
    +-input_scan=
      +-ArrayScan
        +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11, $array.b1#24, $array.i1#25]
        +-input_scan=
        | +-ArrayScan
        |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11, $array.b1#24]
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[TestTable.key#1, TestTable.KitchenSink#3, ArrayTypes.Int32Array#4, ArrayTypes.FloatArray#11]
        |   |   +-left_scan=
        |   |   | +-TableScan(column_list=TestTable.[key#1, KitchenSink#3], table=TestTable, column_index_list=[0, 2], alias="tt")
        |   |   +-right_scan=
        |   |     +-TableScan(column_list=ArrayTypes.[Int32Array#4, FloatArray#11], table=ArrayTypes, column_index_list=[0, 7], alias="ar")
        |   +-array_expr_list=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<BOOL>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=repeated_bool_val
        |   |   +-default_value=[]
        |   +-element_column_list=[$array.b1#24]
        +-array_expr_list=
        | +-ColumnRef(type=ARRAY<INT32>, column=ArrayTypes.Int32Array#4)
        +-element_column_list=[$array.i1#25]
==

# Test for ExtractTableNames, that it realizes the nested_catalog
# inner range variable is dropped, so nested_catalog in the JOIN
# is actually a catalog name.
FROM (FROM TestTable nested_catalog, KeyValue kv) row
|> CROSS JOIN nested_catalog.KeyValueNested kvn
--
QueryStmt
+-output_column_list=
| +-TestTable.key#1 AS key [INT32]
| +-TestTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-TestTable.KitchenSink#3 AS KitchenSink [PROTO<zetasql_test__.KitchenSinkPB>]
| +-KeyValue.Key#4 AS Key [INT64]
| +-KeyValue.Value#5 AS Value [STRING]
| +-KeyValueNested.Key#6 AS Key [INT64]
| +-KeyValueNested.Value#7 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, KeyValue.Key#4, KeyValue.Value#5, KeyValueNested.Key#6, KeyValueNested.Value#7]
    +-left_scan=
    | +-JoinScan
    |   +-column_list=[TestTable.key#1, TestTable.TestEnum#2, TestTable.KitchenSink#3, KeyValue.Key#4, KeyValue.Value#5]
    |   +-left_scan=
    |   | +-TableScan(column_list=TestTable.[key#1, TestEnum#2, KitchenSink#3], table=TestTable, column_index_list=[0, 1, 2], alias="nested_catalog")
    |   +-right_scan=
    |     +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1], alias="kv")
    +-right_scan=
      +-TableScan(column_list=KeyValueNested.[Key#6, Value#7], table=nested_catalog.KeyValueNested, column_index_list=[0, 1], alias="kvn")
==

# Case with ambiguous columns and pseudo-columns.
SELECT {{key|filename|row.key|row.filename|t1.key}}
FROM (FROM EnumTable t1, EnumTable t2) row
--
ALTERNATION GROUP: key
--
ERROR: Column name key is ambiguous [at 1:8]
SELECT key
       ^
--
ALTERNATION GROUP: filename
--
ERROR: Column name filename is ambiguous [at 1:8]
SELECT filename
       ^
--
ALTERNATION GROUP: row.key
--
ERROR: Name key is ambiguous inside row [at 1:12]
SELECT row.key
           ^
--
ALTERNATION GROUP: row.filename
--
ERROR: Name filename is ambiguous inside row [at 1:12]
SELECT row.filename
           ^
--
ALTERNATION GROUP: t1.key
--
ERROR: Unrecognized name: t1 [at 1:8]
SELECT t1.key
       ^
==

# Case with duplicate range variable coming from two subqueries.
{{SELECT *|}}
FROM (FROM EnumTable), (FROM EnumTable)
--
ALTERNATION GROUP: SELECT *
--
ERROR: Duplicate table alias EnumTable in the same FROM clause [at 2:24]
FROM (FROM EnumTable), (FROM EnumTable)
                       ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Duplicate table alias EnumTable in the same FROM clause [at 1:24]
FROM (FROM EnumTable), (FROM EnumTable)
                       ^
==

# The inner range variables propagate out of the subqueries, and cause
# a collision.
{{SELECT *|}} FROM
  (FROM EnumTable), (FROM EnumTable)
--
ERROR: Duplicate table alias EnumTable in the same FROM clause [at 2:21]
  (FROM EnumTable), (FROM EnumTable)
                    ^
==

# The inner range variables are replaced by new aliases that are different,
# so there is no collison.
FROM (FROM EnumTable) row1, (FROM EnumTable) row2
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-EnumTable.key#1 AS key [INT32]
| +-EnumTable.TestEnum#2 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-EnumTable.AnotherTestEnum#3 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
| +-EnumTable.key#6 AS key [INT32]
| +-EnumTable.TestEnum#7 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-EnumTable.AnotherTestEnum#8 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
+-query=
  +-StaticDescribeScan
    +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, key#6, TestEnum#7, AnotherTestEnum#8]
    +-describe_text=
    |   """
    |   NameList:
    |     key INT32 EnumTable.key#1
    |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#2
    |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#3
    |     key INT32 EnumTable.key#6
    |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#7
    |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#8
    |   NameScope:
    |     Names:
    |       AnotherTestEnum -> ambiguous
    |       Filename -> ambiguous
    |       RowId -> ambiguous
    |       TestEnum -> ambiguous
    |       key -> ambiguous
    |     Range variables:
    |       row1 -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |       row2 -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, key#6, TestEnum#7, AnotherTestEnum#8]
        +-left_scan=
        | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
        +-right_scan=
          +-TableScan(column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8], table=EnumTable, column_index_list=[0, 1, 2])
==

# Those collisions always happen for value tables, since the value table name
# always comes out as a range variable, even with a new alias for the subquery.
# This passes if either the value table is re-aliased, or the row is aliases,
# which makes the value table name a column name rather than a range variable.
FROM (FROM KeyValue kv1, TestExtraValueTable),
     (FROM KeyValue kv2, TestExtraValueTable {{|AS vt2}}){{| AS row}}
|> STATIC_DESCRIBE
--
ALTERNATION GROUP: <empty>
--
ERROR: Duplicate table alias TestExtraValueTable in the same FROM clause [at 2:6]
     (FROM KeyValue kv2, TestExtraValueTable )
     ^
--
ALTERNATION GROUP:  AS row
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-TestExtraValueTable.value#3 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-KeyValue.Key#6 AS Key [INT64]
| +-KeyValue.Value#7 AS Value [STRING]
| +-TestExtraValueTable.value#8 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#3 (value table)
    |     Key INT64 KeyValue.Key#6
    |     Value STRING KeyValue.Value#7
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#8 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> ambiguous
    |       Key -> ambiguous
    |       RowId -> ambiguous
    |       Value -> ambiguous
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |       kv1 -> RANGE_VARIABLE<Key,Value>
    |       row -> RANGE_VARIABLE<Key,Value,TestExtraValueTable>
    |     Value table columns:
    |       TestExtraValueTable.value#3
    |       TestExtraValueTable.value#8
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        |   +-right_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0])
        +-right_scan=
          +-JoinScan
            +-column_list=[KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
            +-left_scan=
            | +-TableScan(column_list=KeyValue.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1], alias="kv2")
            +-right_scan=
              +-TableScan(column_list=[TestExtraValueTable.value#8], table=TestExtraValueTable, column_index_list=[0])
--
ALTERNATION GROUP: AS vt2,
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-TestExtraValueTable.value#3 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-KeyValue.Key#6 AS Key [INT64]
| +-KeyValue.Value#7 AS Value [STRING]
| +-TestExtraValueTable.value#8 AS vt2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#3 (value table)
    |     Key INT64 KeyValue.Key#6
    |     Value STRING KeyValue.Value#7
    |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#8 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> ambiguous
    |       Key -> ambiguous
    |       RowId -> ambiguous
    |       Value -> ambiguous
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |       kv1 -> RANGE_VARIABLE<Key,Value>
    |       kv2 -> RANGE_VARIABLE<Key,Value>
    |       vt2 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#3
    |       TestExtraValueTable.value#8
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        |   +-right_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0])
        +-right_scan=
          +-JoinScan
            +-column_list=[KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
            +-left_scan=
            | +-TableScan(column_list=KeyValue.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1], alias="kv2")
            +-right_scan=
              +-TableScan(column_list=[TestExtraValueTable.value#8], table=TestExtraValueTable, column_index_list=[0], alias="vt2")
--
ALTERNATION GROUP: AS vt2, AS row
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-TestExtraValueTable.value#3 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-KeyValue.Key#6 AS Key [INT64]
| +-KeyValue.Value#7 AS Value [STRING]
| +-TestExtraValueTable.value#8 AS vt2 [PROTO<zetasql_test__.TestExtraPB>]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     TestExtraValueTable zetasql_test__.TestExtraPB TestExtraValueTable.value#3 (value table)
    |     Key INT64 KeyValue.Key#6
    |     Value STRING KeyValue.Value#7
    |     vt2 zetasql_test__.TestExtraPB TestExtraValueTable.value#8 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> ambiguous
    |       Key -> ambiguous
    |       RowId -> ambiguous
    |       Value -> ambiguous
    |       vt2 -> zetasql_test__.TestExtraPB (TestExtraValueTable.value#8)
    |     Range variables:
    |       TestExtraValueTable -> RANGE_VARIABLE<$value>
    |       kv1 -> RANGE_VARIABLE<Key,Value>
    |       row -> RANGE_VARIABLE<Key,Value,vt2>
    |     Value table columns:
    |       TestExtraValueTable.value#3
    |       TestExtraValueTable.value#8
    |   """
    +-input_scan=
      +-JoinScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3, KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
        +-left_scan=
        | +-JoinScan
        |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, TestExtraValueTable.value#3]
        |   +-left_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="kv1")
        |   +-right_scan=
        |     +-TableScan(column_list=[TestExtraValueTable.value#3], table=TestExtraValueTable, column_index_list=[0])
        +-right_scan=
          +-JoinScan
            +-column_list=[KeyValue.Key#6, KeyValue.Value#7, TestExtraValueTable.value#8]
            +-left_scan=
            | +-TableScan(column_list=KeyValue.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1], alias="kv2")
            +-right_scan=
              +-TableScan(column_list=[TestExtraValueTable.value#8], table=TestExtraValueTable, column_index_list=[0], alias="vt2")
==

# Multi-table FROM inside a WITH clause.
# Column names are visible outside. `key` is ambiguous.
WITH q AS (FROM EnumTable et, KeyValue kv)
SELECT TestEnum, value, q.TestEnum, q.value{{|,key|,q.key}}
FROM q
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-q.TestEnum#9 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-q.Value#12 AS value [STRING]
| +-q.TestEnum#9 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-q.Value#12 AS value [STRING]
+-query=
  +-WithScan
    +-column_list=q.[TestEnum#9, Value#12, TestEnum#9, Value#12]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="q"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, KeyValue.Key#6, KeyValue.Value#7]
    |       +-input_scan=
    |         +-JoinScan
    |           +-column_list=[EnumTable.key#1, EnumTable.TestEnum#2, EnumTable.AnotherTestEnum#3, KeyValue.Key#6, KeyValue.Value#7]
    |           +-left_scan=
    |           | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2], alias="et")
    |           +-right_scan=
    |             +-TableScan(column_list=KeyValue.[Key#6, Value#7], table=KeyValue, column_index_list=[0, 1], alias="kv")
    +-query=
      +-ProjectScan
        +-column_list=q.[TestEnum#9, Value#12, TestEnum#9, Value#12]
        +-input_scan=
          +-WithRefScan(column_list=q.[key#8, TestEnum#9, AnotherTestEnum#10, Key#11, Value#12], with_query_name="q")
--
ALTERNATION GROUP: ,key
--
ERROR: Column name key is ambiguous [at 2:45]
SELECT TestEnum, value, q.TestEnum, q.value,key
                                            ^
--
ALTERNATION GROUP: ,q.key
--
ERROR: Name key is ambiguous inside q [at 2:47]
SELECT TestEnum, value, q.TestEnum, q.value,q.key
                                              ^
==

# Range variables from inside the WITH subquery do not escape it.
WITH q AS (FROM EnumTable et, KeyValue kv)
SELECT TestEnum, value, {{et.TestEnum|kv.key|et|kv}}
FROM q
--
ALTERNATION GROUP: et.TestEnum
--
ERROR: Unrecognized name: et [at 2:25]
SELECT TestEnum, value, et.TestEnum
                        ^
--
ALTERNATION GROUP: kv.key
--
ERROR: Unrecognized name: kv [at 2:25]
SELECT TestEnum, value, kv.key
                        ^
--
ALTERNATION GROUP: et
--
ERROR: Unrecognized name: et [at 2:25]
SELECT TestEnum, value, et
                        ^
--
ALTERNATION GROUP: kv
--
ERROR: Unrecognized name: kv [at 2:25]
SELECT TestEnum, value, kv
                        ^
==

# A FROM query in WITH may produce pseudo-columns (`Filename`), but they
# don't escape the WITH.
WITH q AS (FROM EnumTable et, KeyValue kv
           |> WHERE Filename='abc')
SELECT value, q.TestEnum, {{Filename|et.Filename|q.Filename}}
FROM q
--
ALTERNATION GROUP: Filename
--
ERROR: Unrecognized name: Filename [at 3:27]
SELECT value, q.TestEnum, Filename
                          ^
--
ALTERNATION GROUP: et.Filename
--
ERROR: Unrecognized name: et [at 3:27]
SELECT value, q.TestEnum, et.Filename
                          ^
--
ALTERNATION GROUP: q.Filename
--
ERROR: Name Filename not found inside q [at 3:29]
SELECT value, q.TestEnum, q.Filename
                            ^
==

# This shows the full NameList produced by the WITH ref, when the inner query
# had a pseudo-column.  The pseudo-column does not come out.
# Note the ProjectScan added inside the WITH subquery to drop
# the pseudo-columns from the column_list.
WITH q AS (FROM EnumTable et
           |> STATIC_DESCRIBE
           |> WHERE filename='')
FROM q
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-q.key#6 AS key [INT32]
| +-q.TestEnum#7 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-q.AnotherTestEnum#8 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
+-query=
  +-WithScan
    +-column_list=q.[key#6, TestEnum#7, AnotherTestEnum#8]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="q"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
    |       +-input_scan=
    |         +-FilterScan
    |           +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4]
    |           +-input_scan=
    |           | +-StaticDescribeScan
    |           |   +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4]
    |           |   +-describe_text=
    |           |   |   """
    |           |   |   NameList:
    |           |   |     key INT32 EnumTable.key#1
    |           |   |     TestEnum zetasql_test__.TestEnum EnumTable.TestEnum#2
    |           |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum EnumTable.AnotherTestEnum#3
    |           |   |   NameScope:
    |           |   |     Names:
    |           |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (EnumTable.AnotherTestEnum#3) (implicit)
    |           |   |       Filename -> STRING (EnumTable.Filename#4) (implicit) (pseudo-column)
    |           |   |       RowId -> BYTES (EnumTable.RowId#5) (implicit) (pseudo-column)
    |           |   |       TestEnum -> zetasql_test__.TestEnum (EnumTable.TestEnum#2) (implicit)
    |           |   |       key -> INT32 (EnumTable.key#1) (implicit)
    |           |   |     Range variables:
    |           |   |       et -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |           |   |   """
    |           |   +-input_scan=
    |           |     +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4], table=EnumTable, column_index_list=[0, 1, 2, 3], alias="et")
    |           +-filter_expr=
    |             +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |               +-ColumnRef(type=STRING, column=EnumTable.Filename#4)
    |               +-Literal(type=STRING, value="")
    +-query=
      +-StaticDescribeScan
        +-column_list=q.[key#6, TestEnum#7, AnotherTestEnum#8]
        +-describe_text=
        |   """
        |   NameList:
        |     key INT32 q.key#6
        |     TestEnum zetasql_test__.TestEnum q.TestEnum#7
        |     AnotherTestEnum zetasql_test__.AnotherTestEnum q.AnotherTestEnum#8
        |   NameScope:
        |     Names:
        |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (q.AnotherTestEnum#8) (implicit)
        |       TestEnum -> zetasql_test__.TestEnum (q.TestEnum#7) (implicit)
        |       key -> INT32 (q.key#6) (implicit)
        |     Range variables:
        |       q -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
        |
        |   **Common table expressions**:
        |   Name  Columns
        |   ----  ------------------------------
        |   q     key, TestEnum, AnotherTestEnum
        |   """
        +-input_scan=
          +-WithRefScan(column_list=q.[key#6, TestEnum#7, AnotherTestEnum#8], with_query_name="q")
==

# Test a WITH RECURSIVE case with pseudo-columns, which has a different code
# path for making the SetOperationItems.
# The pseudo-columns are pruned from the column_lists.
[language_features=NONE,+PIPES,+WITH_RECURSIVE,+PIPE_STATIC_DESCRIBE]
WITH RECURSIVE q AS ((FROM EnumTable
                      |> WHERE Filename='x')
                     UNION ALL
                     (FROM q
                      |> WHERE true))
FROM q
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-q.key#12 AS key [INT32]
| +-q.TestEnum#13 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-q.AnotherTestEnum#14 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
+-query=
  +-WithScan
    +-column_list=q.[key#12, TestEnum#13, AnotherTestEnum#14]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="q"
    |   +-with_subquery=
    |     +-RecursiveScan
    |       +-column_list=$union_all.[key#6, TestEnum#7, AnotherTestEnum#8]
    |       +-op_type=UNION_ALL
    |       +-non_recursive_term=
    |       | +-SetOperationItem
    |       |   +-scan=
    |       |   | +-FilterScan
    |       |   |   +-column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4]
    |       |   |   +-input_scan=
    |       |   |   | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3, Filename#4], table=EnumTable, column_index_list=[0, 1, 2, 3])
    |       |   |   +-filter_expr=
    |       |   |     +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |       |   |       +-ColumnRef(type=STRING, column=EnumTable.Filename#4)
    |       |   |       +-Literal(type=STRING, value="x")
    |       |   +-output_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
    |       +-recursive_term=
    |         +-SetOperationItem
    |           +-scan=
    |           | +-FilterScan
    |           |   +-column_list=q.[key#9, TestEnum#10, AnotherTestEnum#11]
    |           |   +-input_scan=
    |           |   | +-RecursiveRefScan(column_list=q.[key#9, TestEnum#10, AnotherTestEnum#11])
    |           |   +-filter_expr=
    |           |     +-Literal(type=BOOL, value=true)
    |           +-output_column_list=q.[key#9, TestEnum#10, AnotherTestEnum#11]
    +-query=
    | +-StaticDescribeScan
    |   +-column_list=q.[key#12, TestEnum#13, AnotherTestEnum#14]
    |   +-describe_text=
    |   |   """
    |   |   NameList:
    |   |     key INT32 q.key#12
    |   |     TestEnum zetasql_test__.TestEnum q.TestEnum#13
    |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum q.AnotherTestEnum#14
    |   |   NameScope:
    |   |     Names:
    |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum (q.AnotherTestEnum#14) (implicit)
    |   |       TestEnum -> zetasql_test__.TestEnum (q.TestEnum#13) (implicit)
    |   |       key -> INT32 (q.key#12) (implicit)
    |   |     Range variables:
    |   |       q -> RANGE_VARIABLE<key,TestEnum,AnotherTestEnum>
    |   |
    |   |   **Common table expressions**:
    |   |   Name  Columns
    |   |   ----  ------------------------------
    |   |   q     key, TestEnum, AnotherTestEnum
    |   |   """
    |   +-input_scan=
    |     +-WithRefScan(column_list=q.[key#12, TestEnum#13, AnotherTestEnum#14], with_query_name="q")
    +-recursive=TRUE
==

# FROM doing an array scan of column and field path on a table.
[language_features=NONE,+PIPES,+SINGLE_TABLE_NAME_ARRAY_PATH,+PIPE_STATIC_DESCRIBE]
from TestTable.KitchenSink.nested_value.nested_repeated_int64
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-$array.nested_repeated_int64#4 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$array.nested_repeated_int64#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     nested_repeated_int64 INT64 $array.nested_repeated_int64#4 (value table)
    |   NameScope:
    |     Range variables:
    |       nested_repeated_int64 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $array.nested_repeated_int64#4
    |   """
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.nested_repeated_int64#4]
        +-node_source="single_table_array_name_path"
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-array_expr_list=
        | +-GetProtoField
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-GetProtoField
        |   |   +-type=PROTO<zetasql_test__.KitchenSinkPB.Nested>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_value
        |   |   +-default_value=NULL
        |   +-field_descriptor=nested_repeated_int64
        |   +-default_value=[]
        +-element_column_list=[$array.nested_repeated_int64#4]
==

# FROM doing an array scan of column and field path on a table, with flattening.
[language_features=NONE,+PIPES,+SINGLE_TABLE_NAME_ARRAY_PATH,+UNNEST_AND_FLATTEN_ARRAYS,+PIPE_STATIC_DESCRIBE]
from TestTable.KitchenSink.nested_repeated_value.nested_repeated_int64
|> STATIC_DESCRIBE
--
QueryStmt
+-output_column_list=
| +-$array.nested_repeated_int64#4 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=[$array.nested_repeated_int64#4]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     nested_repeated_int64 INT64 $array.nested_repeated_int64#4 (value table)
    |   NameScope:
    |     Range variables:
    |       nested_repeated_int64 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       $array.nested_repeated_int64#4
    |   """
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.nested_repeated_int64#4]
        +-node_source="single_table_array_name_path"
        +-input_scan=
        | +-TableScan(column_list=[TestTable.KitchenSink#3], table=TestTable, column_index_list=[2])
        +-array_expr_list=
        | +-Flatten
        |   +-type=ARRAY<INT64>
        |   +-expr=
        |   | +-GetProtoField
        |   |   +-type=ARRAY<PROTO<zetasql_test__.KitchenSinkPB.Nested>>
        |   |   +-expr=
        |   |   | +-ColumnRef(type=PROTO<zetasql_test__.KitchenSinkPB>, column=TestTable.KitchenSink#3)
        |   |   +-field_descriptor=nested_repeated_value
        |   |   +-default_value=[]
        |   +-get_field_list=
        |     +-GetProtoField
        |       +-type=ARRAY<INT64>
        |       +-expr=
        |       | +-FlattenedArg(type=PROTO<zetasql_test__.KitchenSinkPB.Nested>)
        |       +-field_descriptor=nested_repeated_int64
        |       +-default_value=[]
        +-element_column_list=[$array.nested_repeated_int64#4]
==

# Set operation over FROM queries must preserve their column_lists.
# Pseudo-columns don't make it through UNION ALL.
(FROM EnumTable)
UNION ALL
(FROM EnumTable)
|> STATIC_DESCRIBE
|> WHERE {{key|filename}} IS NULL
--
ALTERNATION GROUP: key
--
QueryStmt
+-output_column_list=
| +-$union_all.key#11 AS key [INT32]
| +-$union_all.TestEnum#12 AS TestEnum [ENUM<zetasql_test__.TestEnum>]
| +-$union_all.AnotherTestEnum#13 AS AnotherTestEnum [ENUM<zetasql_test__.AnotherTestEnum>]
+-query=
  +-FilterScan
    +-column_list=$union_all.[key#11, TestEnum#12, AnotherTestEnum#13]
    +-input_scan=
    | +-StaticDescribeScan
    |   +-column_list=$union_all.[key#11, TestEnum#12, AnotherTestEnum#13]
    |   +-describe_text=
    |   |   """
    |   |   NameList:
    |   |     key INT32 $union_all.key#11
    |   |     TestEnum zetasql_test__.TestEnum $union_all.TestEnum#12
    |   |     AnotherTestEnum zetasql_test__.AnotherTestEnum $union_all.AnotherTestEnum#13
    |   |   NameScope:
    |   |     Names:
    |   |       AnotherTestEnum -> zetasql_test__.AnotherTestEnum ($union_all.AnotherTestEnum#13) (implicit)
    |   |       TestEnum -> zetasql_test__.TestEnum ($union_all.TestEnum#12) (implicit)
    |   |       key -> INT32 ($union_all.key#11) (implicit)
    |   |   """
    |   +-input_scan=
    |     +-SetOperationScan
    |       +-column_list=$union_all.[key#11, TestEnum#12, AnotherTestEnum#13]
    |       +-op_type=UNION_ALL
    |       +-input_item_list=
    |         +-SetOperationItem
    |         | +-scan=
    |         | | +-TableScan(column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3], table=EnumTable, column_index_list=[0, 1, 2])
    |         | +-output_column_list=EnumTable.[key#1, TestEnum#2, AnotherTestEnum#3]
    |         +-SetOperationItem
    |           +-scan=
    |           | +-TableScan(column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8], table=EnumTable, column_index_list=[0, 1, 2])
    |           +-output_column_list=EnumTable.[key#6, TestEnum#7, AnotherTestEnum#8]
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT32) -> BOOL)
        +-ColumnRef(type=INT32, column=$union_all.key#11)
--
ALTERNATION GROUP: filename
--
ERROR: Unrecognized name: filename [at 5:10]
|> WHERE filename IS NULL
         ^
==

FROM UNNEST([1,2]) AS elem WITH OFFSET
|> STATIC_DESCRIBE
|> WHERE elem=2
|> WHERE offset=3
--
QueryStmt
+-output_column_list=
| +-$array.elem#1 AS elem [INT64]
| +-$array_offset.offset#2 AS offset [INT64]
+-query=
  +-FilterScan
    +-column_list=[$array.elem#1, $array_offset.offset#2]
    +-input_scan=
    | +-FilterScan
    |   +-column_list=[$array.elem#1, $array_offset.offset#2]
    |   +-input_scan=
    |   | +-StaticDescribeScan
    |   |   +-column_list=[$array.elem#1, $array_offset.offset#2]
    |   |   +-describe_text=
    |   |   |   """
    |   |   |   NameList:
    |   |   |     elem INT64 $array.elem#1 (value table)
    |   |   |     offset INT64 $array_offset.offset#2 (value table)
    |   |   |   NameScope:
    |   |   |     Range variables:
    |   |   |       elem -> RANGE_VARIABLE<$value>
    |   |   |       offset -> RANGE_VARIABLE<$value>
    |   |   |     Value table columns:
    |   |   |       $array.elem#1
    |   |   |       $array_offset.offset#2
    |   |   |   """
    |   |   +-input_scan=
    |   |     +-ArrayScan
    |   |       +-column_list=[$array.elem#1, $array_offset.offset#2]
    |   |       +-array_expr_list=
    |   |       | +-Literal(type=ARRAY<INT64>, value=[1, 2])
    |   |       +-element_column_list=[$array.elem#1]
    |   |       +-array_offset_column=
    |   |         +-ColumnHolder(column=$array_offset.offset#2)
    |   +-filter_expr=
    |     +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |       +-ColumnRef(type=INT64, column=$array.elem#1)
    |       +-Literal(type=INT64, value=2)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=$array_offset.offset#2)
        +-Literal(type=INT64, value=3)
==

# Here, row ends up being the value table name, and the elem name is dropped.
SELECT {{elem|row.elem|row}}
FROM
  (FROM UNNEST([1,2]) AS elem) AS row
--
ALTERNATION GROUP: elem
--
ERROR: Unrecognized name: elem [at 1:8]
SELECT elem
       ^
--
ALTERNATION GROUP: row.elem
--
ERROR: Cannot access field elem on a value with type INT64 [at 1:12]
SELECT row.elem
           ^
--
ALTERNATION GROUP: row
--
QueryStmt
+-output_column_list=
| +-$array.elem#1 AS `row` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$array.elem#1]
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.elem#1]
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2])
        +-element_column_list=[$array.elem#1]
==

# This shows an aliased table subquery with UNNEST.
SELECT key, row.key, elem, row.elem, row
FROM
  (FROM KeyValue, UNNEST([1,2]) AS elem) AS row
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key [INT64]
| +-$array.elem#3 AS elem [INT64]
| +-$array.elem#3 AS elem [INT64]
| +-$query.row#5 AS `row` [STRUCT<Key INT64, Value STRING, elem INT64>]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Key#1, $array.elem#3, $array.elem#3, $query.row#5]
    +-expr_list=
    | +-row#5 :=
    |   +-MakeStruct
    |     +-type=STRUCT<Key INT64, Value STRING, elem INT64>
    |     +-field_list=
    |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    |       +-ColumnRef(type=INT64, column=$array.elem#3)
    +-input_scan=
      +-ArrayScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $array.elem#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2])
        +-element_column_list=[$array.elem#3]
==

SELECT {{KeyValue|row.KeyValue|KeyValue.key|row.KeyValue.key}}
FROM
  (FROM KeyValue, UNNEST([1,2]) AS elem) AS row
--
ALTERNATION GROUP: KeyValue
--
ERROR: Unrecognized name: KeyValue; Did you mean Value? [at 1:8]
SELECT KeyValue
       ^
--
ALTERNATION GROUP: row.KeyValue
--
ERROR: Name KeyValue not found inside row [at 1:12]
SELECT row.KeyValue
           ^
--
ALTERNATION GROUP: KeyValue.key
--
ERROR: Unrecognized name: KeyValue; Did you mean Value? [at 1:8]
SELECT KeyValue.key
       ^
--
ALTERNATION GROUP: row.KeyValue.key
--
ERROR: Name KeyValue not found inside row [at 1:12]
SELECT row.KeyValue.key
           ^
==

# We have a value table, wrapped in a FROM query twice, with or without
# aliases at each level.
# The final output is always still a value table.
# Pseudo-columns work even if aliases are added, since the aliases become the
# new alias of the value table.
from (from (from TestExtraValueTable vt) {{|AS row1}}){{| AS row2}}
|> where filename = ''
|> STATIC_DESCRIBE
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     vt zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |     Range variables:
    |       vt -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |   """
    +-input_scan=
      +-FilterScan
        +-column_list=TestExtraValueTable.[value#1, Filename#2]
        +-input_scan=
        | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="vt")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
            +-Literal(type=STRING, value="")
--
ALTERNATION GROUPS:
     AS row2
    AS row1, AS row2
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     row2 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |     Range variables:
    |       row2 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |   """
    +-input_scan=
      +-FilterScan
        +-column_list=TestExtraValueTable.[value#1, Filename#2]
        +-input_scan=
        | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="vt")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
            +-Literal(type=STRING, value="")
--
ALTERNATION GROUP: AS row1,
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-StaticDescribeScan
    +-column_list=TestExtraValueTable.[value#1, Filename#2]
    +-describe_text=
    |   """
    |   NameList (is_value_table = true):
    |     row1 zetasql_test__.TestExtraPB TestExtraValueTable.value#1 (value table)
    |   NameScope:
    |     Names:
    |       Filename -> STRING (TestExtraValueTable.Filename#2) (implicit) (pseudo-column)
    |       RowId -> BYTES (TestExtraValueTable.RowId#3) (implicit) (pseudo-column)
    |     Range variables:
    |       row1 -> RANGE_VARIABLE<$value>
    |     Value table columns:
    |       TestExtraValueTable.value#1
    |   """
    +-input_scan=
      +-FilterScan
        +-column_list=TestExtraValueTable.[value#1, Filename#2]
        +-input_scan=
        | +-TableScan(column_list=TestExtraValueTable.[value#1, Filename#2], table=TestExtraValueTable, column_index_list=[0, 1], alias="vt")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=TestExtraValueTable.Filename#2)
            +-Literal(type=STRING, value="")
