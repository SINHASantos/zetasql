# Literal replacement doesn't work because parameters don't work as constants
# in the IF conditions yet.
[default language_features=MAXIMUM]
[default no_enable_literal_replacement]

[language_features=NONE,+PIPES]
FROM KeyValue
|> IF true THEN ()
--
ERROR: Pipe IF not supported [at 2:1]
|> IF true THEN ()
^
==

[default language_features=MAXIMUM,+PIPES,+PIPE_IF,+PIPE_STATIC_DESCRIBE]
FROM KeyValue
|> IF true THEN ()
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="()"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
==

FROM KeyValue
|> IF "abc" THEN ()
--
ERROR: Pipe IF condition expression should return type BOOL, but returns STRING [at 2:7]
|> IF "abc" THEN ()
      ^
==

FROM KeyValue
|> IF key=5 THEN ()
--
ERROR: Pipe IF condition expression must be a constant expression [at 2:7]
|> IF key=5 THEN ()
      ^
==

FROM KeyValue
|> IF 2=5 THEN ()
--
ERROR: Pipe IF condition expression must be evaluated to a constant value at analysis time; Only literals and constants are currently supported [at 2:7]
|> IF 2=5 THEN ()
      ^
==

# All of the conditions must be valid and boolean and constant, even
# after an earlier 'true' value.
FROM KeyValue
|> IF true THEN ( |> SELECT key )
   ELSEIF {{5|key=4|xx=yy|true}} THEN ()
--
ALTERNATION GROUP: 5
--
ERROR: Pipe IF condition expression should return type BOOL, but returns INT64 [at 3:11]
   ELSEIF 5 THEN ()
          ^
--
ALTERNATION GROUP: key=4
--
ERROR: Pipe IF condition expression must be a constant expression [at 3:11]
   ELSEIF key=4 THEN ()
          ^
--
ALTERNATION GROUP: xx=yy
--
ERROR: Unrecognized name: xx [at 3:11]
   ELSEIF xx=yy THEN ()
          ^
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=true)
      | +-subpipeline_sql="( |> SELECT key )"
      | +-subpipeline=
      |   +-Subpipeline
      |     +-scan=
      |       +-ProjectScan
      |         +-column_list=[KeyValue.Key#1]
      |         +-input_scan=
      |           +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="()"
==

# NULL conditions are allowed and act like falses.
FROM KeyValue
|> IF NULL THEN ( |> SELECT key )
   ELSE ( |> SELECT value )
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Value#2]
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
    +-selected_case=1
    +-if_case_list=
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=NULL)
      | +-subpipeline_sql="( |> SELECT key )"
      +-PipeIfCase
        +-subpipeline_sql="( |> SELECT value )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-ProjectScan
                +-column_list=[KeyValue.Value#2]
                +-input_scan=
                  +-SubpipelineInputScan(column_list=[KeyValue.Value#2])
==

# An error evaluating a condition before the chosen condition will
# cause a failure at analysis time.
# This is not currently reachable because we don't support evalauting
# any constant expressions that can evaluate to errors.
FROM KeyValue
|> IF ERROR("abc") IS NOT NULL THEN ( |> SELECT key )
   ELSEIF true THEN ()
--
ERROR: Pipe IF condition expression must be evaluated to a constant value at analysis time; Only literals and constants are currently supported [at 2:7]
|> IF ERROR("abc") IS NOT NULL THEN ( |> SELECT key )
      ^
==

# An error evaluating a condition after the chosen condition is okay
# because the later conditions are not evaluated.
# This is not currently reachable because we don't support evalauting
# any constant expressions that can evaluate to errors.
FROM KeyValue
|> IF true THEN ( |> SELECT key )
   ELSEIF ERROR("abc") IS NULL THEN ()
--
ERROR: Pipe IF condition expression must be evaluated to a constant value at analysis time; Only literals and constants are currently supported [at 3:11]
   ELSEIF ERROR("abc") IS NULL THEN ()
          ^
==

# Invalid queries in the unchosen branches are okay.
FROM KeyValue
|> IF false THEN ( |> WHERE key0 )
|> IF false THEN ( |> SELECT key1 )
   ELSEIF false THEN ( |> SELECT key2 )
   ELSE ( |> SELECT key )
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=[KeyValue.Key#1]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-selected_case=-1
    |   +-if_case_list=
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=false)
    |       +-subpipeline_sql="( |> WHERE key0 )"
    +-selected_case=2
    +-if_case_list=
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=false)
      | +-subpipeline_sql="( |> SELECT key1 )"
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=false)
      | +-subpipeline_sql="( |> SELECT key2 )"
      +-PipeIfCase
        +-subpipeline_sql="( |> SELECT key )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-ProjectScan
                +-column_list=[KeyValue.Key#1]
                +-input_scan=
                  +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
==

# Invalid queries in the unchosen branches are okay,
# even if their conditions are true.
FROM KeyValue
|> IF false THEN ( |> SELECT key1 )
   ELSEIF true THEN ( |> SELECT key )
   ELSEIF true THEN ( |> SELECT key3 )
   ELSE ( |> SELECT key4 )
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-selected_case=1
    +-if_case_list=
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=false)
      | +-subpipeline_sql="( |> SELECT key1 )"
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=true)
      | +-subpipeline_sql="( |> SELECT key )"
      | +-subpipeline=
      |   +-Subpipeline
      |     +-scan=
      |       +-ProjectScan
      |         +-column_list=[KeyValue.Key#1]
      |         +-input_scan=
      |           +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
      +-PipeIfCase
      | +-condition=
      | | +-Literal(type=BOOL, value=true)
      | +-subpipeline_sql="( |> SELECT key3 )"
      +-PipeIfCase(subpipeline_sql="( |> SELECT key4 )")
==

# The chosen query is invalid.
FROM KeyValue
|> IF {{true|false}} THEN (
     |> WHERE true
     |> SELECT key = 'abc'
     |> WHERE true
   )
   ELSEIF {{true|false}} THEN ( |> WHERE 5 )
   ELSE ( |> EXTEND xxx() )
--
ALTERNATION GROUPS:
    true,true
    true,false
--
ERROR: No matching signature for operator = for argument types: INT64, STRING
  Signature: T1 = T1
    Unable to find common supertype for templated argument <T1>
      Input types for <T1>: {INT64, STRING}
  Signature: INT64 = UINT64
    Argument 2: Unable to coerce type STRING to expected type UINT64
  Signature: UINT64 = INT64
    Argument 1: Unable to coerce type INT64 to expected type UINT64 [at 4:16]
     |> SELECT key = 'abc'
               ^
--
ALTERNATION GROUP: false,true
--
ERROR: WHERE clause should return type BOOL, but returns INT64 [at 7:32]
   ELSEIF true THEN ( |> WHERE 5 )
                               ^
--
ALTERNATION GROUP: false,false
--
ERROR: Function not found: xxx [at 8:21]
   ELSE ( |> EXTEND xxx() )
                    ^
==

# Based on which of IF and ELSEIF are true, we get a different
# `selected_case`, and a different output schema, with a resolved
# subpipeline filled in just for the selected case.
FROM KeyValue
|> {{IF true|IF false}} THEN ( |> EXTEND 1 x )
   {{ELSEIF true|ELSEIF false}} THEN ( |> EXTEND 2 y )
   ELSE ( |> EXTEND 3 z )
|> STATIC_DESCRIBE
--
ALTERNATION GROUP: IF true,ELSEIF true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.x#3 AS x [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     x INT64 $pipe_extend.x#3
    |   NameScope:
    |     Names:
    |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |       Value -> STRING (KeyValue.Value#2) (implicit)
    |       x -> INT64 ($pipe_extend.x#3)
    |     Range variables:
    |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-PipeIfScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-selected_case=0
        +-if_case_list=
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=true)
          | +-subpipeline_sql="( |> EXTEND 1 x )"
          | +-subpipeline=
          |   +-Subpipeline
          |     +-scan=
          |       +-ProjectScan
          |         +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
          |         +-expr_list=
          |         | +-x#3 := Literal(type=INT64, value=1)
          |         +-input_scan=
          |           +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=true)
          | +-subpipeline_sql="( |> EXTEND 2 y )"
          +-PipeIfCase(subpipeline_sql="( |> EXTEND 3 z )")
--
ALTERNATION GROUP: IF true,ELSEIF false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.x#3 AS x [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     x INT64 $pipe_extend.x#3
    |   NameScope:
    |     Names:
    |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |       Value -> STRING (KeyValue.Value#2) (implicit)
    |       x -> INT64 ($pipe_extend.x#3)
    |     Range variables:
    |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-PipeIfScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-selected_case=0
        +-if_case_list=
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=true)
          | +-subpipeline_sql="( |> EXTEND 1 x )"
          | +-subpipeline=
          |   +-Subpipeline
          |     +-scan=
          |       +-ProjectScan
          |         +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.x#3]
          |         +-expr_list=
          |         | +-x#3 := Literal(type=INT64, value=1)
          |         +-input_scan=
          |           +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=false)
          | +-subpipeline_sql="( |> EXTEND 2 y )"
          +-PipeIfCase(subpipeline_sql="( |> EXTEND 3 z )")
--
ALTERNATION GROUP: IF false,ELSEIF true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.y#3 AS y [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.y#3]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     y INT64 $pipe_extend.y#3
    |   NameScope:
    |     Names:
    |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |       Value -> STRING (KeyValue.Value#2) (implicit)
    |       y -> INT64 ($pipe_extend.y#3)
    |     Range variables:
    |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-PipeIfScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.y#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-selected_case=1
        +-if_case_list=
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=false)
          | +-subpipeline_sql="( |> EXTEND 1 x )"
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=true)
          | +-subpipeline_sql="( |> EXTEND 2 y )"
          | +-subpipeline=
          |   +-Subpipeline
          |     +-scan=
          |       +-ProjectScan
          |         +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.y#3]
          |         +-expr_list=
          |         | +-y#3 := Literal(type=INT64, value=2)
          |         +-input_scan=
          |           +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
          +-PipeIfCase(subpipeline_sql="( |> EXTEND 3 z )")
--
ALTERNATION GROUP: IF false,ELSEIF false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.z#3 AS z [INT64]
+-query=
  +-StaticDescribeScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.z#3]
    +-describe_text=
    |   """
    |   NameList:
    |     Key INT64 KeyValue.Key#1
    |     Value STRING KeyValue.Value#2
    |     z INT64 $pipe_extend.z#3
    |   NameScope:
    |     Names:
    |       Key -> INT64 (KeyValue.Key#1) (implicit)
    |       Value -> STRING (KeyValue.Value#2) (implicit)
    |       z -> INT64 ($pipe_extend.z#3)
    |     Range variables:
    |       KeyValue -> RANGE_VARIABLE<Key,Value>
    |   """
    +-input_scan=
      +-PipeIfScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.z#3]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-selected_case=2
        +-if_case_list=
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=false)
          | +-subpipeline_sql="( |> EXTEND 1 x )"
          +-PipeIfCase
          | +-condition=
          | | +-Literal(type=BOOL, value=false)
          | +-subpipeline_sql="( |> EXTEND 2 y )"
          +-PipeIfCase
            +-subpipeline_sql="( |> EXTEND 3 z )"
            +-subpipeline=
              +-Subpipeline
                +-scan=
                  +-ProjectScan
                    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.z#3]
                    +-expr_list=
                    | +-z#3 := Literal(type=INT64, value=3)
                    +-input_scan=
                      +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
==

# This query is valid or invalid depending whether the column we
# select is the one the IF added.
FROM KeyValue
|> IF {{true|false}} THEN ( |> EXTEND key AS key1 )
   ELSE ( |> EXTEND key AS key2 )
|> WHERE value = 'abc'
|> SELECT key, {{key1|key2}}
--
ALTERNATION GROUP: true,key1
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key1 [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-PipeIfScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-selected_case=0
        |   +-if_case_list=
        |     +-PipeIfCase
        |     | +-condition=
        |     | | +-Literal(type=BOOL, value=true)
        |     | +-subpipeline_sql="( |> EXTEND key AS key1 )"
        |     | +-subpipeline=
        |     |   +-Subpipeline
        |     |     +-scan=
        |     |       +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        |     +-PipeIfCase(subpipeline_sql="( |> EXTEND key AS key2 )")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-Literal(type=STRING, value="abc")
--
ALTERNATION GROUP: true,key2
--
ERROR: Unrecognized name: key2; Did you mean key1? [at 5:16]
|> SELECT key, key2
               ^
--
ALTERNATION GROUP: false,key1
--
ERROR: Unrecognized name: key1; Did you mean key2? [at 5:16]
|> SELECT key, key1
               ^
--
ALTERNATION GROUP: false,key2
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
| +-KeyValue.Key#1 AS key2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=KeyValue.[Key#1, Key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=KeyValue.[Key#1, Value#2]
        +-input_scan=
        | +-PipeIfScan
        |   +-column_list=KeyValue.[Key#1, Value#2]
        |   +-input_scan=
        |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   +-selected_case=1
        |   +-if_case_list=
        |     +-PipeIfCase
        |     | +-condition=
        |     | | +-Literal(type=BOOL, value=false)
        |     | +-subpipeline_sql="( |> EXTEND key AS key1 )"
        |     +-PipeIfCase
        |       +-subpipeline_sql="( |> EXTEND key AS key2 )"
        |       +-subpipeline=
        |         +-Subpipeline
        |           +-scan=
        |             +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-Literal(type=STRING, value="abc")
==

# Output has is_ordered if the IF branch was ordered.
FROM KeyValue
|> IF {{true|false}} THEN ( |> ORDER BY key )
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="( |> ORDER BY key )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-OrderByScan
                +-column_list=KeyValue.[Key#1, Value#2]
                +-is_ordered=TRUE
                +-input_scan=
                | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
                +-order_by_item_list=
                  +-OrderByItem
                    +-column_ref=
                      +-ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=-1
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=false)
        +-subpipeline_sql="( |> ORDER BY key )"
==

# Output loses is_ordered if the IF branch was executed.
# The ELSEIF and ELSE branches preserve order.
FROM KeyValue
|> ORDER BY key
|> IF {{true|false}} THEN ( |> WHERE true )
   ELSEIF {{true|false}} THEN ( |> LIMIT 10 )
|> LIMIT 10
--
ALTERNATION GROUP: true,true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-LimitOffsetScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-selected_case=0
    |   +-if_case_list=
    |     +-PipeIfCase
    |     | +-condition=
    |     | | +-Literal(type=BOOL, value=true)
    |     | +-subpipeline_sql="( |> WHERE true )"
    |     | +-subpipeline=
    |     |   +-Subpipeline
    |     |     +-scan=
    |     |       +-FilterScan
    |     |         +-column_list=KeyValue.[Key#1, Value#2]
    |     |         +-input_scan=
    |     |         | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2], is_ordered=TRUE)
    |     |         +-filter_expr=
    |     |           +-Literal(type=BOOL, value=true)
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=true)
    |       +-subpipeline_sql="( |> LIMIT 10 )"
    +-limit=
      +-Literal(type=INT64, value=10)
--
ALTERNATION GROUP: true,false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-LimitOffsetScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-selected_case=0
    |   +-if_case_list=
    |     +-PipeIfCase
    |     | +-condition=
    |     | | +-Literal(type=BOOL, value=true)
    |     | +-subpipeline_sql="( |> WHERE true )"
    |     | +-subpipeline=
    |     |   +-Subpipeline
    |     |     +-scan=
    |     |       +-FilterScan
    |     |         +-column_list=KeyValue.[Key#1, Value#2]
    |     |         +-input_scan=
    |     |         | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2], is_ordered=TRUE)
    |     |         +-filter_expr=
    |     |           +-Literal(type=BOOL, value=true)
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=false)
    |       +-subpipeline_sql="( |> LIMIT 10 )"
    +-limit=
      +-Literal(type=INT64, value=10)
--
ALTERNATION GROUP: false,true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-LimitOffsetScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-is_ordered=TRUE
    |   +-input_scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-selected_case=1
    |   +-if_case_list=
    |     +-PipeIfCase
    |     | +-condition=
    |     | | +-Literal(type=BOOL, value=false)
    |     | +-subpipeline_sql="( |> WHERE true )"
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=true)
    |       +-subpipeline_sql="( |> LIMIT 10 )"
    |       +-subpipeline=
    |         +-Subpipeline
    |           +-scan=
    |             +-LimitOffsetScan
    |               +-column_list=KeyValue.[Key#1, Value#2]
    |               +-is_ordered=TRUE
    |               +-input_scan=
    |               | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2], is_ordered=TRUE)
    |               +-limit=
    |                 +-Literal(type=INT64, value=10)
    +-limit=
      +-Literal(type=INT64, value=10)
--
ALTERNATION GROUP: false,false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-LimitOffsetScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-is_ordered=TRUE
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-is_ordered=TRUE
    |   +-input_scan=
    |   | +-OrderByScan
    |   |   +-column_list=KeyValue.[Key#1, Value#2]
    |   |   +-is_ordered=TRUE
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-order_by_item_list=
    |   |     +-OrderByItem
    |   |       +-column_ref=
    |   |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   +-selected_case=-1
    |   +-if_case_list=
    |     +-PipeIfCase
    |     | +-condition=
    |     | | +-Literal(type=BOOL, value=false)
    |     | +-subpipeline_sql="( |> WHERE true )"
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=false)
    |       +-subpipeline_sql="( |> LIMIT 10 )"
    +-limit=
      +-Literal(type=INT64, value=10)
==

# Value table is preserved if the IF doesn't remove it.
FROM TestExtraValueTable
|> IF {{true|false}} THEN ( |> EXTEND 123 )
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS TestExtraValueTable [PROTO<zetasql_test__.TestExtraPB>]
| +-$pipe_extend.$col1#4 AS `$col1` [INT64]
+-query=
  +-PipeIfScan
    +-column_list=[TestExtraValueTable.value#1, $pipe_extend.$col1#4]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="( |> EXTEND 123 )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-ProjectScan
                +-column_list=[TestExtraValueTable.value#1, $pipe_extend.$col1#4]
                +-expr_list=
                | +-$col1#4 := Literal(type=INT64, value=123)
                +-input_scan=
                  +-SubpipelineInputScan(column_list=[TestExtraValueTable.value#1])
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-TestExtraValueTable.value#1 AS `$value` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-PipeIfScan
    +-column_list=[TestExtraValueTable.value#1]
    +-input_scan=
    | +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0])
    +-selected_case=-1
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=false)
        +-subpipeline_sql="( |> EXTEND 123 )"
==

# Value table property is added if the IF adds it.
FROM KeyValue
|> IF {{true|false}} THEN ( |> SELECT AS VALUE key )
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS `$value_column` [INT64]
+-is_value_table=TRUE
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
    | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="( |> SELECT AS VALUE key )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-ProjectScan
                +-column_list=[KeyValue.Key#1]
                +-input_scan=
                  +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=-1
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=false)
        +-subpipeline_sql="( |> SELECT AS VALUE key )"
==

# Show rewrite when an IF case is or isn't selected.
[enabled_ast_rewrites=DEFAULTS]
FROM KeyValue
|> IF {{true|false}} THEN (
     |> WHERE key > 10
     |> EXTEND key * 1000
     |> DROP value
   )
|> WHERE key IS NULL
--
ALTERNATION GROUP: true
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-$pipe_extend.$col1#3 AS `$col1` [INT64]
+-query=
  +-FilterScan
    +-column_list=[KeyValue.Key#1, $pipe_extend.$col1#3]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=[KeyValue.Key#1, $pipe_extend.$col1#3]
    |   +-input_scan=
    |   | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-selected_case=0
    |   +-if_case_list=
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=true)
    |       +-subpipeline_sql="(\n     |> WHERE key > 10\n     |> EXTEND key * 1000\n     |> DROP value\n   )"
    |       +-subpipeline=
    |         +-Subpipeline
    |           +-scan=
    |             +-ProjectScan
    |               +-column_list=[KeyValue.Key#1, $pipe_extend.$col1#3]
    |               +-expr_list=
    |               | +-$col1#3 :=
    |               |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |               |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |               |     +-Literal(type=INT64, value=1000)
    |               +-input_scan=
    |                 +-FilterScan
    |                   +-column_list=[KeyValue.Key#1]
    |                   +-input_scan=
    |                   | +-SubpipelineInputScan(column_list=[KeyValue.Key#1])
    |                   +-filter_expr=
    |                     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |                       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |                       +-Literal(type=INT64, value=10)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-$pipe_extend.$col1#3 AS `$col1` [INT64]
+-query=
  +-FilterScan
    +-column_list=[KeyValue.Key#1, $pipe_extend.$col1#3]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=[KeyValue.Key#1, $pipe_extend.$col1#3]
    |   +-expr_list=
    |   | +-$col1#3 :=
    |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |   |     +-Literal(type=INT64, value=1000)
    |   +-input_scan=
    |     +-FilterScan
    |       +-column_list=[KeyValue.Key#1]
    |       +-input_scan=
    |       | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |       +-filter_expr=
    |         +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    |           +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |           +-Literal(type=INT64, value=10)
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
--
ALTERNATION GROUP: false
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-PipeIfScan
    |   +-column_list=KeyValue.[Key#1, Value#2]
    |   +-input_scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-selected_case=-1
    |   +-if_case_list=
    |     +-PipeIfCase
    |       +-condition=
    |       | +-Literal(type=BOOL, value=false)
    |       +-subpipeline_sql="(\n     |> WHERE key > 10\n     |> EXTEND key * 1000\n     |> DROP value\n   )"
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=KeyValue.Key#1)
==

# Test rewrites when we have nested IFs.
[enabled_ast_rewrites=DEFAULTS]
FROM KeyValue
|> IF true THEN (
     |> EXTEND key*10 k10
     |> IF false THEN ()
        ELSEIF true THEN (
          |> EXTEND k10*10 k100
          |> IF false THEN ()
             ELSE (
               |> EXTEND k100*10 k1000
             )
         )
   )
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.k10#3 AS k10 [INT64]
| +-$pipe_extend.k100#4 AS k100 [INT64]
| +-$pipe_extend.k1000#5 AS k1000 [INT64]
+-query=
  +-PipeIfScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4, $pipe_extend.k1000#5]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="(\n     |> EXTEND key*10 k10\n     |> IF false THEN ()\n        ELSEIF true THEN (\n          |> EXTEND k10*10 k100\n          |> IF false THEN ()\n             ELSE (\n               |> EXTEND k100*10 k1000\n             )\n         )\n   )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-PipeIfScan
                +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4, $pipe_extend.k1000#5]
                +-input_scan=
                | +-ProjectScan
                |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3]
                |   +-expr_list=
                |   | +-k10#3 :=
                |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
                |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                |   |     +-Literal(type=INT64, value=10)
                |   +-input_scan=
                |     +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
                +-selected_case=1
                +-if_case_list=
                  +-PipeIfCase
                  | +-condition=
                  | | +-Literal(type=BOOL, value=false)
                  | +-subpipeline_sql="()"
                  +-PipeIfCase
                    +-condition=
                    | +-Literal(type=BOOL, value=true)
                    +-subpipeline_sql="(\n          |> EXTEND k10*10 k100\n          |> IF false THEN ()\n             ELSE (\n               |> EXTEND k100*10 k1000\n             )\n         )"
                    +-subpipeline=
                      +-Subpipeline
                        +-scan=
                          +-PipeIfScan
                            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4, $pipe_extend.k1000#5]
                            +-input_scan=
                            | +-ProjectScan
                            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4]
                            |   +-expr_list=
                            |   | +-k100#4 :=
                            |   |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
                            |   |     +-ColumnRef(type=INT64, column=$pipe_extend.k10#3)
                            |   |     +-Literal(type=INT64, value=10)
                            |   +-input_scan=
                            |     +-SubpipelineInputScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3])
                            +-selected_case=1
                            +-if_case_list=
                              +-PipeIfCase
                              | +-condition=
                              | | +-Literal(type=BOOL, value=false)
                              | +-subpipeline_sql="()"
                              +-PipeIfCase
                                +-subpipeline_sql="(\n               |> EXTEND k100*10 k1000\n             )"
                                +-subpipeline=
                                  +-Subpipeline
                                    +-scan=
                                      +-ProjectScan
                                        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4, $pipe_extend.k1000#5]
                                        +-expr_list=
                                        | +-k1000#5 :=
                                        |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
                                        |     +-ColumnRef(type=INT64, column=$pipe_extend.k100#4)
                                        |     +-Literal(type=INT64, value=10)
                                        +-input_scan=
                                          +-SubpipelineInputScan(column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4])

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.k10#3 AS k10 [INT64]
| +-$pipe_extend.k100#4 AS k100 [INT64]
| +-$pipe_extend.k1000#5 AS k1000 [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4, $pipe_extend.k1000#5]
    +-expr_list=
    | +-k1000#5 :=
    |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
    |     +-ColumnRef(type=INT64, column=$pipe_extend.k100#4)
    |     +-Literal(type=INT64, value=10)
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3, $pipe_extend.k100#4]
        +-expr_list=
        | +-k100#4 :=
        |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$pipe_extend.k10#3)
        |     +-Literal(type=INT64, value=10)
        +-input_scan=
          +-ProjectScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.k10#3]
            +-expr_list=
            | +-k10#3 :=
            |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-Literal(type=INT64, value=10)
            +-input_scan=
              +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
==

# Hints are supported in analysis, but not in rewrites, where we
# don't know what to do with them.
[enabled_ast_rewrites=DEFAULTS]
FROM KeyValue
|> IF @{hint=true} {{true|false}} THEN (
     |> WHERE key > 10
   )
--
ALTERNATION GROUP: true
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-hint_list=
    | +-hint := Literal(type=BOOL, value=true)
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=0
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=true)
        +-subpipeline_sql="(\n     |> WHERE key > 10\n   )"
        +-subpipeline=
          +-Subpipeline
            +-scan=
              +-FilterScan
                +-column_list=KeyValue.[Key#1, Value#2]
                +-input_scan=
                | +-SubpipelineInputScan(column_list=KeyValue.[Key#1, Value#2])
                +-filter_expr=
                  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
                    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                    +-Literal(type=INT64, value=10)

Rewrite ERROR: generic::unimplemented: Pipe IF does not support hints
--
ALTERNATION GROUP: false
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
+-query=
  +-PipeIfScan
    +-column_list=KeyValue.[Key#1, Value#2]
    +-hint_list=
    | +-hint := Literal(type=BOOL, value=true)
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-selected_case=-1
    +-if_case_list=
      +-PipeIfCase
        +-condition=
        | +-Literal(type=BOOL, value=false)
        +-subpipeline_sql="(\n     |> WHERE key > 10\n   )"

Rewrite ERROR: generic::unimplemented: Pipe IF does not support hints
==

# This fails, while the version below without IF passes, because literalness
# of NULL doesn't propagate out of the IF.  This is similar to selecting NULL
# in a subquery.
SELECT 1
|> IF TRUE THEN (
  |> SELECT NULL
)
|> UNION ALL (SELECT CAST(NULL AS STRING))
--
ERROR: Column 1 in UNION ALL has incompatible types: INT64, STRING [at 5:15]
|> UNION ALL (SELECT CAST(NULL AS STRING))
              ^
==

SELECT 1
|> SELECT NULL
|> UNION ALL (SELECT CAST(NULL AS STRING))
--
QueryStmt
+-output_column_list=
| +-$union_all.$col1#4 AS `$col1` [STRING]
+-query=
  +-SetOperationScan
    +-column_list=[$union_all.$col1#4]
    +-op_type=UNION_ALL
    +-input_item_list=
      +-SetOperationItem
      | +-scan=
      | | +-ProjectScan
      | |   +-column_list=[$union_all1_cast.$col1#5]
      | |   +-expr_list=
      | |   | +-$col1#5 := Literal(type=STRING, value=NULL)
      | |   +-input_scan=
      | |     +-ProjectScan
      | |       +-column_list=[$pipe_select.$col1#2]
      | |       +-expr_list=
      | |       | +-$col1#2 := Literal(type=INT64, value=NULL)
      | |       +-input_scan=
      | |         +-ProjectScan
      | |           +-column_list=[$query.$col1#1]
      | |           +-expr_list=
      | |           | +-$col1#1 := Literal(type=INT64, value=1)
      | |           +-input_scan=
      | |             +-SingleRowScan
      | +-output_column_list=[$union_all1_cast.$col1#5]
      +-SetOperationItem
        +-scan=
        | +-ProjectScan
        |   +-column_list=[$union_all1.$col1#3]
        |   +-expr_list=
        |   | +-$col1#3 := Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
        |   +-input_scan=
        |     +-SingleRowScan
        +-output_column_list=[$union_all1.$col1#3]
