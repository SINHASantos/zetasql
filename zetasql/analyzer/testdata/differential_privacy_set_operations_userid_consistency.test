# Tests that DP queries reject set operations with inconsistent userid columns.
[default language_features=NONE,+DIFFERENTIAL_PRIVACY,+NAMED_ARGUMENTS,+NUMERIC_TYPE]

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from SimpleTypesWithAnonymizationUid
      {{union|intersect|except}} {{all|distinct}}
      select NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
--
ALTERNATION GROUP: union,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-237
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-236
        |   +-column_list=$union_all.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$union_all2_cast.$col1#37, $union_all2.$col2#14, $union_all2_cast.$col3#38, $union_all2_cast.$col4#39, $union_all2_cast.$col5#40, $union_all2_cast.$col6#41, $union_all2_cast.$col7#42, $union_all2_cast.$col8#43, $union_all2_cast.$col9#44, $union_all2_cast.$col10#45, $union_all2.$col11#23, $union_all2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=166-170, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=178-182, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=184-188, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=190-194, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=196-200, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=202-206, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=208-212, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=214-218, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=220-224, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=232-236, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$union_all2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=172-176, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=226-230, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$union_all2_cast.$col1#37, $union_all2.$col2#14, $union_all2_cast.$col3#38, $union_all2_cast.$col4#39, $union_all2_cast.$col5#40, $union_all2_cast.$col6#41, $union_all2_cast.$col7#42, $union_all2_cast.$col8#43, $union_all2_cast.$col9#44, $union_all2_cast.$col10#45, $union_all2.$col11#23, $union_all2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      union all
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in UNION ALL are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
--
ALTERNATION GROUP: union,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-242
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-241
        |   +-column_list=$union_distinct.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=UNION_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$union_distinct2_cast.$col1#37, $union_distinct2.$col2#14, $union_distinct2_cast.$col3#38, $union_distinct2_cast.$col4#39, $union_distinct2_cast.$col5#40, $union_distinct2_cast.$col6#41, $union_distinct2_cast.$col7#42, $union_distinct2_cast.$col8#43, $union_distinct2_cast.$col9#44, $union_distinct2_cast.$col10#45, $union_distinct2.$col11#23, $union_distinct2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=171-175, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=183-187, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=189-193, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=195-199, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=201-205, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=207-211, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=213-217, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=219-223, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=225-229, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=237-241, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$union_distinct2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=177-181, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=231-235, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$union_distinct2_cast.$col1#37, $union_distinct2.$col2#14, $union_distinct2_cast.$col3#38, $union_distinct2_cast.$col4#39, $union_distinct2_cast.$col5#40, $union_distinct2_cast.$col6#41, $union_distinct2_cast.$col7#42, $union_distinct2_cast.$col8#43, $union_distinct2_cast.$col9#44, $union_distinct2_cast.$col10#45, $union_distinct2.$col11#23, $union_distinct2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      union distinct
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in UNION DISTINCT are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
--
ALTERNATION GROUP: intersect,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-241
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-240
        |   +-column_list=$intersect_all.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=INTERSECT_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$intersect_all2_cast.$col1#37, $intersect_all2.$col2#14, $intersect_all2_cast.$col3#38, $intersect_all2_cast.$col4#39, $intersect_all2_cast.$col5#40, $intersect_all2_cast.$col6#41, $intersect_all2_cast.$col7#42, $intersect_all2_cast.$col8#43, $intersect_all2_cast.$col9#44, $intersect_all2_cast.$col10#45, $intersect_all2.$col11#23, $intersect_all2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=170-174, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=182-186, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=188-192, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=194-198, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=200-204, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=206-210, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=212-216, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=218-222, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=224-228, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=236-240, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$intersect_all2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=176-180, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=230-234, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$intersect_all2_cast.$col1#37, $intersect_all2.$col2#14, $intersect_all2_cast.$col3#38, $intersect_all2_cast.$col4#39, $intersect_all2_cast.$col5#40, $intersect_all2_cast.$col6#41, $intersect_all2_cast.$col7#42, $intersect_all2_cast.$col8#43, $intersect_all2_cast.$col9#44, $intersect_all2_cast.$col10#45, $intersect_all2.$col11#23, $intersect_all2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      intersect all
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in INTERSECT ALL are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
--
ALTERNATION GROUP: intersect,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-246
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-245
        |   +-column_list=$intersect_distinct.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=INTERSECT_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$intersect_distinct2_cast.$col1#37, $intersect_distinct2.$col2#14, $intersect_distinct2_cast.$col3#38, $intersect_distinct2_cast.$col4#39, $intersect_distinct2_cast.$col5#40, $intersect_distinct2_cast.$col6#41, $intersect_distinct2_cast.$col7#42, $intersect_distinct2_cast.$col8#43, $intersect_distinct2_cast.$col9#44, $intersect_distinct2_cast.$col10#45, $intersect_distinct2.$col11#23, $intersect_distinct2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=175-179, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=187-191, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=193-197, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=199-203, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=205-209, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=211-215, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=217-221, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=223-227, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=229-233, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=241-245, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$intersect_distinct2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=181-185, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=235-239, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$intersect_distinct2_cast.$col1#37, $intersect_distinct2.$col2#14, $intersect_distinct2_cast.$col3#38, $intersect_distinct2_cast.$col4#39, $intersect_distinct2_cast.$col5#40, $intersect_distinct2_cast.$col6#41, $intersect_distinct2_cast.$col7#42, $intersect_distinct2_cast.$col8#43, $intersect_distinct2_cast.$col9#44, $intersect_distinct2_cast.$col10#45, $intersect_distinct2.$col11#23, $intersect_distinct2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      intersect distinct
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in INTERSECT DISTINCT are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
--
ALTERNATION GROUP: except,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-238
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-237
        |   +-column_list=$except_all.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=EXCEPT_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$except_all2_cast.$col1#37, $except_all2.$col2#14, $except_all2_cast.$col3#38, $except_all2_cast.$col4#39, $except_all2_cast.$col5#40, $except_all2_cast.$col6#41, $except_all2_cast.$col7#42, $except_all2_cast.$col8#43, $except_all2_cast.$col9#44, $except_all2_cast.$col10#45, $except_all2.$col11#23, $except_all2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=167-171, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=179-183, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=185-189, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=191-195, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=197-201, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=203-207, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=209-213, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=215-219, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=221-225, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=233-237, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$except_all2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=173-177, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=227-231, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$except_all2_cast.$col1#37, $except_all2.$col2#14, $except_all2_cast.$col3#38, $except_all2_cast.$col4#39, $except_all2_cast.$col5#40, $except_all2_cast.$col6#41, $except_all2_cast.$col7#42, $except_all2_cast.$col8#43, $except_all2_cast.$col9#44, $except_all2_cast.$col10#45, $except_all2.$col11#23, $except_all2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      except all
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in EXCEPT ALL are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
--
ALTERNATION GROUP: except,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#47 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-243
    +-column_list=[$aggregate.$agg1#47]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#47]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-242
        |   +-column_list=$except_distinct.[int32#25, int64#26, uint32#27, uint64#28, string#29, bytes#30, bool#31, float#32, double#33, date#34, uid#35, numeric#36]
        |   +-op_type=EXCEPT_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-136, column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12], table=SimpleTypesWithAnonymizationUid, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        |     | +-output_column_list=SimpleTypesWithAnonymizationUid.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, uid#11, numeric#12]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=[$except_distinct2_cast.$col1#37, $except_distinct2.$col2#14, $except_distinct2_cast.$col3#38, $except_distinct2_cast.$col4#39, $except_distinct2_cast.$col5#40, $except_distinct2_cast.$col6#41, $except_distinct2_cast.$col7#42, $except_distinct2_cast.$col8#43, $except_distinct2_cast.$col9#44, $except_distinct2_cast.$col10#45, $except_distinct2.$col11#23, $except_distinct2_cast.$col12#46]
        |       |   +-expr_list=
        |       |   | +-$col1#37 := Literal(parse_location=172-176, type=INT32, value=NULL)
        |       |   | +-$col3#38 := Literal(parse_location=184-188, type=UINT32, value=NULL)
        |       |   | +-$col4#39 := Literal(parse_location=190-194, type=UINT64, value=NULL)
        |       |   | +-$col5#40 := Literal(parse_location=196-200, type=STRING, value=NULL)
        |       |   | +-$col6#41 := Literal(parse_location=202-206, type=BYTES, value=NULL)
        |       |   | +-$col7#42 := Literal(parse_location=208-212, type=BOOL, value=NULL)
        |       |   | +-$col8#43 := Literal(parse_location=214-218, type=FLOAT, value=NULL)
        |       |   | +-$col9#44 := Literal(parse_location=220-224, type=DOUBLE, value=NULL)
        |       |   | +-$col10#45 := Literal(parse_location=226-230, type=DATE, value=NULL)
        |       |   | +-$col12#46 := Literal(parse_location=238-242, type=NUMERIC, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$except_distinct2.[$col1#13, $col2#14, $col3#15, $col4#16, $col5#17, $col6#18, $col7#19, $col8#20, $col9#21, $col10#22, $col11#23, $col12#24]
        |       |       +-expr_list=
        |       |       | +-$col1#13 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#14 := Literal(parse_location=178-182, type=INT64, value=NULL)
        |       |       | +-$col3#15 := Literal(type=INT64, value=NULL)
        |       |       | +-$col4#16 := Literal(type=INT64, value=NULL)
        |       |       | +-$col5#17 := Literal(type=INT64, value=NULL)
        |       |       | +-$col6#18 := Literal(type=INT64, value=NULL)
        |       |       | +-$col7#19 := Literal(type=INT64, value=NULL)
        |       |       | +-$col8#20 := Literal(type=INT64, value=NULL)
        |       |       | +-$col9#21 := Literal(type=INT64, value=NULL)
        |       |       | +-$col10#22 := Literal(type=INT64, value=NULL)
        |       |       | +-$col11#23 := Literal(parse_location=232-236, type=INT64, value=NULL)
        |       |       | +-$col12#24 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=[$except_distinct2_cast.$col1#37, $except_distinct2.$col2#14, $except_distinct2_cast.$col3#38, $except_distinct2_cast.$col4#39, $except_distinct2_cast.$col5#40, $except_distinct2_cast.$col6#41, $except_distinct2_cast.$col7#42, $except_distinct2_cast.$col8#43, $except_distinct2_cast.$col9#44, $except_distinct2_cast.$col10#45, $except_distinct2.$col11#23, $except_distinct2_cast.$col12#46]
        +-aggregate_list=
          +-$agg1#47 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from SimpleTypesWithAnonymizationUid
      except distinct
      select @_p1_INT32, @_p2_INT64, @_p3_UINT32, @_p4_UINT64, @_p5_STRING, @_p6_BYTES, @_p7_BOOL, @_p8_FLOAT, @_p9_DOUBLE, @_p10_DATE, @_p11_INT64, @_p12_NUMERIC);

Rewrite ERROR: Not all queries in EXCEPT DISTINCT are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 2 is not [at 2:7]
from (select * from SimpleTypesWithAnonymizationUid
      ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from T1StringAnonymizationUid
      union all
      select * from T1StringAnonymizationUid
      union all
      select NULL, NULL);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#11 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-231
    +-column_list=[$aggregate.$agg1#11]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#11]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-230
        |   +-column_list=$union_all.[uid#7, c2#8]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#3, c2#4]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=166-190, column_list=T1StringAnonymizationUid.[uid#3, c2#4], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#3, c2#4]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=$union_all3_cast.[$col1#9, $col2#10]
        |       |   +-expr_list=
        |       |   | +-$col1#9 := Literal(parse_location=220-224, type=STRING, value=NULL)
        |       |   | +-$col2#10 := Literal(parse_location=226-230, type=STRING, value=NULL)
        |       |   +-input_scan=
        |       |     +-ProjectScan
        |       |       +-column_list=$union_all3.[$col1#5, $col2#6]
        |       |       +-expr_list=
        |       |       | +-$col1#5 := Literal(type=INT64, value=NULL)
        |       |       | +-$col2#6 := Literal(type=INT64, value=NULL)
        |       |       +-input_scan=
        |       |         +-SingleRowScan
        |       +-output_column_list=$union_all3_cast.[$col1#9, $col2#10]
        +-aggregate_list=
          +-$agg1#11 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      union all
      select * from T1StringAnonymizationUid
      union all
      select @_p1_STRING, @_p2_STRING);

Rewrite ERROR: Not all queries in UNION ALL are differential_privacy-enabled table expressions; query 1 is a differential_privacy-enabled table expression, but query 3 is not [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from T1StringAnonymizationUid
      {{union|intersect|except}} {{all|distinct}}
      select * from T2StringAnonymizationUid);
--
ALTERNATION GROUP: union,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-191
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-190
        |   +-column_list=$union_all.[uid#5, c2#6]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=166-190, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      union all
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in UNION ALL have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
--
ALTERNATION GROUP: union,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-196
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-195
        |   +-column_list=$union_distinct.[uid#5, c2#6]
        |   +-op_type=UNION_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=171-195, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      union distinct
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in UNION DISTINCT have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
--
ALTERNATION GROUP: intersect,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-195
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-194
        |   +-column_list=$intersect_all.[uid#5, c2#6]
        |   +-op_type=INTERSECT_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=170-194, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      intersect all
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in INTERSECT ALL have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
--
ALTERNATION GROUP: intersect,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-200
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-199
        |   +-column_list=$intersect_distinct.[uid#5, c2#6]
        |   +-op_type=INTERSECT_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=175-199, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      intersect distinct
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in INTERSECT DISTINCT have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
--
ALTERNATION GROUP: except,all
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-192
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-191
        |   +-column_list=$except_all.[uid#5, c2#6]
        |   +-op_type=EXCEPT_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=167-191, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      except all
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in EXCEPT ALL have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
--
ALTERNATION GROUP: except,distinct
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#7 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-197
    +-column_list=[$aggregate.$agg1#7]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#7]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-196
        |   +-column_list=$except_distinct.[uid#5, c2#6]
        |   +-op_type=EXCEPT_DISTINCT
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=172-196, column_list=T2StringAnonymizationUid.[c1#3, uid#4], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#3, uid#4]
        +-aggregate_list=
          +-$agg1#7 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      except distinct
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in EXCEPT DISTINCT have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 2 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
==

[enabled_ast_rewrites=DEFAULTS,+ANONYMIZATION]
[parse_location_record_type=PARSE_LOCATION_RECORD_CODE_SEARCH]
select with differential_privacy count(*, contribution_bounds_per_group => (0, 100))
from (select * from T1StringAnonymizationUid
      union all
      select * from T1StringAnonymizationUid
      union all
      select * from T2StringAnonymizationUid);
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$aggregate.$agg1#9 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-parse_location=0-252
    +-column_list=[$aggregate.$agg1#9]
    +-input_scan=
      +-DifferentialPrivacyAggregateScan
        +-column_list=[$aggregate.$agg1#9]
        +-input_scan=
        | +-SetOperationScan
        |   +-parse_location=91-251
        |   +-column_list=$union_all.[uid#7, c2#8]
        |   +-op_type=UNION_ALL
        |   +-input_item_list=
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=105-129, column_list=T1StringAnonymizationUid.[uid#1, c2#2], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#1, c2#2]
        |     +-SetOperationItem
        |     | +-scan=
        |     | | +-ProjectScan
        |     | |   +-column_list=T1StringAnonymizationUid.[uid#3, c2#4]
        |     | |   +-input_scan=
        |     | |     +-TableScan(parse_location=166-190, column_list=T1StringAnonymizationUid.[uid#3, c2#4], table=T1StringAnonymizationUid, column_index_list=[0, 1])
        |     | +-output_column_list=T1StringAnonymizationUid.[uid#3, c2#4]
        |     +-SetOperationItem
        |       +-scan=
        |       | +-ProjectScan
        |       |   +-column_list=T2StringAnonymizationUid.[c1#5, uid#6]
        |       |   +-input_scan=
        |       |     +-TableScan(parse_location=227-251, column_list=T2StringAnonymizationUid.[c1#5, uid#6], table=T2StringAnonymizationUid, column_index_list=[0, 1])
        |       +-output_column_list=T2StringAnonymizationUid.[c1#5, uid#6]
        +-aggregate_list=
          +-$agg1#9 :=
            +-AggregateFunctionCall(ZetaSQL:$differential_privacy_count_star(optional(1) STRUCT<INT64, INT64> contribution_bounds_per_group) -> INT64)
              +-parse_location=33-38
              +-Literal(parse_location=75-83, type=STRUCT<INT64, INT64>, value={0, 100})
[REPLACED_LITERALS]
select with differential_privacy count(*, contribution_bounds_per_group => @_p0_STRUCT)
from (select * from T1StringAnonymizationUid
      union all
      select * from T1StringAnonymizationUid
      union all
      select * from T2StringAnonymizationUid);

Rewrite ERROR: Queries in UNION ALL have mismatched userid columns; query 1 has userid column 'uid' in position 1, query 3 has userid column 'uid' in position 2 [at 2:7]
from (select * from T1StringAnonymizationUid
      ^
==
