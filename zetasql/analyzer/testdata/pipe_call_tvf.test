[default language_features=MAXIMUM]
[language_features=NONE,+PIPES]
select 1 x
|> call tvf()
--
ERROR: Table-valued functions are not supported [at 2:9]
|> call tvf()
        ^
==

[default language_features=MAXIMUM,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS,+CREATE_TABLE_FUNCTION,+TEMPLATE_FUNCTIONS,+FUNCTION_ARGUMENTS_WITH_DEFAULTS,+PIPE_CALL_INPUT_TABLE]
select 1 x
|> call tvf()
--
ERROR: Table-valued function not found: tvf [at 2:9]
|> call tvf()
        ^
==

select 1 x
|> call sqrt()
--
ERROR: Table-valued function not found: sqrt [at 2:9]
|> call sqrt()
        ^
==

select 1 x
|> call tvf_no_args()
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its signature does not include a table-typed argument; Supported signature: TVF_NO_ARGS() [at 2:9]
|> call tvf_no_args()
        ^
==

select 1 x
|> call tvf_exactly_3_int64_args(1,2)
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its signature does not include a table-typed argument; Supported signature: TVF_EXACTLY_3_INT64_ARGS(INT64, INT64, INT64) [at 2:9]
|> call tvf_exactly_3_int64_args(1,2)
        ^
==

# Not allowed because the first table arg is a named-only arg.
# The error suggests using INPUT TABLE if the feature is enabled.
[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
select 1 x
|> call tvf_two_named_only_tables()
--
ALTERNATION GROUP: <empty>
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its first table-typed argument is a named-only argument; Supported signature: TVF_TWO_NAMED_ONLY_TABLES([table1 => TABLE], [table2 => TABLE]) [at 2:9]
|> call tvf_two_named_only_tables()
        ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because its first table-typed argument is a named-only argument; Supported signature: TVF_TWO_NAMED_ONLY_TABLES([table1 => TABLE], [table2 => TABLE]); Consider using INPUT TABLE for the table argument [at 2:9]
|> call tvf_two_named_only_tables()
        ^
==

# Its signature is ANY TABLE->TABLE<column_bool BOOL,column_bytes BYTES>
# Test the error message for both regular and value tables since they pass in
# the is_pipe_input_table bit separately.
select {{|AS STRUCT}} 1 x
|> call tvf_one_relation_arg_with_fixed_output((select true))
--
ALTERNATION GROUP: <empty>
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<x INT64> (from pipe input), BOOL
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 2:9]
|> call tvf_one_relation_arg_with_fixed_output((select true))
        ^
--
ALTERNATION GROUP: AS STRUCT
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<STRUCT<x INT64>> (from pipe input), BOOL
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 2:9]
|> call tvf_one_relation_arg_with_fixed_output((select true))
        ^
==

# Simple TVF call, with a hint.
[show_sqlbuilder_output]
select true, 5
|> call tvf_one_relation_arg_with_fixed_output({{|INPUT TABLE}}) @{hint=1}
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#3, column_bytes#4]
    +-hint_list=
    | +-hint := Literal(type=INT64, value=1)
    +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<$col1 BOOL, $col2 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$query.[$col1#1, $col2#2]
    |   |   +-expr_list=
    |   |   | +-$col1#1 := Literal(type=BOOL, value=true)
    |   |   | +-$col2#2 := Literal(type=INT64, value=5)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=$query.[$col1#1, $col2#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  tvfscan_4.column_bool AS column_bool,
  tvfscan_4.column_bytes AS column_bytes
FROM
  TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT((
    SELECT
      a_1 AS a_1,
      a_2 AS a_2
    FROM
      (
        SELECT
          true AS a_1,
          5 AS a_2
      ) AS projectscan_3
  )) @{ hint = 1 } AS tvfscan_4;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
SELECT
  true AS a_1,
  5 AS a_2
|> AS projectscan_3
|> SELECT
     a_1 AS a_1,
     a_2 AS a_2
|> CALL TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT() @{ hint = 1 } AS tvfscan_4
|> SELECT
     tvfscan_4.column_bool AS column_bool,
     tvfscan_4.column_bytes AS column_bytes;
==

select true
|> call tvf_one_relation_arg_with_fixed_output(6)
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<BOOL> (from pipe input), INT64
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 2:9]
|> call tvf_one_relation_arg_with_fixed_output(6)
        ^
==

select true
|> call tvf_one_relation_arg_with_fixed_output(TABLE KeyValue)
--
ERROR: No matching signature for tvf_one_relation_arg_with_fixed_output
  Argument types: TABLE<BOOL> (from pipe input), TABLE<Key INT64, Value STRING>
  Signature: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE)
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 2:9]
|> call tvf_one_relation_arg_with_fixed_output(TABLE KeyValue)
        ^
==

# Passing a table schema through.
select 1 x, true
|> call tvf_one_relation_arg_output_schema_is_input_schema({{|INPUT TABLE}})
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.x#3 AS x [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col2#4 AS `$col2` [BOOL]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[x#3, $col2#4]
    +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<x INT64, $col2 BOOL>) -> TABLE<x INT64, $col2 BOOL>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$query.[x#1, $col2#2]
    |   |   +-expr_list=
    |   |   | +-x#1 := Literal(type=INT64, value=1)
    |   |   | +-$col2#2 := Literal(type=BOOL, value=true)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=$query.[x#1, $col2#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE
==

# Passing a value table through.
select as value vt from TestExtraValueTable vt
|> call tvf_one_relation_arg_output_schema_is_input_schema()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#4 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#4]
    +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[TestExtraValueTable.value#1]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="vt")
    |   +-argument_column_list=[TestExtraValueTable.value#1]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE
==

# Column access after pass-through TVF.
from KeyValue
|> call tvf_one_relation_arg_output_schema_is_input_schema()
|> where key = 1
|> select *
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.Key#3 AS Key [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.Value#4 AS Value [STRING]
+-query=
  +-ProjectScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
    +-input_scan=
      +-FilterScan
        +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
        +-input_scan=
        | +-TVFScan
        |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
        |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
        |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
        |   +-argument_list=
        |   | +-FunctionArgument
        |   |   +-scan=
        |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |   |   +-argument_column_list=KeyValue.[Key#1, Value#2]
        |   +-column_index_list=[0, 1]
        |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.Key#3)
            +-Literal(type=INT64, value=1)
==

# This handles an optional table arg.
select "abc"
|> call tvf_one_optional_relation_arg_return_int64_value_table()
--
QueryStmt
+-output_column_list=
| +-tvf_one_optional_relation_arg_return_int64_value_table.$col0#2 AS `$col0` [INT64]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#2]
    +-tvf=tvf_one_optional_relation_arg_return_int64_value_table((optional ANY TABLE) -> TABLE<INT64>)
    +-signature=(TABLE<$col1 STRING>) -> TABLE<INT64>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.$col1#1]
    |   |   +-expr_list=
    |   |   | +-$col1#1 := Literal(type=STRING, value="abc")
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=[$query.$col1#1]
    +-column_index_list=[0]
    +-function_call_signature=(optional(1) ANY TABLE) -> TABLE<INT64>
==

select "abc"
|> call tvf_one_optional_relation_arg_return_int64_value_table(5)
--
ERROR: No matching signature for tvf_one_optional_relation_arg_return_int64_value_table
  Argument types: TABLE<STRING> (from pipe input), INT64
  Signature: TVF_ONE_OPTIONAL_RELATION_ARG_RETURN_INT64_VALUE_TABLE([TABLE])
    Signature accepts at most 1 argument, found 2 arguments (including pipe input table) [at 2:9]
|> call tvf_one_optional_relation_arg_return_int64_value_table(5)
        ^
==

select "abc"
|> call tvf_two_relation_args_return_proto_value_table()
--
ERROR: No matching signature for tvf_two_relation_args_return_proto_value_table
  Argument types: TABLE<STRING> (from pipe input)
  Signature: TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE(TABLE, TABLE)
    Signature requires at least 2 arguments, found 1 argument (including pipe input table) [at 2:9]
|> call tvf_two_relation_args_return_proto_value_table()
        ^
==

select "abc"
|> call tvf_two_relation_args_return_proto_value_table(TABLE KeyValue)
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_return_proto_value_table.$col0#4 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#4]
    +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    +-signature=(TABLE<$col1 STRING>, TABLE<Key INT64, Value STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.$col1#1]
    | | |   +-expr_list=
    | | |   | +-$col1#1 := Literal(type=STRING, value="abc")
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-argument_column_list=[$query.$col1#1]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#2, Value#3], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#2, Value#3]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
==

select "abc"
|> call tvf_two_relation_args_return_proto_value_table((select 5), (select 6))
--
ERROR: No matching signature for tvf_two_relation_args_return_proto_value_table
  Argument types: TABLE<STRING> (from pipe input), TABLE<INT64>, INT64
  Signature: TVF_TWO_RELATION_ARGS_RETURN_PROTO_VALUE_TABLE(TABLE, TABLE)
    Signature accepts at most 2 arguments, found 3 arguments (including pipe input table) [at 2:9]
|> call tvf_two_relation_args_return_proto_value_table((select 5), (select 6))
        ^
==

# This wants MODEL,TABLE but we end up calling it wth TABLE,TABLE.
# The error is a bit confusing because the argument table gets put in
# slot 1 since the pipe input goes in slot 2 (the expected TABLE arg).
select 1
|> call tvf_model_evaluation_args(TABLE KeyValue)
--
ERROR: No matching signature for tvf_model_evaluation_args
  Argument types: TABLE<Key INT64, Value STRING>, TABLE<INT64> (from pipe input)
  Signature: TVF_MODEL_EVALUATION_ARGS(MODEL, [TABLE], [STRUCT])
    Argument 1: expected MODEL, found TABLE<Key INT64, Value STRING> [at 2:9]
|> call tvf_model_evaluation_args(TABLE KeyValue)
        ^
==

from KeyValue
|> call tvf_model_evaluation_args(model onedoublemodel)
--
QueryStmt
+-output_column_list=
| +-tvf_model_evaluation_args.column_bool#3 AS column_bool [BOOL]
| +-tvf_model_evaluation_args.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_model_evaluation_args.[column_bool#3, column_bytes#4]
    +-tvf=tvf_model_evaluation_args((ANY MODEL, optional ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(ANY MODEL, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-model=
    | |   +-Model(model=OneDoubleModel)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY MODEL, optional(1) ANY TABLE, optional <struct>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The error suggests using INPUT TABLE if the feature is enabled.
[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
from KeyValue
|> call tvf_model_optional_string_optional_table(model onedoublemodel)
--
ALTERNATION GROUP: <empty>
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because it has an optional argument before its first table-typed argument; Supported signature: TVF_MODEL_OPTIONAL_STRING_OPTIONAL_TABLE(MODEL, [STRING], [TABLE]) [at 2:9]
|> call tvf_model_optional_string_optional_table(model onedoublemodel)
        ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because it has an optional argument before its first table-typed argument; Supported signature: TVF_MODEL_OPTIONAL_STRING_OPTIONAL_TABLE(MODEL, [STRING], [TABLE]); Consider using INPUT TABLE for the table argument [at 2:9]
|> call tvf_model_optional_string_optional_table(model onedoublemodel)
        ^
==

# The table argument is optional but this is allowed because the
# arguments before it are positional.
from KeyValue
|> call tvf_model_optional_table_named_string_default(model onedoublemodel)
--
QueryStmt
+-output_column_list=
| +-tvf_model_optional_table_named_string_default.column_bool#3 AS column_bool [BOOL]
| +-tvf_model_optional_table_named_string_default.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_model_optional_table_named_string_default.[column_bool#3, column_bytes#4]
    +-tvf=tvf_model_optional_table_named_string_default((ANY MODEL, optional ANY TABLE, optional STRING {default_value: "default"} foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(ANY MODEL, TABLE<Key INT64, Value STRING>, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-model=
    | |   +-Model(model=OneDoubleModel)
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=STRING, value="default")
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY MODEL, optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The arguemnt after the optional table is an optional arg
# passed named or positionally.
# The SQLBuilder currently doesn't know how to use pipe CALL for this
# because the table argument isn't first.
[show_sqlbuilder_output]
from KeyValue
|> call tvf_model_optional_table_named_string_default(
      model onedoublemodel, {{"abc"|foobar=>"abc"}})
--
QueryStmt
+-output_column_list=
| +-tvf_model_optional_table_named_string_default.column_bool#3 AS column_bool [BOOL]
| +-tvf_model_optional_table_named_string_default.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_model_optional_table_named_string_default.[column_bool#3, column_bytes#4]
    +-tvf=tvf_model_optional_table_named_string_default((ANY MODEL, optional ANY TABLE, optional STRING {default_value: "default"} foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(ANY MODEL, TABLE<Key INT64, Value STRING>, literal STRING) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-model=
    | |   +-Model(model=OneDoubleModel)
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=STRING, value="abc")
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY MODEL, optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  tvfscan_4.column_bool AS column_bool,
  tvfscan_4.column_bytes AS column_bytes
FROM
  TVF_MODEL_OPTIONAL_TABLE_NAMED_STRING_DEFAULT(MODEL OneDoubleModel, (
    SELECT
      a_1 AS Key,
      a_2 AS Value
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ), "abc") AS tvfscan_4;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  TVF_MODEL_OPTIONAL_TABLE_NAMED_STRING_DEFAULT(MODEL OneDoubleModel, (
    FROM
      KeyValue
    |> SELECT
         KeyValue.Key AS a_1,
         KeyValue.Value AS a_2
    |> AS keyvalue_3
    |> SELECT
         a_1 AS Key,
         a_2 AS Value
  ), "abc") AS tvfscan_4
|> SELECT
     tvfscan_4.column_bool AS column_bool,
     tvfscan_4.column_bytes AS column_bytes;
==

# This TVF expects TABLE<int64 `int64`, string `string`> with named columns.
select 5, "abc"
|> call tvf_one_relation_arg_int64_string_input_columns()
--
ERROR: Required column "int64" not found in table passed as argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 2:9]
|> call tvf_one_relation_arg_int64_string_input_columns()
        ^
==

# Named column matching with out-of-order and extra columns.
select null, "abc" string, true xxx, 5 int64
|> call tvf_one_relation_arg_int64_string_input_columns()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#5 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#6 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#5, column_bytes#6]
    +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=$query.[int64#4, string#2]
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$query.[$col1#1, string#2, xxx#3, int64#4]
    |   |       +-expr_list=
    |   |       | +-$col1#1 := Literal(type=INT64, value=NULL)
    |   |       | +-string#2 := Literal(type=STRING, value="abc")
    |   |       | +-xxx#3 := Literal(type=BOOL, value=true)
    |   |       | +-int64#4 := Literal(type=INT64, value=5)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-argument_column_list=$query.[int64#4, string#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The table scan produces lots of extra columns.
# They are pruned for TVF input with an extra ProjectScan.
# They are not pruned from the TableScan column_list because of SELECT *.
select * from SimpleTypes
|> call tvf_one_relation_arg_int64_string_input_columns()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
    +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#2, string#5]
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18, uuid#19]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3, uint64#4, string#5, bytes#6, bool#7, float#8, double#9, date#10, timestamp_seconds#11, timestamp_millis#12, timestamp_micros#13, timestamp_nanos#14, timestamp#15, numeric#16, bignumeric#17, json#18, uuid#19], table=SimpleTypes, column_index_list=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])
    |   +-argument_column_list=SimpleTypes.[int64#2, string#5]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# In this case where there is no SELECT *, the TableScan column_list
# does get pruned.
from SimpleTypes
|> call tvf_one_relation_arg_int64_string_input_columns()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#20 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#21 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#20, column_bytes#21]
    +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[int64#2, string#5]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=SimpleTypes.[int64#2, string#5], table=SimpleTypes, column_index_list=[1, 4])
    |   +-argument_column_list=SimpleTypes.[int64#2, string#5]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

select 5 int64
|> call tvf_one_relation_arg_int64_string_input_columns()
--
ERROR: Required column "string" not found in table passed as argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 2:9]
|> call tvf_one_relation_arg_int64_string_input_columns()
        ^
==

# Coercion of input columns from the lhs table input.
select cast(5 as int32) int64, cast(null as string) string
|> call tvf_one_relation_arg_int64_string_input_columns()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_string_input_columns.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_string_input_columns.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_string_input_columns.[column_bool#4, column_bytes#5]
    +-tvf=tvf_one_relation_arg_int64_string_input_columns((TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.int64#3, $query.string#2]
    |   |   +-expr_list=
    |   |   | +-int64#3 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=$query.int64#1)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$query.[int64#1, string#2]
    |   |       +-expr_list=
    |   |       | +-int64#1 := Literal(type=INT32, value=5, has_explicit_type=TRUE)
    |   |       | +-string#2 := Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-argument_column_list=[$subquery1.int64#3, $query.string#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64 INT64, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Coercion of NULL literals doesn't work. (It doesn't in regular syntax either.)
select NULL int64, NULL string
|> call tvf_one_relation_arg_int64_string_input_columns()
--
ERROR: Invalid type INT64 for column "string STRING" of argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 2:9]
|> call tvf_one_relation_arg_int64_string_input_columns()
        ^
==

# Duplicate column name.
select "abc" AS string, 5 AS int64, 6 as int64
|> call tvf_one_relation_arg_int64_string_input_columns()
--
ERROR: Table-valued function does not allow duplicate input columns named "int64" for argument 1 of TVF_ONE_RELATION_ARG_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 2:9]
|> call tvf_one_relation_arg_int64_string_input_columns()
        ^
==

# TVF with two relation args with required schemas.
# Column matching happens on both.
select bool, uint32 as uint64, string from simpletypes
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select bool, `date`, string from simpletypes))
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#40 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#41 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#40, column_bytes#41]
    +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$subquery2.uint64#39, SimpleTypes.string#5]
    | | |   +-expr_list=
    | | |   | +-uint64#39 :=
    | | |   |   +-Cast(UINT32 -> UINT64)
    | | |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    | | |   +-input_scan=
    | | |     +-ProjectScan
    | | |       +-column_list=SimpleTypes.[bool#7, uint32#3, string#5]
    | | |       +-input_scan=
    | | |         +-TableScan(column_list=SimpleTypes.[uint32#3, string#5, bool#7], table=SimpleTypes, column_index_list=[2, 4, 6])
    | | +-argument_column_list=[$subquery2.uint64#39, SimpleTypes.string#5]
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=SimpleTypes.[date#29, string#24]
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=SimpleTypes.[bool#26, date#29, string#24]
    |   |       +-input_scan=
    |   |         +-TableScan(column_list=SimpleTypes.[string#24, bool#26, date#29], table=SimpleTypes, column_index_list=[4, 6, 9])
    |   +-argument_column_list=SimpleTypes.[date#29, string#24]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Missing column in the second table.
# The error reports this as argument 2.
select uint32 as uint64, string from simpletypes
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select `date` from simpletypes))
--
ERROR: Required column "string" not found in table passed as argument 2 of TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) [at 3:5]
    (select `date` from simpletypes))
    ^
==

select uint32 as uint64, string from simpletypes
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(
    (select `date`, string from simpletypes), 456)
--
ERROR: No matching signature for tvf_two_relation_args_uint64_string_and_date_string_input_columns
  Argument types: TABLE<uint64 UINT32, string STRING> (from pipe input), TABLE<date DATE, string STRING>, INT64
  Signature: TVF_TWO_RELATION_ARGS_UINT64_STRING_AND_DATE_STRING_INPUT_COLUMNS(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>)
    Signature accepts at most 2 arguments, found 3 arguments (including pipe input table) [at 2:9]
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(
        ^
==

# Pass scalar where a relation is expected.
select uint32 as uint64, string from simpletypes
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(123)
--
ERROR: Table-valued function tvf_two_relation_args_uint64_string_and_date_string_input_columns argument 2 must be a relation (i.e. table subquery) [at 2:75]
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(123)
                                                                          ^
==

# Expected value table input.
select as value Key from KeyValue
|> call tvf_one_relation_arg_int64_input_value_table()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_input_value_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
    +-tvf=tvf_one_relation_arg_int64_input_value_table((TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#1]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-argument_column_list=[KeyValue.Key#1]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Expected value table input with non-value column input.
select Key from KeyValue
|> call tvf_one_relation_arg_int64_input_value_table()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_int64_input_value_table.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_int64_input_value_table.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_int64_input_value_table.[column_bool#3, column_bytes#4]
    +-tvf=tvf_one_relation_arg_int64_input_value_table((TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#1]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-argument_column_list=[KeyValue.Key#1]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

select * from KeyValue
|> call tvf_one_relation_arg_int64_input_value_table()
--
ERROR: Expected value table of type INT64 for argument 1; got TABLE<Key INT64, Value STRING> of TVF_ONE_RELATION_ARG_INT64_INPUT_VALUE_TABLE(TABLE<INT64>) [at 2:9]
|> call tvf_one_relation_arg_int64_input_value_table()
        ^
==

# Two chained TVFs. The first one returns a proto value table and
# the second one expects a value table with that proto.
select 1, 2
|> call tvf_two_relation_args_return_proto_value_table((select 3, 4))
|> call tvf_one_relation_arg_input_proto_value_table()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_input_proto_value_table.column_bool#6 AS column_bool [BOOL]
| +-tvf_one_relation_arg_input_proto_value_table.column_bytes#7 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_input_proto_value_table.[column_bool#6, column_bytes#7]
    +-tvf=tvf_one_relation_arg_input_proto_value_table((TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-TVFScan
    |   |   +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
    |   |   +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    |   |   +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<$col1 INT64, $col2 INT64>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |   |   +-argument_list=
    |   |   | +-FunctionArgument
    |   |   | | +-scan=
    |   |   | | | +-ProjectScan
    |   |   | | |   +-column_list=$query.[$col1#1, $col2#2]
    |   |   | | |   +-expr_list=
    |   |   | | |   | +-$col1#1 := Literal(type=INT64, value=1)
    |   |   | | |   | +-$col2#2 := Literal(type=INT64, value=2)
    |   |   | | |   +-input_scan=
    |   |   | | |     +-SingleRowScan
    |   |   | | +-argument_column_list=$query.[$col1#1, $col2#2]
    |   |   | +-FunctionArgument
    |   |   |   +-scan=
    |   |   |   | +-ProjectScan
    |   |   |   |   +-column_list=$subquery1.[$col1#3, $col2#4]
    |   |   |   |   +-expr_list=
    |   |   |   |   | +-$col1#3 := Literal(type=INT64, value=3)
    |   |   |   |   | +-$col2#4 := Literal(type=INT64, value=4)
    |   |   |   |   +-input_scan=
    |   |   |   |     +-SingleRowScan
    |   |   |   +-argument_column_list=$subquery1.[$col1#3, $col2#4]
    |   |   +-column_index_list=[0]
    |   |   +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |   +-argument_column_list=[tvf_two_relation_args_return_proto_value_table.$col0#5]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# More chained TVFs, including an identity TVF inside an rhs arg subquery.
select 1, 2
|> call tvf_two_relation_args_return_proto_value_table(
     (
       FROM KeyValue
       |> call tvf_one_relation_arg_output_schema_is_input_schema()
     )
   )
|> call tvf_one_relation_arg_output_schema_is_input_schema()
|> call tvf_one_relation_arg_input_proto_value_table()
|> call tvf_one_relation_arg_output_schema_is_input_schema()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.column_bool#11 AS column_bool [BOOL]
| +-tvf_one_relation_arg_output_schema_is_input_schema.column_bytes#12 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[column_bool#11, column_bytes#12]
    +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<column_bool BOOL, column_bytes BYTES>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-TVFScan
    |   |   +-column_list=tvf_one_relation_arg_input_proto_value_table.[column_bool#9, column_bytes#10]
    |   |   +-tvf=tvf_one_relation_arg_input_proto_value_table((TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |   |   +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |   |   +-argument_list=
    |   |   | +-FunctionArgument
    |   |   |   +-scan=
    |   |   |   | +-TVFScan
    |   |   |   |   +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#8]
    |   |   |   |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   |   |   |   +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |   |   |   |   +-argument_list=
    |   |   |   |   | +-FunctionArgument
    |   |   |   |   |   +-scan=
    |   |   |   |   |   | +-TVFScan
    |   |   |   |   |   |   +-column_list=[tvf_two_relation_args_return_proto_value_table.$col0#7]
    |   |   |   |   |   |   +-tvf=tvf_two_relation_args_return_proto_value_table((ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>)
    |   |   |   |   |   |   +-signature=(TABLE<$col1 INT64, $col2 INT64>, TABLE<Key INT64, Value STRING>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |   |   |   |   |   |   +-argument_list=
    |   |   |   |   |   |   | +-FunctionArgument
    |   |   |   |   |   |   | | +-scan=
    |   |   |   |   |   |   | | | +-ProjectScan
    |   |   |   |   |   |   | | |   +-column_list=$query.[$col1#1, $col2#2]
    |   |   |   |   |   |   | | |   +-expr_list=
    |   |   |   |   |   |   | | |   | +-$col1#1 := Literal(type=INT64, value=1)
    |   |   |   |   |   |   | | |   | +-$col2#2 := Literal(type=INT64, value=2)
    |   |   |   |   |   |   | | |   +-input_scan=
    |   |   |   |   |   |   | | |     +-SingleRowScan
    |   |   |   |   |   |   | | +-argument_column_list=$query.[$col1#1, $col2#2]
    |   |   |   |   |   |   | +-FunctionArgument
    |   |   |   |   |   |   |   +-scan=
    |   |   |   |   |   |   |   | +-TVFScan
    |   |   |   |   |   |   |   |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#5, Value#6]
    |   |   |   |   |   |   |   |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   |   |   |   |   |   |   |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
    |   |   |   |   |   |   |   |   +-argument_list=
    |   |   |   |   |   |   |   |   | +-FunctionArgument
    |   |   |   |   |   |   |   |   |   +-scan=
    |   |   |   |   |   |   |   |   |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |   |   |   |   |   |   |   |   |   +-argument_column_list=KeyValue.[Key#3, Value#4]
    |   |   |   |   |   |   |   |   +-column_index_list=[0, 1]
    |   |   |   |   |   |   |   |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    |   |   |   |   |   |   |   +-argument_column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#5, Value#6]
    |   |   |   |   |   |   +-column_index_list=[0]
    |   |   |   |   |   |   +-function_call_signature=(ANY TABLE, ANY TABLE) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    |   |   |   |   |   +-argument_column_list=[tvf_two_relation_args_return_proto_value_table.$col0#7]
    |   |   |   |   +-column_index_list=[0]
    |   |   |   |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    |   |   |   +-argument_column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#8]
    |   |   +-column_index_list=[0, 1]
    |   |   +-function_call_signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |   +-argument_column_list=tvf_one_relation_arg_input_proto_value_table.[column_bool#9, column_bytes#10]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE
==

# A TVF used in an expression subquery can do correlated references.
select (
    select * from i.structval
    |> call tvf_one_relation_arg_one_int64_arg(col)
    |> select column_bool
  )
from (select [struct("e" as string, 123 as int64)] as structval, 5 as col) as i
--
QueryStmt
+-output_column_list=
| +-$query.$col1#8 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#8]
    +-expr_list=
    | +-$col1#8 :=
    |   +-SubqueryExpr
    |     +-type=BOOL
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1)
    |     | +-ColumnRef(type=INT64, column=i.col#2)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[tvf_one_relation_arg_one_int64_arg.column_bool#6]
    |         +-input_scan=
    |           +-TVFScan
    |             +-column_list=[tvf_one_relation_arg_one_int64_arg.column_bool#6]
    |             +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |             +-signature=(TABLE<string STRING, int64 INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             | | +-scan=
    |             | | | +-ProjectScan
    |             | | |   +-column_list=$expr_subquery.[string#4, int64#5]
    |             | | |   +-expr_list=
    |             | | |   | +-string#4 :=
    |             | | |   | | +-GetStructField
    |             | | |   | |   +-type=STRING
    |             | | |   | |   +-expr=
    |             | | |   | |   | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.structval#3)
    |             | | |   | |   +-field_idx=0
    |             | | |   | +-int64#5 :=
    |             | | |   |   +-GetStructField
    |             | | |   |     +-type=INT64
    |             | | |   |     +-expr=
    |             | | |   |     | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.structval#3)
    |             | | |   |     +-field_idx=1
    |             | | |   +-input_scan=
    |             | | |     +-ArrayScan
    |             | | |       +-column_list=[$array.structval#3]
    |             | | |       +-array_expr_list=
    |             | | |       | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1, is_correlated=TRUE)
    |             | | |       +-element_column_list=[$array.structval#3]
    |             | | +-argument_column_list=$expr_subquery.[string#4, int64#5]
    |             | +-FunctionArgument
    |             |   +-expr=
    |             |     +-ColumnRef(type=INT64, column=i.col#2, is_correlated=TRUE)
    |             +-column_index_list=[0]
    |             +-function_call_signature=(ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-input_scan=
      +-ProjectScan
        +-column_list=i.[structval#1, col#2]
        +-expr_list=
        | +-structval#1 := Literal(type=ARRAY<STRUCT<string STRING, int64 INT64>>, value=[{string:"e", int64:123}])
        | +-col#2 := Literal(type=INT64, value=5)
        +-input_scan=
          +-SingleRowScan
==

# A TVF used in an UNNEST(ARRAY(...)) subquery can do correlated references
# to the lateral table on the left.
from (select [struct("e" as string, 123 as int64)] as structval, 5 as col) as i,
      unnest(array(
               select * from unnest(i.structval)
               |> call tvf_one_relation_arg_one_int64_arg(i.col)
               |> select column_bool))
--
QueryStmt
+-output_column_list=
| +-i.structval#1 AS structval [ARRAY<STRUCT<string STRING, int64 INT64>>]
| +-i.col#2 AS col [INT64]
| +-$array.$unnest2#8 AS `$unnest2` [BOOL]
+-query=
  +-ArrayScan
    +-column_list=[i.structval#1, i.col#2, $array.$unnest2#8]
    +-input_scan=
    | +-ProjectScan
    |   +-column_list=i.[structval#1, col#2]
    |   +-expr_list=
    |   | +-structval#1 := Literal(type=ARRAY<STRUCT<string STRING, int64 INT64>>, value=[{string:"e", int64:123}])
    |   | +-col#2 := Literal(type=INT64, value=5)
    |   +-input_scan=
    |     +-SingleRowScan
    +-array_expr_list=
    | +-SubqueryExpr
    |   +-type=ARRAY<BOOL>
    |   +-subquery_type=ARRAY
    |   +-parameter_list=
    |   | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1)
    |   | +-ColumnRef(type=INT64, column=i.col#2)
    |   +-subquery=
    |     +-ProjectScan
    |       +-column_list=[tvf_one_relation_arg_one_int64_arg.column_bool#6]
    |       +-input_scan=
    |         +-TVFScan
    |           +-column_list=[tvf_one_relation_arg_one_int64_arg.column_bool#6]
    |           +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |           +-signature=(TABLE<string STRING, int64 INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |           +-argument_list=
    |           | +-FunctionArgument
    |           | | +-scan=
    |           | | | +-ProjectScan
    |           | | |   +-column_list=$expr_subquery.[string#4, int64#5]
    |           | | |   +-expr_list=
    |           | | |   | +-string#4 :=
    |           | | |   | | +-GetStructField
    |           | | |   | |   +-type=STRING
    |           | | |   | |   +-expr=
    |           | | |   | |   | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.$unnest1#3)
    |           | | |   | |   +-field_idx=0
    |           | | |   | +-int64#5 :=
    |           | | |   |   +-GetStructField
    |           | | |   |     +-type=INT64
    |           | | |   |     +-expr=
    |           | | |   |     | +-ColumnRef(type=STRUCT<string STRING, int64 INT64>, column=$array.$unnest1#3)
    |           | | |   |     +-field_idx=1
    |           | | |   +-input_scan=
    |           | | |     +-ArrayScan
    |           | | |       +-column_list=[$array.$unnest1#3]
    |           | | |       +-array_expr_list=
    |           | | |       | +-ColumnRef(type=ARRAY<STRUCT<string STRING, int64 INT64>>, column=i.structval#1, is_correlated=TRUE)
    |           | | |       +-element_column_list=[$array.$unnest1#3]
    |           | | +-argument_column_list=$expr_subquery.[string#4, int64#5]
    |           | +-FunctionArgument
    |           |   +-expr=
    |           |     +-ColumnRef(type=INT64, column=i.col#2, is_correlated=TRUE)
    |           +-column_index_list=[0]
    |           +-function_call_signature=(ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-element_column_list=[$array.$unnest2#8]
==

# TVF gets a column directly from a table input on the lhs.
from KeyValue
|> call tvf_key_input_column_extra_input_columns_allowed()
--
QueryStmt
+-output_column_list=
| +-tvf_key_input_column_extra_input_columns_allowed.column_bool#3 AS column_bool [BOOL]
| +-tvf_key_input_column_extra_input_columns_allowed.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_key_input_column_extra_input_columns_allowed.[column_bool#3, column_bytes#4]
    +-tvf=tvf_key_input_column_extra_input_columns_allowed((TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Key#1]
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
    |   +-argument_column_list=[KeyValue.Key#1]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<key INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# TVF resolver doesn't match fields of value tables as expected columns.
(select as struct 5 key, 6 value)
|> call tvf_key_input_column_extra_input_columns_allowed()
--
ERROR: Required column "key" not found in table passed as argument 1 of TVF_KEY_INPUT_COLUMN_EXTRA_INPUT_COLUMNS_ALLOWED(TABLE<key INT64>) [at 2:9]
|> call tvf_key_input_column_extra_input_columns_allowed()
        ^
==

# Here the expected column from the lhs table requires a coercion.
from simpletypes
|> call tvf_uint64_input_column_named_uint32()
--
QueryStmt
+-output_column_list=
| +-tvf_uint64_input_column_named_uint32.column_bool#21 AS column_bool [BOOL]
| +-tvf_uint64_input_column_named_uint32.column_bytes#22 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_uint64_input_column_named_uint32.[column_bool#21, column_bytes#22]
    +-tvf=tvf_uint64_input_column_named_uint32((TABLE<uint32 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<uint32 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.uint32#20]
    |   |   +-expr_list=
    |   |   | +-uint32#20 :=
    |   |   |   +-Cast(UINT32 -> UINT64)
    |   |   |     +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[SimpleTypes.uint32#3], table=SimpleTypes, column_index_list=[2])
    |   +-argument_column_list=[$subquery1.uint32#20]
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<uint32 UINT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Value table on the lhs has pseudo-columns (RowId and Filename)
from TestExtraValueTable
|> where RowId is null
|> call tvf_one_relation_arg_with_fixed_output()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_with_fixed_output.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_relation_arg_with_fixed_output.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_with_fixed_output.[column_bool#4, column_bytes#5]
    +-tvf=tvf_one_relation_arg_with_fixed_output((ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-FilterScan
    |   |   +-column_list=TestExtraValueTable.[value#1, RowId#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=TestExtraValueTable.[value#1, RowId#3], table=TestExtraValueTable, column_index_list=[0, 2])
    |   |   +-filter_expr=
    |   |     +-FunctionCall(ZetaSQL:$is_null(BYTES) -> BOOL)
    |   |       +-ColumnRef(type=BYTES, column=TestExtraValueTable.RowId#3)
    |   +-argument_column_list=[TestExtraValueTable.value#1]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Value table on the lhs has pseudo-columns and passes through as a value table.
from TestExtraValueTable
|> where RowId is null
|> call tvf_one_relation_arg_output_schema_is_input_schema()
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.$col0#4 AS `$col0` [PROTO<zetasql_test__.TestExtraPB>]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_one_relation_arg_output_schema_is_input_schema.$col0#4]
    +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<PROTO<zetasql_test__.TestExtraPB>>) -> TABLE<PROTO<zetasql_test__.TestExtraPB>>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-FilterScan
    |   |   +-column_list=TestExtraValueTable.[value#1, RowId#3]
    |   |   +-input_scan=
    |   |   | +-TableScan(column_list=TestExtraValueTable.[value#1, RowId#3], table=TestExtraValueTable, column_index_list=[0, 2])
    |   |   +-filter_expr=
    |   |     +-FunctionCall(ZetaSQL:$is_null(BYTES) -> BOOL)
    |   |       +-ColumnRef(type=BYTES, column=TestExtraValueTable.RowId#3)
    |   +-argument_column_list=[TestExtraValueTable.value#1]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE
==

# Pseudo-columns do not pass through.
from TestExtraValueTable
|> where RowId is null
|> call tvf_one_relation_arg_output_schema_is_input_schema()
|> where RowId is not null
--
ERROR: Unrecognized name: RowId [at 4:10]
|> where RowId is not null
         ^
==

# TVF in a nested catalog.
# Java test framework does not supported nested catalogs.
[no_java]
from EnumTable
|> call nested_catalog.nested_tvf_one()
--
QueryStmt
+-output_column_list=
| +-nested_catalog.nested_tvf_one.key#7 AS key [INT64]
+-query=
  +-TVFScan
    +-column_list=[nested_catalog.nested_tvf_one.key#7]
    +-tvf=nested_catalog.nested_tvf_one((TABLE<key INT64>) -> TABLE<key INT64>)
    +-signature=(TABLE<key INT64>) -> TABLE<key INT64>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.key#6]
    |   |   +-expr_list=
    |   |   | +-key#6 :=
    |   |   |   +-Cast(INT32 -> INT64)
    |   |   |     +-ColumnRef(type=INT32, column=EnumTable.key#1)
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=[EnumTable.key#1], table=EnumTable, column_index_list=[0])
    |   +-argument_column_list=[$subquery1.key#6]
    +-column_index_list=[0]
    +-function_call_signature=(TABLE<key INT64>) -> TABLE<key INT64>
==

# Templated TVF with SQL body that looks for some columns, ignores others.
select value, 111 as xx, key from KeyValue
|> call tvf_templated_select_relation_arg_using_column_names()
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_column_names.key#4 AS key [INT64]
| +-tvf_templated_select_relation_arg_using_column_names.value#5 AS value [STRING]
+-query=
  +-TVFScan
    +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#4, value#5]
    +-tvf=tvf_templated_select_relation_arg_using_column_names((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<value STRING, xx INT64, key INT64>) -> TABLE<key INT64, value STRING>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[KeyValue.Value#2, $query.xx#3, KeyValue.Key#1]
    |   |   +-expr_list=
    |   |   | +-xx#3 := Literal(type=INT64, value=111)
    |   |   +-input_scan=
    |   |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=[KeyValue.Value#2, $query.xx#3, KeyValue.Key#1]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_column_names(TABLE<value STRING, xx INT64, key INT64>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#3 AS key [INT64]
| +-t.value#1 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[key#3, value#1]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[value#1, key#3], name="t")
==

# Same as previous, directly from the table.
from KeyValue
|> call tvf_templated_select_relation_arg_using_column_names()
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_relation_arg_using_column_names.key#3 AS key [INT64]
| +-tvf_templated_select_relation_arg_using_column_names.value#4 AS value [STRING]
+-query=
  +-TVFScan
    +-column_list=tvf_templated_select_relation_arg_using_column_names.[key#3, value#4]
    +-tvf=tvf_templated_select_relation_arg_using_column_names((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<key INT64, value STRING>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_select_relation_arg_using_column_names(TABLE<Key INT64, Value STRING>) -> TABLE<key INT64, value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.Key#1 AS key [INT64]
| +-t.Value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=t.[Key#1, Value#2]
    +-input_scan=
      +-RelationArgumentScan(column_list=t.[Key#1, Value#2], name="t")
==

# Templated TVF with non-relation in arg 1.
select 42
|> call tvf_templated_select_scalar_and_relation_args(5)
--
ERROR: Required column "key" not found in table passed as argument 2 of TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>) [at 2:9]
|> call tvf_templated_select_scalar_and_relation_args(5)
        ^
==

select 5, 42 key, 6 y
|> call tvf_templated_select_scalar_and_relation_args(5)
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_scalar_and_relation_args.key#4 AS key [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_templated_select_scalar_and_relation_args.key#4]
    +-tvf=tvf_templated_select_scalar_and_relation_args((INT64, TABLE<key INT64>) -> ANY TABLE)
    +-signature=(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=5)
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$query.key#2]
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$query.[$col1#1, key#2, y#3]
    |   |       +-expr_list=
    |   |       | +-$col1#1 := Literal(type=INT64, value=5)
    |   |       | +-key#2 := Literal(type=INT64, value=42)
    |   |       | +-y#3 := Literal(type=INT64, value=6)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-argument_column_list=[$query.key#2]
    +-column_index_list=[0]
    +-function_call_signature=(INT64, TABLE<key INT64>) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_select_scalar_and_relation_args(literal INT64, TABLE<key INT64>) -> TABLE<key INT64>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-t.key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t.key#1]
    +-input_scan=
      +-FilterScan
        +-column_list=[t.key#1]
        +-input_scan=
        | +-RelationArgumentScan(column_list=[t.key#1], name="t")
        +-filter_expr=
          +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
            +-ColumnRef(type=INT64, column=t.key#1)
            +-ArgumentRef(type=INT64, name="x")
==

select 42
|> call tvf_templated_select_scalar_and_relation_args("abc")
--
ERROR: No matching signature for tvf_templated_select_scalar_and_relation_args
  Argument types: STRING, TABLE<INT64> (from pipe input)
  Signature: TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>)
    Argument 1: Unable to coerce type STRING to expected type INT64 [at 2:9]
|> call tvf_templated_select_scalar_and_relation_args("abc")
        ^
==

# The error suggests using INPUT TABLE if the feature is enabled.
[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS{{|,+PIPE_CALL_INPUT_TABLE}}]
select 42
|> call tvf_templated_select_scalar_and_relation_args()
--
ALTERNATION GROUP: <empty>
--
ERROR: Table-valued function call in pipe CALL requires at least 1 positional argument because its first table argument is in position 2, but the call has no arguments; Supported signature: TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>) [at 2:9]
|> call tvf_templated_select_scalar_and_relation_args()
        ^
--
ALTERNATION GROUP: ,+PIPE_CALL_INPUT_TABLE
--
ERROR: Table-valued function call in pipe CALL requires at least 1 positional argument because its first table argument is in position 2, but the call has no arguments; Supported signature: TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>); Consider using INPUT TABLE for the table argument [at 2:9]
|> call tvf_templated_select_scalar_and_relation_args()
        ^
==

select 42
|> call tvf_templated_select_scalar_and_relation_args(TABLE KeyValue)
--
ERROR: No matching signature for tvf_templated_select_scalar_and_relation_args
  Argument types: TABLE<Key INT64, Value STRING>, TABLE<INT64> (from pipe input)
  Signature: TVF_TEMPLATED_SELECT_SCALAR_AND_RELATION_ARGS(INT64, TABLE<key INT64>)
    Argument 1: expected INT64, found TABLE<Key INT64, Value STRING> [at 2:9]
|> call tvf_templated_select_scalar_and_relation_args(TABLE KeyValue)
        ^
==

# Templated SQL TVF with two relations.
# SQLBuilder can't handle this case where one TVF outputs two columns with
# duplicate names because it's impossible to write an explicit select list.
[no_run_sqlbuilder]
from KeyValue
|> call tvf_templated_select_two_relation_args(table KeyValue)
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_two_relation_args.key#5 AS key [INT64]
| +-tvf_templated_select_two_relation_args.Value#6 AS Value [STRING]
| +-tvf_templated_select_two_relation_args.Value#7 AS Value [STRING]
+-query=
  +-TVFScan
    +-column_list=tvf_templated_select_two_relation_args.[key#5, Value#6, Value#7]
    +-tvf=tvf_templated_select_two_relation_args((ANY TABLE, ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<Key INT64, Value STRING>, TABLE<Key INT64, Value STRING>) -> TABLE<key INT64, Value STRING, Value STRING>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#3, Value#4]
    +-column_index_list=[0, 1, 2]
    +-function_call_signature=(ANY TABLE, ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_select_two_relation_args(TABLE<Key INT64, Value STRING>, TABLE<Key INT64, Value STRING>) -> TABLE<key INT64, Value STRING, Value STRING>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-w1.Key#5 AS key [INT64]
| +-w1.Value#6 AS Value [STRING]
| +-w2.Value#8 AS Value [STRING]
+-query=
  +-WithScan
    +-column_list=[w1.Key#5, w1.Value#6, w2.Value#8]
    +-is_ordered=TRUE
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="w1"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=s.[Key#1, Value#2]
    | |     +-input_scan=
    | |       +-RelationArgumentScan(column_list=s.[Key#1, Value#2], name="s")
    | +-WithEntry
    |   +-with_query_name="w2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[Key#3, Value#4]
    |       +-input_scan=
    |         +-RelationArgumentScan(column_list=t.[Key#3, Value#4], name="t")
    +-query=
      +-LimitOffsetScan
        +-column_list=[w1.Key#5, w1.Value#6, w2.Value#8]
        +-is_ordered=TRUE
        +-input_scan=
        | +-OrderByScan
        |   +-column_list=[w1.Key#5, w1.Value#6, w2.Value#8]
        |   +-is_ordered=TRUE
        |   +-input_scan=
        |   | +-JoinScan
        |   |   +-column_list=[w1.Key#5, w1.Value#6, w2.Key#7, w2.Value#8]
        |   |   +-left_scan=
        |   |   | +-WithRefScan(column_list=w1.[Key#5, Value#6], with_query_name="w1")
        |   |   +-right_scan=
        |   |   | +-WithRefScan(column_list=w2.[Key#7, Value#8], with_query_name="w2")
        |   |   +-join_expr=
        |   |   | +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        |   |   |   +-ColumnRef(type=INT64, column=w1.Key#5)
        |   |   |   +-ColumnRef(type=INT64, column=w2.Key#7)
        |   |   +-has_using=TRUE
        |   +-order_by_item_list=
        |     +-OrderByItem
        |       +-column_ref=
        |         +-ColumnRef(type=INT64, column=w1.Key#5)
        +-limit=
          +-Literal(type=INT64, value=1)
==

# Templated SQL TVF taking a value table.
from TestStructValueTable
|> call tvf_templated_select_a()
--
QueryStmt
+-output_column_list=
| +-tvf_templated_select_a.a#2 AS a [INT32]
+-query=
  +-TVFScan
    +-column_list=[tvf_templated_select_a.a#2]
    +-tvf=tvf_templated_select_a((ANY TABLE) -> ANY TABLE)
    +-signature=(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=[TestStructValueTable.value#1], table=TestStructValueTable, column_index_list=[0])
    |   +-argument_column_list=[TestStructValueTable.value#1]
    +-column_index_list=[0]
    +-function_call_signature=(ANY TABLE) -> ANY TABLE

With Templated SQL TVF signature:
  tvf_templated_select_a(TABLE<STRUCT<a INT32, b STRING>>) -> TABLE<a INT32>
containing resolved templated query:
QueryStmt
+-output_column_list=
| +-$query.a#2 AS a [INT32]
+-query=
  +-ProjectScan
    +-column_list=[$query.a#2]
    +-expr_list=
    | +-a#2 :=
    |   +-GetStructField
    |     +-type=INT32
    |     +-expr=
    |     | +-ColumnRef(type=STRUCT<a INT32, b STRING>, column=x.$value_column#1)
    |     +-field_idx=0
    +-input_scan=
      +-RelationArgumentScan(column_list=[x.$value_column#1], name="x", is_value_table=TRUE)
==

# Two input tables from WITH clause, passed as lhs and rhs table inputs
# with required schemas, using TABLE or FROM for the argument.
with q1 as (select uint64, string from SimpleTypes),
     q2 as (select date, string from SimpleTypes)
from q1
|> call tvf_two_relation_args_uint64_string_and_date_string_input_columns(
  {{TABLE q2|(FROM q2)}})
--
QueryStmt
+-output_column_list=
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bool#43 AS column_bool [BOOL]
| +-tvf_two_relation_args_uint64_string_and_date_string_input_columns.column_bytes#44 AS column_bytes [BYTES]
+-query=
  +-WithScan
    +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#43, column_bytes#44]
    +-with_entry_list=
    | +-WithEntry
    | | +-with_query_name="q1"
    | | +-with_subquery=
    | |   +-ProjectScan
    | |     +-column_list=SimpleTypes.[uint64#4, string#5]
    | |     +-input_scan=
    | |       +-TableScan(column_list=SimpleTypes.[uint64#4, string#5], table=SimpleTypes, column_index_list=[3, 4])
    | +-WithEntry
    |   +-with_query_name="q2"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=SimpleTypes.[date#29, string#24]
    |       +-input_scan=
    |         +-TableScan(column_list=SimpleTypes.[string#24, date#29], table=SimpleTypes, column_index_list=[4, 9])
    +-query=
      +-TVFScan
        +-column_list=tvf_two_relation_args_uint64_string_and_date_string_input_columns.[column_bool#43, column_bytes#44]
        +-tvf=tvf_two_relation_args_uint64_string_and_date_string_input_columns((TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>)
        +-signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
        +-argument_list=
        | +-FunctionArgument
        | | +-scan=
        | | | +-WithRefScan(column_list=q1.[uint64#39, string#40], with_query_name="q1")
        | | +-argument_column_list=q1.[uint64#39, string#40]
        | +-FunctionArgument
        |   +-scan=
        |   | +-WithRefScan(column_list=q2.[date#41, string#42], with_query_name="q2")
        |   +-argument_column_list=q2.[date#41, string#42]
        +-column_index_list=[0, 1]
        +-function_call_signature=(TABLE<uint64 UINT64, string STRING>, TABLE<date DATE, string STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# This TVF takes a required table, optional scalar, and optionally named table.
# It works to pass the optional table after the optional scalar positionally.
[show_sqlbuilder_output]
from KeyValue
|> call tvf_table_optional_scalar_named_table(
     10, (select 20))
--
QueryStmt
+-output_column_list=
| +-tvf_table_optional_scalar_named_table.column_bool#4 AS column_bool [BOOL]
| +-tvf_table_optional_scalar_named_table.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_table_optional_scalar_named_table.[column_bool#4, column_bytes#5]
    +-tvf=tvf_table_optional_scalar_named_table((ANY TABLE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64, Value STRING>, literal INT64, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=10)
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.$col1#3]
    |   |   +-expr_list=
    |   |   | +-$col1#3 := Literal(type=INT64, value=20)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=[$subquery1.$col1#3]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE, optional(1) INT64, optional(1) ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  tvfscan_6.column_bool AS column_bool,
  tvfscan_6.column_bytes AS column_bytes
FROM
  TVF_TABLE_OPTIONAL_SCALAR_NAMED_TABLE((
    SELECT
      a_1 AS Key,
      a_2 AS Value
    FROM
      (
        SELECT
          KeyValue.Key AS a_1,
          KeyValue.Value AS a_2
        FROM
          KeyValue
      ) AS keyvalue_3
  ), 10, (
    SELECT
      a_4 AS a_4
    FROM
      (
        SELECT
          20 AS a_4
      ) AS projectscan_5
  )) AS tvfscan_6;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  KeyValue
|> SELECT
     KeyValue.Key AS a_1,
     KeyValue.Value AS a_2
|> AS keyvalue_3
|> SELECT
     a_1 AS Key,
     a_2 AS Value
|> CALL TVF_TABLE_OPTIONAL_SCALAR_NAMED_TABLE(10, (
     SELECT
       20 AS a_4
     |> AS projectscan_5
     |> SELECT
          a_4 AS a_4
   )) AS tvfscan_6
|> SELECT
     tvfscan_6.column_bool AS column_bool,
     tvfscan_6.column_bytes AS column_bytes;
==

# It works to pass the optional table named after the optional scalar.
from KeyValue
|> call tvf_table_optional_scalar_named_table(
     10, foobar=>(select 20))
--
QueryStmt
+-output_column_list=
| +-tvf_table_optional_scalar_named_table.column_bool#4 AS column_bool [BOOL]
| +-tvf_table_optional_scalar_named_table.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_table_optional_scalar_named_table.[column_bool#4, column_bytes#5]
    +-tvf=tvf_table_optional_scalar_named_table((ANY TABLE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64, Value STRING>, literal INT64, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=10)
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.$col1#3]
    |   |   +-expr_list=
    |   |   | +-$col1#3 := Literal(type=INT64, value=20)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=[$subquery1.$col1#3]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE, optional(1) INT64, optional(1) ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# It works to pass the optional table named without the optional scalar.
from KeyValue
|> call tvf_table_optional_scalar_named_table(
     foobar=>(select 20))
--
QueryStmt
+-output_column_list=
| +-tvf_table_optional_scalar_named_table.column_bool#4 AS column_bool [BOOL]
| +-tvf_table_optional_scalar_named_table.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_table_optional_scalar_named_table.[column_bool#4, column_bytes#5]
    +-tvf=tvf_table_optional_scalar_named_table((ANY TABLE, optional ANY TYPE, optional ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64, Value STRING>, null INT64, TABLE<$col1 INT64>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=NULL)
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.$col1#3]
    |   |   +-expr_list=
    |   |   | +-$col1#3 := Literal(type=INT64, value=20)
    |   |   +-input_scan=
    |   |     +-SingleRowScan
    |   +-argument_column_list=[$subquery1.$col1#3]
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE, optional(1) INT64, optional(1) ANY TABLE foobar) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Too many args.
from KeyValue
|> call tvf_table_optional_scalar_named_table(
     10, 11, foobar=>(select 20))
--
ERROR: Table-valued function tvf_table_optional_scalar_named_table argument 3 ('foobar') must be a relation (i.e. table subquery) [at 3:10]
     10, 11, foobar=>(select 20))
         ^
==

from KeyValue
|> call tvf_table_optional_scalar_named_table(
     foobar=>17)
--
ERROR: Table-valued function tvf_table_optional_scalar_named_table argument 3 ('foobar') must be a relation (i.e. table subquery) [at 3:14]
     foobar=>17)
             ^
==

# Call TVF that does not accept extra columns in the input table.
select value as string, key + 1 as int64, 42 as extra_col from keyvalue
|> call tvf_one_relation_arg_only_int64_string_input_columns()
--
ERROR: Function does not allow extra input column named "extra_col" for argument 1 of TVF_ONE_RELATION_ARG_ONLY_INT64_STRING_INPUT_COLUMNS(TABLE<int64 INT64, string STRING>) [at 2:9]
|> call tvf_one_relation_arg_only_int64_string_input_columns()
        ^
==

# Call TVF where one of the expected columns is a pseudo-column.
# This does not work currently.
from EnumTable
|> call tvf_key_filename_input_columns()
--
ERROR: Required column "filename" not found in table passed as argument 1 of TVF_KEY_FILENAME_INPUT_COLUMNS(TABLE<key INT64, filename STRING>) [at 2:9]
|> call tvf_key_filename_input_columns()
        ^
==

# DESCRIPTOR arg.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor(descriptor(test_col))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_descriptor.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_descriptor.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_one_descriptor.[column_bool#2, column_bytes#3]
    +-tvf=tvf_one_relation_arg_one_descriptor((TABLE<int64a INT64>, ANY DESCRIPTOR) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64a INT64>, ANY DESCRIPTOR) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.int64a#1]
    | | |   +-expr_list=
    | | |   | +-int64a#1 := Literal(type=INT64, value=42)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-argument_column_list=[$query.int64a#1]
    | +-FunctionArgument
    |   +-descriptor_arg=
    |     +-Descriptor(descriptor_column_name_list=[test_col])
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64a INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# Wrong type for DESCRIPTOR arg.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor((select 1))
--
ERROR: Table-valued function tvf_one_relation_arg_one_descriptor argument 2 must be a DESCRIPTOR [at 2:45]
|> call tvf_one_relation_arg_one_descriptor((select 1))
                                            ^
==

# Wrong type for DESCRIPTOR arg.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor(15)
--
ERROR: Table-valued function tvf_one_relation_arg_one_descriptor argument 2 must be a DESCRIPTOR [at 2:45]
|> call tvf_one_relation_arg_one_descriptor(15)
                                            ^
==

# Wrong type for DESCRIPTOR arg.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor(model onedoublemodel)
--
ERROR: No matching signature for tvf_one_relation_arg_one_descriptor
  Argument types: TABLE<int64a INT64> (from pipe input), MODEL
  Signature: TVF_ONE_RELATION_ARG_ONE_DESCRIPTOR(TABLE<int64a INT64>, DESCRIPTOR)
    Argument 2: expected DESCRIPTOR, found MODEL [at 2:9]
|> call tvf_one_relation_arg_one_descriptor(model onedoublemodel)
        ^
==

# DESCRIPTOR arg with resolved names.
# The `descriptor_column_list` has a column from the pipe input table.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor_resolved_names(descriptor(int64a))
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_descriptor_resolved_names.column_bool#2 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_descriptor_resolved_names.column_bytes#3 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_one_descriptor_resolved_names.[column_bool#2, column_bytes#3]
    +-tvf=tvf_one_relation_arg_one_descriptor_resolved_names((TABLE<int64a INT64>, ANY DESCRIPTOR) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<int64a INT64>, ANY DESCRIPTOR) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-ProjectScan
    | | |   +-column_list=[$query.int64a#1]
    | | |   +-expr_list=
    | | |   | +-int64a#1 := Literal(type=INT64, value=42)
    | | |   +-input_scan=
    | | |     +-SingleRowScan
    | | +-argument_column_list=[$query.int64a#1]
    | +-FunctionArgument
    |   +-descriptor_arg=
    |     +-Descriptor(descriptor_column_list=[$query.int64a#1], descriptor_column_name_list=[int64a])
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<int64a INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# DESCRIPTOR arg with missing resolved names.
select 42 as int64a
|> call tvf_one_relation_arg_one_descriptor_resolved_names(descriptor(int64axxx))
--
ERROR: DESCRIPTOR specifies int64axxx, which does not exist in the table passed as argument 1 [at 2:71]
...ne_descriptor_resolved_names(descriptor(int64axxx))
                                           ^
==

# MODEL argument
# Java does not support MODELs.
[no_java]
from KeyValue
|> call tvf_one_relation_one_model_arg_with_fixed_output(model onedoublemodel)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_one_model_arg_with_fixed_output.double#3 AS double [DOUBLE]
| +-tvf_one_relation_one_model_arg_with_fixed_output.string#4 AS string [STRING]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_one_model_arg_with_fixed_output.[double#3, string#4]
    +-tvf=tvf_one_relation_one_model_arg_with_fixed_output((TABLE<key INT64, value STRING>, ANY MODEL) -> TABLE<double DOUBLE, string STRING>)
    +-signature=(TABLE<Key INT64, Value STRING>, ANY MODEL) -> TABLE<double DOUBLE, string STRING>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-model=
    |     +-Model(model=OneDoubleModel)
    +-column_index_list=[0, 1]
    +-function_call_signature=(TABLE<key INT64, value STRING>, ANY MODEL) -> TABLE<double DOUBLE, string STRING>
==

# MODEL argument with missing columns.
# Java does not support MODELs.
[no_java]
select 1 a
|> call tvf_one_relation_one_model_arg_with_fixed_output(model onedoublemodel)
--
ERROR: Function does not allow extra input column named "a" for argument 1 of TVF_ONE_RELATION_ONE_MODEL_ARG_WITH_FIXED_OUTPUT(TABLE<key INT64, value STRING>, MODEL) [at 2:9]
|> call tvf_one_relation_one_model_arg_with_fixed_output(model onedoublemodel)
        ^
==

# Calling a TVF with an alias, producing a range variable.
from KeyValue
|> call tvf_one_relation_arg_output_schema_is_input_schema() AS tvf1
|> WHERE tvf1.key = 4 AND value = 'abc'
|> call tvf_one_relation_arg_output_schema_is_input_schema() tvf2
|> WHERE tvf2.key = 5
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.Key#5 AS Key [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.Value#6 AS Value [STRING]
+-query=
  +-FilterScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#5, Value#6]
    +-input_scan=
    | +-TVFScan
    |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#5, Value#6]
    |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
    |   +-argument_list=
    |   | +-FunctionArgument
    |   |   +-scan=
    |   |   | +-FilterScan
    |   |   |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
    |   |   |   +-input_scan=
    |   |   |   | +-TVFScan
    |   |   |   |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
    |   |   |   |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   |   |   |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
    |   |   |   |   +-argument_list=
    |   |   |   |   | +-FunctionArgument
    |   |   |   |   |   +-scan=
    |   |   |   |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   |   |   |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    |   |   |   |   +-column_index_list=[0, 1]
    |   |   |   |   +-alias="tvf1"
    |   |   |   |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    |   |   |   +-filter_expr=
    |   |   |     +-FunctionCall(ZetaSQL:$and(BOOL, repeated(1) BOOL) -> BOOL)
    |   |   |       +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
    |   |   |       | +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.Key#3)
    |   |   |       | +-Literal(type=INT64, value=4)
    |   |   |       +-FunctionCall(ZetaSQL:$equal(STRING, STRING) -> BOOL)
    |   |   |         +-ColumnRef(type=STRING, column=tvf_one_relation_arg_output_schema_is_input_schema.Value#4)
    |   |   |         +-Literal(type=STRING, value="abc")
    |   |   +-argument_column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
    |   +-column_index_list=[0, 1]
    |   +-alias="tvf2"
    |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.Key#5)
        +-Literal(type=INT64, value=5)
==

# Range variable from the earlier TVF is not still visible.
from KeyValue
|> call tvf_one_relation_arg_output_schema_is_input_schema() AS tvf1
|> call tvf_one_relation_arg_output_schema_is_input_schema() tvf2
|> WHERE tvf1.key = 5
--
ERROR: Unrecognized name: tvf1; Did you mean tvf2? [at 4:10]
|> WHERE tvf1.key = 5
         ^
==

# JOIN a pipe and regular TVF call using their aliases in an ON clause.
from KeyValue
|> call tvf_one_relation_arg_output_schema_is_input_schema() AS tvf1
|> JOIN
     tvf_one_relation_arg_output_schema_is_input_schema(TABLE KeyValue) AS tvf2
   ON tvf1.key = tvf2.key
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_output_schema_is_input_schema.Key#3 AS Key [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.Value#4 AS Value [STRING]
| +-tvf_one_relation_arg_output_schema_is_input_schema.Key#7 AS Key [INT64]
| +-tvf_one_relation_arg_output_schema_is_input_schema.Value#8 AS Value [STRING]
+-query=
  +-JoinScan
    +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4, Key#7, Value#8]
    +-left_scan=
    | +-TVFScan
    |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#3, Value#4]
    |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
    |   +-argument_list=
    |   | +-FunctionArgument
    |   |   +-scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    |   +-column_index_list=[0, 1]
    |   +-alias="tvf1"
    |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    +-right_scan=
    | +-TVFScan
    |   +-column_list=tvf_one_relation_arg_output_schema_is_input_schema.[Key#7, Value#8]
    |   +-tvf=tvf_one_relation_arg_output_schema_is_input_schema((ANY TABLE) -> ANY TABLE)
    |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<Key INT64, Value STRING>
    |   +-argument_list=
    |   | +-FunctionArgument
    |   |   +-scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#5, Value#6], table=KeyValue, column_index_list=[0, 1])
    |   |   +-argument_column_list=KeyValue.[Key#5, Value#6]
    |   +-column_index_list=[0, 1]
    |   +-alias="tvf2"
    |   +-function_call_signature=(ANY TABLE) -> ANY TABLE
    +-join_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.Key#3)
        +-ColumnRef(type=INT64, column=tvf_one_relation_arg_output_schema_is_input_schema.Key#7)
==

# TVF returning a value table, accessed by its alias.
from KeyValue
|> call tvf_one_optional_relation_arg_return_int64_value_table() AS val
|> where val=5
--
QueryStmt
+-output_column_list=
| +-tvf_one_optional_relation_arg_return_int64_value_table.$col0#3 AS `$value` [INT64]
+-is_value_table=TRUE
+-query=
  +-FilterScan
    +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#3]
    +-input_scan=
    | +-TVFScan
    |   +-column_list=[tvf_one_optional_relation_arg_return_int64_value_table.$col0#3]
    |   +-tvf=tvf_one_optional_relation_arg_return_int64_value_table((optional ANY TABLE) -> TABLE<INT64>)
    |   +-signature=(TABLE<Key INT64, Value STRING>) -> TABLE<INT64>
    |   +-argument_list=
    |   | +-FunctionArgument
    |   |   +-scan=
    |   |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    |   +-column_index_list=[0]
    |   +-alias="val"
    |   +-function_call_signature=(optional(1) ANY TABLE) -> TABLE<INT64>
    +-filter_expr=
      +-FunctionCall(ZetaSQL:$equal(INT64, INT64) -> BOOL)
        +-ColumnRef(type=INT64, column=tvf_one_optional_relation_arg_return_int64_value_table.$col0#3)
        +-Literal(type=INT64, value=5)
==

[language_features=NONE,+PIPES,+TABLE_VALUED_FUNCTIONS,+NAMED_ARGUMENTS,+INLINE_LAMBDA_ARGUMENT]
FROM KeyValue
|> call tvf_relation_arg_scalar_arg_named_lambda(1, named_lambda => e -> e)
--
ERROR: Lambda arguments are not implemented for TVF [at 2:69]
|> call tvf_relation_arg_scalar_arg_named_lambda(1, named_lambda => e -> e)
                                                                    ^
==

FROM KeyValue
|> CALL tvf_one_relation_arg_one_int64_arg(10)
--
QueryStmt
+-output_column_list=
| +-tvf_one_relation_arg_one_int64_arg.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_relation_arg_one_int64_arg.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_relation_arg_one_int64_arg.[column_bool#3, column_bytes#4]
    +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(TABLE<Key INT64, Value STRING>, literal INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=INT64, value=10)
    +-column_index_list=[0, 1]
    +-function_call_signature=(ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The TVF in CALL cannot use columns from the input table as arguments.
# The TVF is called once so cannot use references to these columns
# that have different values per row.
FROM KeyValue
|> CALL tvf_one_relation_arg_one_int64_arg(key)
--
ERROR: Unrecognized name: key [at 2:44]
|> CALL tvf_one_relation_arg_one_int64_arg(key)
                                           ^
==

# Referencing columns from the outer query is allowed inside an expression
# subquery.  These columns are constant for the CALL, which happens once
# per subquery execution.  Columns from the input table inside the subquery
# are not visible.
#
# The alternation `key` shows that the inner `key` column is ignored and does
# not hide the outer `key` column.
FROM KeyValue t1
|> EXTEND 123 AS outer_column
|> EXTEND
   (FROM KeyValue t2
    |> EXTEND 456 AS inner_column
    |> CALL tvf_one_relation_arg_one_int64_arg(
                {{t1.key|t2.key|key|outer_column|inner_column}})
    |> SELECT key)
--
ALTERNATION GROUPS:
    t1.key
    key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.outer_column#3 AS outer_column [INT64]
| +-$pipe_extend.$col1#10 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.outer_column#3, $pipe_extend.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$pipe_select.key#9]
    |         +-expr_list=
    |         | +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         +-input_scan=
    |           +-TVFScan
    |             +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |             +-signature=(TABLE<Key INT64, Value STRING, inner_column INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             | | +-scan=
    |             | | | +-ProjectScan
    |             | | |   +-column_list=[KeyValue.Key#4, KeyValue.Value#5, $pipe_extend.inner_column#6]
    |             | | |   +-expr_list=
    |             | | |   | +-inner_column#6 := Literal(type=INT64, value=456)
    |             | | |   +-input_scan=
    |             | | |     +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |             | | +-argument_column_list=[KeyValue.Key#4, KeyValue.Value#5, $pipe_extend.inner_column#6]
    |             | +-FunctionArgument
    |             |   +-expr=
    |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             +-function_call_signature=(ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.outer_column#3]
        +-expr_list=
        | +-outer_column#3 := Literal(type=INT64, value=123)
        +-input_scan=
          +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
--
ALTERNATION GROUP: t2.key
--
ERROR: Unrecognized name: t2 [at 7:17]
                t2.key)
                ^
--
ALTERNATION GROUP: outer_column
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.outer_column#3 AS outer_column [INT64]
| +-$pipe_extend.$col1#10 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.outer_column#3, $pipe_extend.$col1#10]
    +-expr_list=
    | +-$col1#10 :=
    |   +-SubqueryExpr
    |     +-type=INT64
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    |     | +-ColumnRef(type=INT64, column=$pipe_extend.outer_column#3)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$pipe_select.key#9]
    |         +-expr_list=
    |         | +-key#9 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         +-input_scan=
    |           +-TVFScan
    |             +-tvf=tvf_one_relation_arg_one_int64_arg((ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    |             +-signature=(TABLE<Key INT64, Value STRING, inner_column INT64>, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    |             +-argument_list=
    |             | +-FunctionArgument
    |             | | +-scan=
    |             | | | +-ProjectScan
    |             | | |   +-column_list=[KeyValue.Key#4, KeyValue.Value#5, $pipe_extend.inner_column#6]
    |             | | |   +-expr_list=
    |             | | |   | +-inner_column#6 := Literal(type=INT64, value=456)
    |             | | |   +-input_scan=
    |             | | |     +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |             | | +-argument_column_list=[KeyValue.Key#4, KeyValue.Value#5, $pipe_extend.inner_column#6]
    |             | +-FunctionArgument
    |             |   +-expr=
    |             |     +-ColumnRef(type=INT64, column=$pipe_extend.outer_column#3, is_correlated=TRUE)
    |             +-function_call_signature=(ANY TABLE, INT64) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.outer_column#3]
        +-expr_list=
        | +-outer_column#3 := Literal(type=INT64, value=123)
        +-input_scan=
          +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
--
ALTERNATION GROUP: inner_column
--
ERROR: Unrecognized name: inner_column [at 7:17]
                inner_column)
                ^
==

# Call a TVF where the table arg is in the second position.
FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg({{5|"ab"|TABLE TestTable}})
--
ALTERNATION GROUP: 5
--
QueryStmt
+-output_column_list=
| +-tvf_one_int64_arg_one_relation_arg.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_int64_arg_one_relation_arg.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_int64_arg_one_relation_arg.[column_bool#3, column_bytes#4]
    +-tvf=tvf_one_int64_arg_one_relation_arg((INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(literal INT64, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=5)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
--
ALTERNATION GROUP: "ab"
--
ERROR: No matching signature for tvf_one_int64_arg_one_relation_arg
  Argument types: STRING, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_ONE_INT64_ARG_ONE_RELATION_ARG(INT64, TABLE)
    Argument 1: Unable to coerce type STRING to expected type INT64 [at 2:9]
|> CALL tvf_one_int64_arg_one_relation_arg("ab")
        ^
--
ALTERNATION GROUP: TABLE TestTable
--
ERROR: No matching signature for tvf_one_int64_arg_one_relation_arg
  Argument types: TABLE<key INT32, TestEnum zetasql_test__.TestEnum, KitchenSink zetasql_test__.KitchenSinkPB>, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_ONE_INT64_ARG_ONE_RELATION_ARG(INT64, TABLE)
    Argument 1: expected INT64, found TABLE<key INT32, TestEnum zetasql_test__.TestEnum, KitchenSink zetasql_test__.KitchenSinkPB> [at 2:9]
|> CALL tvf_one_int64_arg_one_relation_arg(TABLE TestTable)
        ^
==

FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg()
--
ERROR: Table-valued function call in pipe CALL requires at least 1 positional argument because its first table argument is in position 2, but the call has no arguments; Supported signature: TVF_ONE_INT64_ARG_ONE_RELATION_ARG(INT64, TABLE); Consider using INPUT TABLE for the table argument [at 2:9]
|> CALL tvf_one_int64_arg_one_relation_arg()
        ^
==

FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg(0)
--
QueryStmt
+-output_column_list=
| +-tvf_one_int64_arg_one_relation_arg.column_bool#3 AS column_bool [BOOL]
| +-tvf_one_int64_arg_one_relation_arg.column_bytes#4 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_int64_arg_one_relation_arg.[column_bool#3, column_bytes#4]
    +-tvf=tvf_one_int64_arg_one_relation_arg((INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(literal INT64, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=0)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg(0,1)
--
ERROR: No matching signature for tvf_one_int64_arg_one_relation_arg
  Argument types: INT64, TABLE<Key INT64, Value STRING> (from pipe input), INT64
  Signature: TVF_ONE_INT64_ARG_ONE_RELATION_ARG(INT64, TABLE)
    Signature accepts at most 2 arguments, found 3 arguments [at 2:9]
|> CALL tvf_one_int64_arg_one_relation_arg(0,1)
        ^
==

# The first call arg is a scalar subquery, which will match the first
# scalar arg in the signature.
FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg((select 1))
--
QueryStmt
+-output_column_list=
| +-tvf_one_int64_arg_one_relation_arg.column_bool#4 AS column_bool [BOOL]
| +-tvf_one_int64_arg_one_relation_arg.column_bytes#5 AS column_bytes [BYTES]
+-query=
  +-TVFScan
    +-column_list=tvf_one_int64_arg_one_relation_arg.[column_bool#4, column_bytes#5]
    +-tvf=tvf_one_int64_arg_one_relation_arg((INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>)
    +-signature=(INT64, TABLE<Key INT64, Value STRING>) -> TABLE<column_bool BOOL, column_bytes BYTES>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-SubqueryExpr
    | |     +-type=INT64
    | |     +-subquery_type=SCALAR
    | |     +-subquery=
    | |       +-ProjectScan
    | |         +-column_list=[$expr_subquery.$col1#3]
    | |         +-expr_list=
    | |         | +-$col1#3 := Literal(type=INT64, value=1)
    | |         +-input_scan=
    | |           +-SingleRowScan
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0, 1]
    +-function_call_signature=(INT64, ANY TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
==

# The first call arg is a scalar subquery, producing the wrong type for the
# scalar arg in the signature.
FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg((select 'ab'))
--
ERROR: No matching signature for tvf_one_int64_arg_one_relation_arg
  Argument types: STRING, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_ONE_INT64_ARG_ONE_RELATION_ARG(INT64, TABLE)
    Argument 1: Unable to coerce type STRING to expected type INT64 [at 2:9]
|> CALL tvf_one_int64_arg_one_relation_arg((select 'ab'))
        ^
==

# The first call arg is a non-scalar subquery, so can't match the first
# scalar arg in the signature.
FROM KeyValue
|> CALL tvf_one_int64_arg_one_relation_arg((select 1, 2))
--
ERROR: Scalar subquery cannot have more than one column unless using SELECT AS STRUCT to build STRUCT values [at 2:44]
|> CALL tvf_one_int64_arg_one_relation_arg((select 1, 2))
                                           ^
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_two_scalars_two_tables(
  x INT64, y INT64, t1 ANY TABLE, t2 ANY TABLE)
RETURNS TABLE<z INT64>
--
CreateTableFunctionStmt(name_path=tvf_two_scalars_two_tables, argument_name_list=[x, y, t1, t2], signature=(INT64 x, INT64 y, ANY TABLE t1, ANY TABLE t2) -> TABLE<z INT64>, has_explicit_return_schema=TRUE, language="UNDECLARED")
==

[default use_database=db]
FROM KeyValue
|> CALL tvf_two_scalars_two_tables(
      {{|1|1,2|1,2,TABLE TestTable|1,TABLE TestTable}})
--
ALTERNATION GROUP: <empty>
--
ERROR: Table-valued function call in pipe CALL requires at least 2 positional arguments because its first table argument is in position 3, but the call has no arguments; Supported signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE); Consider using INPUT TABLE for the table argument [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
--
ALTERNATION GROUP: 1
--
ERROR: Table-valued function call in pipe CALL requires at least 2 positional arguments because its first table argument is in position 3, but the call has only 1 argument; Supported signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE); Consider using INPUT TABLE for the table argument [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
--
ALTERNATION GROUP: 1,2
--
ERROR: No matching signature for tvf_two_scalars_two_tables
  Argument types: INT64, INT64, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE)
    Signature requires at least 4 arguments, found 3 arguments [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
--
ALTERNATION GROUP: 1,2,TABLE TestTable
--
QueryStmt
+-output_column_list=
| +-tvf_two_scalars_two_tables.z#6 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_two_scalars_two_tables.z#6]
    +-tvf=tvf_two_scalars_two_tables((INT64 x, INT64 y, ANY TABLE t1, ANY TABLE t2) -> TABLE<z INT64>)
    +-signature=(literal INT64, literal INT64, TABLE<Key INT64, Value STRING>, TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, KitchenSink PROTO<zetasql_test__.KitchenSinkPB>>) -> TABLE<z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=1)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=2)
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5], table=TestTable, column_index_list=[0, 1, 2])
    |   +-argument_column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5]
    +-column_index_list=[0]
    +-function_call_signature=(INT64 x, INT64 y, ANY TABLE t1, ANY TABLE t2) -> TABLE<z INT64>
--
ALTERNATION GROUP: 1,TABLE TestTable
--
ERROR: No matching signature for tvf_two_scalars_two_tables
  Argument types: INT64, TABLE<key INT32, TestEnum zetasql_test__.TestEnum, KitchenSink zetasql_test__.KitchenSinkPB>, TABLE<Key INT64, Value STRING> (from pipe input)
  Signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE)
    Signature requires at least 4 arguments, found 3 arguments [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
==

FROM KeyValue
|> CALL tvf_two_scalars_two_tables(
      x=>1, y=>2, t2=>(FROM TestTable))
--
ERROR: Table-valued function call in pipe CALL requires at least 2 positional arguments before any named arguments because its first table argument is in position 3; Supported signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE) [at 3:7]
      x=>1, y=>2, t2=>(FROM TestTable))
      ^
==

FROM KeyValue
|> CALL tvf_two_scalars_two_tables(
      1, 2, t2=>(FROM TestTable))
--
QueryStmt
+-output_column_list=
| +-tvf_two_scalars_two_tables.z#6 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_two_scalars_two_tables.z#6]
    +-tvf=tvf_two_scalars_two_tables((INT64 x, INT64 y, ANY TABLE t1, ANY TABLE t2) -> TABLE<z INT64>)
    +-signature=(literal INT64, literal INT64, TABLE<Key INT64, Value STRING>, TABLE<key INT32, TestEnum ENUM<zetasql_test__.TestEnum>, KitchenSink PROTO<zetasql_test__.KitchenSinkPB>>) -> TABLE<z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=1)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=2)
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5], table=TestTable, column_index_list=[0, 1, 2])
    |   +-argument_column_list=TestTable.[key#3, TestEnum#4, KitchenSink#5]
    +-column_index_list=[0]
    +-function_call_signature=(INT64 x, INT64 y, ANY TABLE t1, ANY TABLE t2) -> TABLE<z INT64>
==

# Attempt to pass a table as a named arg that would match the
# pipe input table arg.
FROM KeyValue
|> CALL tvf_two_scalars_two_tables(
      1, 2, t1=>(FROM TestTable))
--
ERROR: No matching signature for tvf_two_scalars_two_tables
  Argument types: INT64, INT64, TABLE<Key INT64, Value STRING> (from pipe input), TABLE<key INT32, TestEnum zetasql_test__.TestEnum, KitchenSink zetasql_test__.KitchenSinkPB>
  Signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE)
    Named argument `t1` duplicates positional argument 3, which also provides `t1` [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
==

FROM KeyValue
|> CALL tvf_two_scalars_two_tables(
      1, (SELECT 5 zz), x=>2)
--
ERROR: No matching signature for tvf_two_scalars_two_tables
  Argument types: INT64, INT64, TABLE<Key INT64, Value STRING> (from pipe input), INT64
  Signature: TVF_TWO_SCALARS_TWO_TABLES(x => INT64, y => INT64, t1 => TABLE, t2 => TABLE)
    Named argument `x` duplicates positional argument 1, which also provides `x` [at 2:9]
|> CALL tvf_two_scalars_two_tables(
        ^
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_three_scalars_one_table(
  x INT64, y INT64, z INT64, t1 ANY TABLE)
RETURNS TABLE<z INT64>
--
CreateTableFunctionStmt(name_path=tvf_three_scalars_one_table, argument_name_list=[x, y, z, t1], signature=(INT64 x, INT64 y, INT64 z, ANY TABLE t1) -> TABLE<z INT64>, has_explicit_return_schema=TRUE, language="UNDECLARED")
==

FROM KeyValue
|> CALL tvf_three_scalars_one_table({{1,2|1,2,3}})
--
ALTERNATION GROUP: 1,2
--
ERROR: Table-valued function call in pipe CALL requires at least 3 positional arguments because its first table argument is in position 4, but the call has only 2 arguments; Supported signature: TVF_THREE_SCALARS_ONE_TABLE(x => INT64, y => INT64, z => INT64, t1 => TABLE); Consider using INPUT TABLE for the table argument [at 2:9]
|> CALL tvf_three_scalars_one_table(1,2)
        ^
--
ALTERNATION GROUP: 1,2,3
--
QueryStmt
+-output_column_list=
| +-tvf_three_scalars_one_table.z#3 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_three_scalars_one_table.z#3]
    +-tvf=tvf_three_scalars_one_table((INT64 x, INT64 y, INT64 z, ANY TABLE t1) -> TABLE<z INT64>)
    +-signature=(literal INT64, literal INT64, literal INT64, TABLE<Key INT64, Value STRING>) -> TABLE<z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=1)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=2)
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=3)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0]
    +-function_call_signature=(INT64 x, INT64 y, INT64 z, ANY TABLE t1) -> TABLE<z INT64>
==

FROM KeyValue
|> CALL tvf_three_scalars_one_table(1,2,z=>3)
--
ERROR: Table-valued function call in pipe CALL requires at least 3 positional arguments before any named arguments because its first table argument is in position 4; Supported signature: TVF_THREE_SCALARS_ONE_TABLE(x => INT64, y => INT64, z => INT64, t1 => TABLE) [at 2:41]
|> CALL tvf_three_scalars_one_table(1,2,z=>3)
                                        ^
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_one_scalar_one_table(
  x INT64, t1 ANY TABLE)
RETURNS TABLE<z INT64>
--
CreateTableFunctionStmt(name_path=tvf_one_scalar_one_table, argument_name_list=[x, t1], signature=(INT64 x, ANY TABLE t1) -> TABLE<z INT64>, has_explicit_return_schema=TRUE, language="UNDECLARED")
==

FROM KeyValue
|> CALL tvf_one_scalar_one_table({{x=>3|z=>4|5}})
--
ALTERNATION GROUP: x=>3
--
ERROR: Table-valued function call in pipe CALL requires at least 1 positional argument before any named arguments because its first table argument is in position 2; Supported signature: TVF_ONE_SCALAR_ONE_TABLE(x => INT64, t1 => TABLE) [at 2:34]
|> CALL tvf_one_scalar_one_table(x=>3)
                                 ^
--
ALTERNATION GROUP: z=>4
--
ERROR: Table-valued function call in pipe CALL requires at least 1 positional argument before any named arguments because its first table argument is in position 2; Supported signature: TVF_ONE_SCALAR_ONE_TABLE(x => INT64, t1 => TABLE) [at 2:34]
|> CALL tvf_one_scalar_one_table(z=>4)
                                 ^
--
ALTERNATION GROUP: 5
--
QueryStmt
+-output_column_list=
| +-tvf_one_scalar_one_table.z#3 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_one_scalar_one_table.z#3]
    +-tvf=tvf_one_scalar_one_table((INT64 x, ANY TABLE t1) -> TABLE<z INT64>)
    +-signature=(literal INT64, TABLE<Key INT64, Value STRING>) -> TABLE<z INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-expr=
    | |   +-Literal(type=INT64, value=5)
    | +-FunctionArgument
    |   +-scan=
    |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    |   +-argument_column_list=KeyValue.[Key#1, Value#2]
    +-column_index_list=[0]
    +-function_call_signature=(INT64 x, ANY TABLE t1) -> TABLE<z INT64>
==

[prepare_database=db]
CREATE TABLE FUNCTION tvf_expect_a_b_c(t TABLE<a INT64, b STRING, c DOUBLE>)
RETURNS TABLE<z INT64>
--
CreateTableFunctionStmt(name_path=tvf_expect_a_b_c, argument_name_list=[t], signature=(TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>, has_explicit_return_schema=TRUE, language="UNDECLARED")
==

# This tests the code that rearranges and coerces columns in the input table to
# match the expected schema.  (Most tests above use ANY TABLE.)
SELECT 1 x, 10 c, 2 y, CAST(NULL AS STRING) {{b|b_is_missing}},
       3 z, CAST(20 AS {{string|int32}}) a
|> CALL tvf_expect_a_b_c()
--
ALTERNATION GROUPS:
    b,string
    b_is_missing,string
--
ERROR: Invalid type STRING for column "a INT64" of argument 1 of TVF_EXPECT_A_B_C(TABLE<a INT64, b STRING, c DOUBLE>) [at 3:9]
|> CALL tvf_expect_a_b_c()
        ^
--
ALTERNATION GROUP: b,int32
--
QueryStmt
+-output_column_list=
| +-tvf_expect_a_b_c.z#9 AS z [INT64]
+-query=
  +-TVFScan
    +-column_list=[tvf_expect_a_b_c.z#9]
    +-tvf=tvf_expect_a_b_c((TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>)
    +-signature=(TABLE<a INT64, b STRING, c DOUBLE>) -> TABLE<z INT64>
    +-argument_list=
    | +-FunctionArgument
    |   +-scan=
    |   | +-ProjectScan
    |   |   +-column_list=[$subquery1.a#7, $query.b#4, $subquery1.c#8]
    |   |   +-expr_list=
    |   |   | +-a#7 :=
    |   |   | | +-Cast(INT32 -> INT64)
    |   |   | |   +-ColumnRef(type=INT32, column=$query.a#6)
    |   |   | +-c#8 :=
    |   |   |   +-Cast(INT64 -> DOUBLE)
    |   |   |     +-ColumnRef(type=INT64, column=$query.c#2)
    |   |   +-input_scan=
    |   |     +-ProjectScan
    |   |       +-column_list=$query.[x#1, c#2, y#3, b#4, z#5, a#6]
    |   |       +-expr_list=
    |   |       | +-x#1 := Literal(type=INT64, value=1)
    |   |       | +-c#2 := Literal(type=INT64, value=10)
    |   |       | +-y#3 := Literal(type=INT64, value=2)
    |   |       | +-b#4 := Literal(type=STRING, value=NULL, has_explicit_type=TRUE)
    |   |       | +-z#5 := Literal(type=INT64, value=3)
    |   |       | +-a#6 := Literal(type=INT32, value=20, has_explicit_type=TRUE)
    |   |       +-input_scan=
    |   |         +-SingleRowScan
    |   +-argument_column_list=[$subquery1.a#7, $query.b#4, $subquery1.c#8]
    +-column_index_list=[0]
    +-function_call_signature=(TABLE<a INT64, b STRING, c DOUBLE> t) -> TABLE<z INT64>
--
ALTERNATION GROUP: b_is_missing,int32
--
ERROR: Required column "b" not found in table passed as argument 1 of TVF_EXPECT_A_B_C(TABLE<a INT64, b STRING, c DOUBLE>) [at 3:9]
|> CALL tvf_expect_a_b_c()
        ^
==

# Test with optional relation and named scalar arguments.
FROM KeyValue
|> CALL tvf_optional_relation_named_scalar(foobar=>'a')
--
QueryStmt
+-output_column_list=
| +-tvf_optional_relation_named_scalar.$col0#3 AS `$col0` [INT64]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_optional_relation_named_scalar.$col0#3]
    +-tvf=tvf_optional_relation_named_scalar((optional ANY TABLE, optional STRING foobar) -> TABLE<INT64>)
    +-signature=(TABLE<Key INT64, Value STRING>, literal STRING) -> TABLE<INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=STRING, value="a")
    +-column_index_list=[0]
    +-function_call_signature=(optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<INT64>
==

# Test with optional relation and named scalar arguments.
FROM KeyValue
|> CALL tvf_optional_relations_named_scalar(foobar=>'a')
--
QueryStmt
+-output_column_list=
| +-tvf_optional_relations_named_scalar.$col0#3 AS `$col0` [INT64]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_optional_relations_named_scalar.$col0#3]
    +-tvf=tvf_optional_relations_named_scalar((optional ANY TABLE, optional ANY TABLE, optional STRING foobar) -> TABLE<INT64>)
    +-signature=(TABLE<Key INT64, Value STRING>, TABLE<>, literal STRING) -> TABLE<INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    | | +-scan=
    | |   +-UnsetArgumentScan
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=STRING, value="a")
    +-column_index_list=[0]
    +-function_call_signature=(optional(1) ANY TABLE, optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<INT64>
==

# Test with optional relation and named scalar arguments.
FROM KeyValue
|> CALL tvf_optional_relations_named_scalar(Table KeyValue, foobar=>'a')
--
QueryStmt
+-output_column_list=
| +-tvf_optional_relations_named_scalar.$col0#5 AS `$col0` [INT64]
+-is_value_table=TRUE
+-query=
  +-TVFScan
    +-column_list=[tvf_optional_relations_named_scalar.$col0#5]
    +-tvf=tvf_optional_relations_named_scalar((optional ANY TABLE, optional ANY TABLE, optional STRING foobar) -> TABLE<INT64>)
    +-signature=(TABLE<Key INT64, Value STRING>, TABLE<Key INT64, Value STRING>, literal STRING) -> TABLE<INT64>
    +-argument_list=
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#1, Value#2]
    | +-FunctionArgument
    | | +-scan=
    | | | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
    | | +-argument_column_list=KeyValue.[Key#3, Value#4]
    | +-FunctionArgument
    |   +-expr=
    |     +-Literal(type=STRING, value="a")
    +-column_index_list=[0]
    +-function_call_signature=(optional(1) ANY TABLE, optional(1) ANY TABLE, optional(1) STRING foobar) -> TABLE<INT64>
==

FROM KeyValue
|> CALL tvf_optional_scalars_named_table(123)
--
ERROR: Table-valued function cannot be called with pipe CALL syntax because it has an optional argument before its first table-typed argument; Supported signature: TVF_OPTIONAL_SCALARS_NAMED_TABLE([ANY], [ANY], [foobar => TABLE]); Consider using INPUT TABLE for the table argument [at 2:9]
|> CALL tvf_optional_scalars_named_table(123)
        ^
