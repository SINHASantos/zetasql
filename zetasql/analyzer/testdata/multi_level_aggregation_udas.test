[default language_features=NONE,+CREATE_AGGREGATE_FUNCTION,+TEMPLATE_FUNCTIONS,+MULTILEVEL_AGGREGATION,+GROUP_BY_STRUCT,+INLINE_LAMBDA_ARGUMENT,+WITH_EXPRESSION]
[default show_sqlbuilder_output]
[default enabled_ast_rewrites=ALL]

CREATE AGGREGATE FUNCTION DuplicateGroupingKeys1(arg {{INT64|ANY TYPE}}) AS (
  SUM(arg GROUP BY arg, arg, arg)
);
--
ALTERNATION GROUP: INT64
--
CreateFunctionStmt
+-name_path=DuplicateGroupingKeys1
+-return_type=INT64
+-argument_name_list=[arg]
+-signature=(INT64 arg) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(arg GROUP BY arg, arg, arg)"
+-aggregate_expression_list=
| +-$agg1#2 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=84-87, type=INT64, name="arg", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys1(arg INT64)
RETURNS INT64 AS (
  SUM(arg
    GROUP BY arg)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys1(arg INT64)
RETURNS INT64 AS (
  SUM(arg
    GROUP BY arg)
);
--
ALTERNATION GROUP: ANY TYPE
--
CreateFunctionStmt(name_path=DuplicateGroupingKeys1, return_type=STRUCT<>, argument_name_list=[arg], signature=(ANY TYPE arg) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(arg GROUP BY arg, arg, arg)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys1(arg ANY TYPE)
AS (
  SUM(arg
    GROUP BY arg, arg, arg)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys1(arg ANY TYPE)
AS (
  SUM(arg
    GROUP BY arg, arg, arg)
);
==

CREATE AGGREGATE FUNCTION DuplicateGroupingKeys2(arg {{INT64|ANY TYPE}}, struct_arg STRUCT<a INT64>) AS (
  SUM(AVG(arg GROUP BY arg, struct_arg) GROUP BY arg, arg, struct_arg, struct_arg)
);
--
ALTERNATION GROUP: INT64
--
CreateFunctionStmt
+-name_path=DuplicateGroupingKeys2
+-return_type=DOUBLE
+-argument_name_list=[arg, struct_arg]
+-signature=(INT64 arg, STRUCT<a INT64> struct_arg) -> DOUBLE
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(AVG(arg GROUP BY arg, struct_arg) GROUP BY arg, arg, struct_arg, struct_arg)"
+-aggregate_expression_list=
| +-$agg1#6 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
|     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#5)
|     +-group_by_list=
|     | +-$groupbymod#1 := ArgumentRef(parse_location=142-145, type=INT64, name="arg", argument_kind=AGGREGATE)
|     | +-$groupbymod#2 := ArgumentRef(parse_location=152-162, type=STRUCT<a INT64>, name="struct_arg", argument_kind=AGGREGATE)
|     +-group_by_aggregate_list=
|       +-$agg1#5 :=
|         +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
|           +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#3)
|           +-group_by_list=
|             +-$groupbymod#3 := ArgumentRef(parse_location=142-145, type=INT64, name="arg", argument_kind=AGGREGATE)
|             +-$groupbymod#4 := ArgumentRef(parse_location=152-162, type=STRUCT<a INT64>, name="struct_arg", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#6)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys2(arg INT64, struct_arg STRUCT< a INT64 >)
RETURNS DOUBLE AS (
  SUM(AVG(arg
      GROUP BY arg, struct_arg)
    GROUP BY arg, struct_arg)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys2(arg INT64, struct_arg STRUCT< a INT64 >)
RETURNS DOUBLE AS (
  SUM(AVG(arg
      GROUP BY arg, struct_arg)
    GROUP BY arg, struct_arg)
);
--
ALTERNATION GROUP: ANY TYPE
--
CreateFunctionStmt(name_path=DuplicateGroupingKeys2, return_type=STRUCT<>, argument_name_list=[arg, struct_arg], signature=(ANY TYPE arg, STRUCT<a INT64> struct_arg) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(AVG(arg GROUP BY arg, struct_arg) GROUP BY arg, arg, struct_arg, struct_arg)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys2(arg ANY TYPE, struct_arg STRUCT< a INT64 >)
AS (
  SUM(AVG(arg
      GROUP BY arg, struct_arg)
    GROUP BY arg, arg, struct_arg, struct_arg)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION DuplicateGroupingKeys2(arg ANY TYPE, struct_arg STRUCT< a INT64 >)
AS (
  SUM(AVG(arg
      GROUP BY arg, struct_arg)
    GROUP BY arg, arg, struct_arg, struct_arg)
);
==

CREATE AGGREGATE FUNCTION SumOfDistinctValues(value {{INT64|ANY TYPE}}) AS (
  SUM(value GROUP BY value)
);
--
ALTERNATION GROUP: INT64
--
CreateFunctionStmt
+-name_path=SumOfDistinctValues
+-return_type=INT64
+-argument_name_list=[value]
+-signature=(INT64 value) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(value GROUP BY value)"
+-aggregate_expression_list=
| +-$agg1#2 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=85-90, type=INT64, name="value", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfDistinctValues(value INT64)
RETURNS INT64 AS (
  SUM(value
    GROUP BY value)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfDistinctValues(value INT64)
RETURNS INT64 AS (
  SUM(value
    GROUP BY value)
);
--
ALTERNATION GROUP: ANY TYPE
--
CreateFunctionStmt(name_path=SumOfDistinctValues, return_type=STRUCT<>, argument_name_list=[value], signature=(ANY TYPE value) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(value GROUP BY value)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfDistinctValues(value ANY TYPE)
AS (
  SUM(value
    GROUP BY value)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfDistinctValues(value ANY TYPE)
AS (
  SUM(value
    GROUP BY value)
);
==

CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value {{INT64|ANY TYPE}}, key {{INT64|ANY TYPE}}) AS (
  SUM(AVG(value) GROUP BY key)
);
--
ALTERNATION GROUP: INT64,INT64
--
CreateFunctionStmt
+-name_path=SumOfAverageValuesForDistinctKey
+-return_type=DOUBLE
+-argument_name_list=[value, key]
+-signature=(INT64 value, INT64 key) -> DOUBLE
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(AVG(value) GROUP BY key)"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(DOUBLE) -> DOUBLE)
|     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#2)
|     +-group_by_list=
|     | +-$groupbymod#1 := ArgumentRef(parse_location=114-117, type=INT64, name="key", argument_kind=AGGREGATE)
|     +-group_by_aggregate_list=
|       +-$agg1#2 :=
|         +-AggregateFunctionCall(ZetaSQL:avg(INT64) -> DOUBLE)
|           +-ArgumentRef(parse_location=98-103, type=INT64, name="value", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#3)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value INT64, key INT64)
RETURNS DOUBLE AS (
  SUM(AVG(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value INT64, key INT64)
RETURNS DOUBLE AS (
  SUM(AVG(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE
--
CreateFunctionStmt(name_path=SumOfAverageValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(INT64 value, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(AVG(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value INT64, key ANY TYPE)
AS (
  SUM(AVG(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value INT64, key ANY TYPE)
AS (
  SUM(AVG(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64
--
CreateFunctionStmt(name_path=SumOfAverageValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(ANY TYPE value, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(AVG(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value ANY TYPE, key INT64)
AS (
  SUM(AVG(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value ANY TYPE, key INT64)
AS (
  SUM(AVG(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=SumOfAverageValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(ANY TYPE value, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(AVG(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value ANY TYPE, key ANY TYPE)
AS (
  SUM(AVG(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfAverageValuesForDistinctKey(value ANY TYPE, key ANY TYPE)
AS (
  SUM(AVG(value)
    GROUP BY key)
);
==

CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value {{INT64|ANY TYPE}}, key {{INT64|ANY TYPE}}) AS (
  SUM(ANY_VALUE(value) GROUP BY key)
);
--
ALTERNATION GROUP: INT64,INT64
--
CreateFunctionStmt
+-name_path=SumOfValuesForDistinctKey
+-return_type=INT64
+-argument_name_list=[value, key]
+-signature=(INT64 value, INT64 key) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(ANY_VALUE(value) GROUP BY key)"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)
|     +-group_by_list=
|     | +-$groupbymod#1 := ArgumentRef(parse_location=113-116, type=INT64, name="key", argument_kind=AGGREGATE)
|     +-group_by_aggregate_list=
|       +-$agg1#2 :=
|         +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
|           +-ArgumentRef(parse_location=97-102, type=INT64, name="value", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value INT64, key INT64)
RETURNS INT64 AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value INT64, key INT64)
RETURNS INT64 AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE
--
CreateFunctionStmt(name_path=SumOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(INT64 value, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64
--
CreateFunctionStmt(name_path=SumOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(ANY TYPE value, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=SumOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value, key], signature=(ANY TYPE value, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION SumOfValuesForDistinctKey(value ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value)
    GROUP BY key)
);
==

CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 {{INT64|ANY TYPE}}, value2 {{INT64|ANY TYPE}}, key {{INT64|ANY TYPE}}) AS (
  SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)
);
--
ALTERNATION GROUP: INT64,INT64,INT64
--
CreateFunctionStmt
+-name_path=RatioOfValuesForDistinctKey
+-return_type=DOUBLE
+-argument_name_list=[value1, value2, key]
+-signature=(INT64 value1, INT64 value2, INT64 key) -> DOUBLE
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)"
+-aggregate_expression_list=
| +-$agg1#3 :=
| | +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
| |   +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)
| |   +-group_by_list=
| |   | +-$groupbymod#1 := ArgumentRef(parse_location=131-134, type=INT64, name="key", argument_kind=AGGREGATE)
| |   +-group_by_aggregate_list=
| |     +-$agg1#2 :=
| |       +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
| |         +-ArgumentRef(parse_location=114-120, type=INT64, name="value1", argument_kind=AGGREGATE)
| +-$agg2#6 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)
|     +-group_by_list=
|     | +-$groupbymod#4 := ArgumentRef(parse_location=169-172, type=INT64, name="key", argument_kind=AGGREGATE)
|     +-group_by_aggregate_list=
|       +-$agg1#5 :=
|         +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
|           +-ArgumentRef(parse_location=152-158, type=INT64, name="value2", argument_kind=AGGREGATE)
+-function_expression=
  +-FunctionCall(ZetaSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
    +-Cast(INT64 -> DOUBLE)
    | +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
    +-Cast(INT64 -> DOUBLE)
      +-ColumnRef(type=INT64, column=$aggregate.$agg2#6)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 INT64, key INT64)
RETURNS DOUBLE AS (
  CAST(SUM(ANY_VALUE(value1)
    GROUP BY key) AS DOUBLE) / CAST(SUM(ANY_VALUE(value2)
    GROUP BY key) AS DOUBLE)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 INT64, key INT64)
RETURNS DOUBLE AS (
  CAST(SUM(ANY_VALUE(value1)
    GROUP BY key) AS DOUBLE) / CAST(SUM(ANY_VALUE(value2)
    GROUP BY key) AS DOUBLE)
);
--
ALTERNATION GROUP: INT64,INT64,ANY TYPE
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, INT64 value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE,INT64
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, ANY TYPE value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, ANY TYPE value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 INT64, value2 ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64,INT64
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, INT64 value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 INT64, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 INT64, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64,ANY TYPE
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, INT64 value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 INT64, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE,INT64
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, ANY TYPE value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key INT64)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=RatioOfValuesForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, ANY TYPE value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(ANY_VALUE(value1) GROUP BY key) / SUM(ANY_VALUE(value2) GROUP BY key)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION RatioOfValuesForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key ANY TYPE)
AS (
  SUM(ANY_VALUE(value1)
    GROUP BY key) / SUM(ANY_VALUE(value2)
    GROUP BY key)
);
==

CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 {{INT64|ANY TYPE}}, value2 {{INT64|ANY TYPE}}, key {{INT64|ANY TYPE}}) AS (
  CORR(
    ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key
  )
);
--
ALTERNATION GROUP: INT64,INT64,INT64
--
CreateFunctionStmt
+-name_path=PearsonCoefficientForDistinctKey
+-return_type=DOUBLE
+-argument_name_list=[value1, value2, key]
+-signature=(INT64 value1, INT64 value2, INT64 key) -> DOUBLE
+-is_aggregate=TRUE
+-language="SQL"
+-code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#4 :=
|   +-AggregateFunctionCall(ZetaSQL:corr(DOUBLE, DOUBLE) -> DOUBLE)
|     +-Cast(INT64 -> DOUBLE)
|     | +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)
|     +-Cast(INT64 -> DOUBLE)
|       +-ColumnRef(type=INT64, column=$aggregate.$agg2#3)
|     +-group_by_list=
|     | +-$groupbymod#1 := ArgumentRef(parse_location=165-168, type=INT64, name="key", argument_kind=AGGREGATE)
|     +-group_by_aggregate_list=
|       +-$agg1#2 :=
|       | +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
|       |   +-ArgumentRef(parse_location=125-131, type=INT64, name="value1", argument_kind=AGGREGATE)
|       +-$agg2#3 :=
|         +-AggregateFunctionCall(ZetaSQL:any_value(INT64) -> INT64)
|           +-ArgumentRef(parse_location=144-150, type=INT64, name="value2", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#4)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 INT64, key INT64)
RETURNS DOUBLE AS (
  CORR(CAST(ANY_VALUE(value1) AS DOUBLE), CAST(ANY_VALUE(value2) AS DOUBLE)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 INT64, key INT64)
RETURNS DOUBLE AS (
  CORR(CAST(ANY_VALUE(value1) AS DOUBLE), CAST(ANY_VALUE(value2) AS DOUBLE)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,INT64,ANY TYPE
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, INT64 value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 INT64, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 INT64, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE,INT64
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, ANY TYPE value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 ANY TYPE, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 ANY TYPE, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: INT64,ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(INT64 value1, ANY TYPE value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 ANY TYPE, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 INT64, value2 ANY TYPE, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64,INT64
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, INT64 value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 INT64, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 INT64, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,INT64,ANY TYPE
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, INT64 value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 INT64, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 INT64, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE,INT64
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, ANY TYPE value2, INT64 key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key INT64)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
--
ALTERNATION GROUP: ANY TYPE,ANY TYPE,ANY TYPE
--
CreateFunctionStmt(name_path=PearsonCoefficientForDistinctKey, return_type=STRUCT<>, argument_name_list=[value1, value2, key], signature=(ANY TYPE value1, ANY TYPE value2, ANY TYPE key) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="CORR(\n    ANY_VALUE(value1), ANY_VALUE(value2)\n    GROUP BY key\n  )")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION PearsonCoefficientForDistinctKey(value1 ANY TYPE, value2 ANY TYPE, key ANY TYPE)
AS (
  CORR(ANY_VALUE(value1), ANY_VALUE(value2)
    GROUP BY key)
);
==

# Grouping-constness test over STRUCT field accesses.
CREATE AGGREGATE FUNCTION GroupingConstnessStructFieldAccess1(struct_arg {{STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>|ANY TYPE}}) AS (
  SUM(struct_arg.f.c GROUP BY struct_arg.f)
);
--
ALTERNATION GROUP: STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>
--
CreateFunctionStmt
+-name_path=GroupingConstnessStructFieldAccess1
+-return_type=INT64
+-argument_name_list=[struct_arg]
+-signature=(STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>> struct_arg) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(struct_arg.f.c GROUP BY struct_arg.f)"
+-aggregate_expression_list=
| +-$agg1#2 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-Cast(INT32 -> INT64)
|       +-GetStructField
|         +-type=INT32
|         +-expr=
|         | +-ColumnRef(type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>, column=$group_by_list.$groupbymod#1)
|         +-field_idx=0
|     +-group_by_list=
|       +-$groupbymod#1 :=
|         +-GetStructField
|           +-type=STRUCT<c INT32, d STRUCT<a INT32, b STRING>>
|           +-expr=
|           | +-ArgumentRef(parse_location=173-183, type=STRUCT<e INT32, f STRUCT<c INT32, d STRUCT<a INT32, b STRING>>>, name="struct_arg", argument_kind=AGGREGATE)
|           +-field_idx=1
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstnessStructFieldAccess1(struct_arg STRUCT< e INT32, f STRUCT< c INT32,
d STRUCT< a INT32, b STRING > > >)
RETURNS INT64 AS (
  SUM(CAST(struct_arg.f.c AS INT64)
    GROUP BY struct_arg.f)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstnessStructFieldAccess1(struct_arg STRUCT< e INT32, f STRUCT< c INT32,
d STRUCT< a INT32, b STRING > > >)
RETURNS INT64 AS (
  SUM(CAST(struct_arg.f.c AS INT64)
    GROUP BY struct_arg.f)
);
--
ALTERNATION GROUP: ANY TYPE
--
CreateFunctionStmt(name_path=GroupingConstnessStructFieldAccess1, return_type=STRUCT<>, argument_name_list=[struct_arg], signature=(ANY TYPE struct_arg) -> ANY TYPE, is_aggregate=TRUE, language="SQL", code="SUM(struct_arg.f.c GROUP BY struct_arg.f)")

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstnessStructFieldAccess1(struct_arg ANY TYPE)
AS (
  SUM(struct_arg.f.c
    GROUP BY struct_arg.f)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstnessStructFieldAccess1(struct_arg ANY TYPE)
AS (
  SUM(struct_arg.f.c
    GROUP BY struct_arg.f)
);
==

# Lambda argument `key` hide function argument `key`
CREATE AGGREGATE FUNCTION LambdaArgHidesFunctionArg(key INT64) AS (
  ANY_VALUE(
    ARRAY_INCLUDES([1,2,3], key -> key > 3)
    GROUP BY key
  )
);
--
CreateFunctionStmt
+-name_path=LambdaArgHidesFunctionArg
+-return_type=BOOL
+-argument_name_list=[key]
+-signature=(INT64 key) -> BOOL
+-is_aggregate=TRUE
+-language="SQL"
+-code="ANY_VALUE(\n    ARRAY_INCLUDES([1,2,3], key -> key > 3)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:any_value(BOOL) -> BOOL)
|     +-FunctionCall(ZetaSQL:array_includes(ARRAY<INT64> array_to_search, FUNCTION<INT64->BOOL> condition) -> BOOL)
|       +-FunctionArgument
|       | +-expr=
|       |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
|       +-FunctionArgument
|         +-inline_lambda=
|           +-InlineLambda
|             +-argument_list=[$lambda_arg.key#2]
|             +-body=
|               +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|                 +-ColumnRef(type=INT64, column=$lambda_arg.key#2)
|                 +-Literal(type=INT64, value=3)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=138-141, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=BOOL, column=$aggregate.$agg1#3)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaArgHidesFunctionArg(key INT64)
RETURNS BOOL AS (
  ANY_VALUE(ARRAY_INCLUDES(ARRAY< INT64 >[1, 2, 3], (a_1) -> a_1 > 3)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaArgHidesFunctionArg(key INT64)
RETURNS BOOL AS (
  ANY_VALUE(ARRAY_INCLUDES(ARRAY< INT64 >[1, 2, 3], (a_1) -> a_1 > 3)
    GROUP BY key)
);

[REWRITTEN AST]
CreateFunctionStmt
+-name_path=LambdaArgHidesFunctionArg
+-return_type=BOOL
+-argument_name_list=[key]
+-signature=(INT64 key) -> BOOL
+-is_aggregate=TRUE
+-language="SQL"
+-code="ANY_VALUE(\n    ARRAY_INCLUDES([1,2,3], key -> key > 3)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:any_value(BOOL) -> BOOL)
|     +-SubqueryExpr
|       +-type=BOOL
|       +-subquery_type=SCALAR
|       +-subquery=
|         +-ProjectScan
|           +-column_list=[$expr_subquery.$col1#7]
|           +-expr_list=
|           | +-$col1#7 :=
|           |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
|           |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
|           |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4)
|           |     +-Literal(type=BOOL, value=NULL)
|           |     +-SubqueryExpr
|           |       +-type=BOOL
|           |       +-subquery_type=EXISTS
|           |       +-parameter_list=
|           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4)
|           |       +-subquery=
|           |         +-ProjectScan
|           |           +-column_list=[$expr_subquery.$col1#6]
|           |           +-expr_list=
|           |           | +-$col1#6 := Literal(type=INT64, value=1)
|           |           +-input_scan=
|           |             +-FilterScan
|           |               +-column_list=[$array.element#5]
|           |               +-input_scan=
|           |               | +-ArrayScan
|           |               |   +-column_list=[$array.element#5]
|           |               |   +-array_expr_list=
|           |               |   | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4, is_correlated=TRUE)
|           |               |   +-element_column_list=[$array.element#5]
|           |               +-filter_expr=
|           |                 +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|           |                   +-ColumnRef(type=INT64, column=$array.element#5)
|           |                   +-Literal(type=INT64, value=3)
|           +-input_scan=
|             +-ProjectScan
|               +-column_list=[$subquery1.array_to_search#4]
|               +-expr_list=
|               | +-array_to_search#4 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
|               +-input_scan=
|                 +-SingleRowScan
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=138-141, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=BOOL, column=$aggregate.$agg1#3)
[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaArgHidesFunctionArg(key INT64)
RETURNS BOOL AS (
  ANY_VALUE((
      SELECT
        `IF`((projectscan_2.a_1) IS NULL, CAST(NULL AS BOOL), EXISTS(
            SELECT
              1 AS a_5
            FROM
              UNNEST(projectscan_2.a_1) AS a_4
            WHERE
              a_4 > 3
          )) AS a_3
      FROM
        (
          SELECT
            ARRAY< INT64 >[1, 2, 3] AS a_1
        ) AS projectscan_2
    )
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaArgHidesFunctionArg(key INT64)
RETURNS BOOL AS (
  ANY_VALUE((
      SELECT
        ARRAY< INT64 >[1, 2, 3] AS a_1
      |> AS projectscan_2
      |> SELECT
           `IF`((projectscan_2.a_1) IS NULL, CAST(NULL AS BOOL), EXISTS(
               FROM
                 UNNEST(projectscan_2.a_1) AS a_4
               |> WHERE
                    a_4 > 3
               |> SELECT
                    1 AS a_5
             )) AS a_3
    )
    GROUP BY key)
);
==

# `key` referenced within lambda body binds to the group by modifier column.
CREATE AGGREGATE FUNCTION LambdaBodyAccessingGroupingKey(key INT64) AS (
  ANY_VALUE(
    ARRAY_INCLUDES([1,2,3], e -> key > 3)
    GROUP BY key
  )
);
--
CreateFunctionStmt
+-name_path=LambdaBodyAccessingGroupingKey
+-return_type=BOOL
+-argument_name_list=[key]
+-signature=(INT64 key) -> BOOL
+-is_aggregate=TRUE
+-language="SQL"
+-code="ANY_VALUE(\n    ARRAY_INCLUDES([1,2,3], e -> key > 3)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:any_value(BOOL) -> BOOL)
|     +-FunctionCall(ZetaSQL:array_includes(ARRAY<INT64> array_to_search, FUNCTION<INT64->BOOL> condition) -> BOOL)
|       +-FunctionArgument
|       | +-expr=
|       |   +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
|       +-FunctionArgument
|         +-inline_lambda=
|           +-InlineLambda
|             +-argument_list=[$lambda_arg.e#2]
|             +-parameter_list=
|             | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|             +-body=
|               +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|                 +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|                 +-Literal(type=INT64, value=3)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=141-144, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=BOOL, column=$aggregate.$agg1#3)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaBodyAccessingGroupingKey(key INT64)
RETURNS BOOL AS (
  ANY_VALUE(ARRAY_INCLUDES(ARRAY< INT64 >[1, 2, 3], (a_1) -> key > 3)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaBodyAccessingGroupingKey(key INT64)
RETURNS BOOL AS (
  ANY_VALUE(ARRAY_INCLUDES(ARRAY< INT64 >[1, 2, 3], (a_1) -> key > 3)
    GROUP BY key)
);

[REWRITTEN AST]
CreateFunctionStmt
+-name_path=LambdaBodyAccessingGroupingKey
+-return_type=BOOL
+-argument_name_list=[key]
+-signature=(INT64 key) -> BOOL
+-is_aggregate=TRUE
+-language="SQL"
+-code="ANY_VALUE(\n    ARRAY_INCLUDES([1,2,3], e -> key > 3)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:any_value(BOOL) -> BOOL)
|     +-SubqueryExpr
|       +-type=BOOL
|       +-subquery_type=SCALAR
|       +-parameter_list=
|       | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|       +-subquery=
|         +-ProjectScan
|           +-column_list=[$expr_subquery.$col1#7]
|           +-expr_list=
|           | +-$col1#7 :=
|           |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
|           |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
|           |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4)
|           |     +-Literal(type=BOOL, value=NULL)
|           |     +-SubqueryExpr
|           |       +-type=BOOL
|           |       +-subquery_type=EXISTS
|           |       +-parameter_list=
|           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4)
|           |       | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|           |       +-subquery=
|           |         +-ProjectScan
|           |           +-column_list=[$expr_subquery.$col1#6]
|           |           +-expr_list=
|           |           | +-$col1#6 := Literal(type=INT64, value=1)
|           |           +-input_scan=
|           |             +-FilterScan
|           |               +-column_list=[$array.element#5]
|           |               +-input_scan=
|           |               | +-ArrayScan
|           |               |   +-column_list=[$array.element#5]
|           |               |   +-array_expr_list=
|           |               |   | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_search#4, is_correlated=TRUE)
|           |               |   +-element_column_list=[$array.element#5]
|           |               +-filter_expr=
|           |                 +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
|           |                   +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|           |                   +-Literal(type=INT64, value=3)
|           +-input_scan=
|             +-ProjectScan
|               +-column_list=[$subquery1.array_to_search#4]
|               +-expr_list=
|               | +-array_to_search#4 := Literal(type=ARRAY<INT64>, value=[1, 2, 3])
|               +-input_scan=
|                 +-SingleRowScan
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=141-144, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=BOOL, column=$aggregate.$agg1#3)
[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaBodyAccessingGroupingKey(key INT64)
RETURNS BOOL AS (
  ANY_VALUE((
      SELECT
        `IF`((projectscan_2.a_1) IS NULL, CAST(NULL AS BOOL), EXISTS(
            SELECT
              1 AS a_5
            FROM
              UNNEST(projectscan_2.a_1) AS a_4
            WHERE
              key > 3
          )) AS a_3
      FROM
        (
          SELECT
            ARRAY< INT64 >[1, 2, 3] AS a_1
        ) AS projectscan_2
    )
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION LambdaBodyAccessingGroupingKey(key INT64)
RETURNS BOOL AS (
  ANY_VALUE((
      SELECT
        ARRAY< INT64 >[1, 2, 3] AS a_1
      |> AS projectscan_2
      |> SELECT
           `IF`((projectscan_2.a_1) IS NULL, CAST(NULL AS BOOL), EXISTS(
               FROM
                 UNNEST(projectscan_2.a_1) AS a_4
               |> WHERE
                    key > 3
               |> SELECT
                    1 AS a_5
             )) AS a_3
    )
    GROUP BY key)
);
==

CREATE AGGREGATE FUNCTION CorrelatedGroupingConstness(key INT64) AS (
  SUM(
    (
      SELECT
        SUM(key GROUP BY key)
      FROM UNNEST([1,2,3])
    )
    GROUP BY key
  )
);
--
CreateFunctionStmt
+-name_path=CorrelatedGroupingConstness
+-return_type=INT64
+-argument_name_list=[key]
+-signature=(INT64 key) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(\n    (\n      SELECT\n        SUM(key GROUP BY key)\n      FROM UNNEST([1,2,3])\n    )\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#5 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-SubqueryExpr
|       +-type=INT64
|       +-subquery_type=SCALAR
|       +-parameter_list=
|       | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|       +-subquery=
|         +-ProjectScan
|           +-column_list=[$aggregate.$agg1#4]
|           +-input_scan=
|             +-AggregateScan
|               +-column_list=[$aggregate.$agg1#4]
|               +-input_scan=
|               | +-ArrayScan
|               |   +-array_expr_list=
|               |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
|               |   +-element_column_list=[$array.$unnest1#2]
|               +-aggregate_list=
|                 +-$agg1#4 :=
|                   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|                     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|                     +-group_by_list=
|                       +-$groupbymod#3 := ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=172-175, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#5)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION CorrelatedGroupingConstness(key INT64)
RETURNS INT64 AS (
  SUM((
      SELECT
        SUM(key
          GROUP BY key) AS a_2
      FROM
        UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1
    )
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION CorrelatedGroupingConstness(key INT64)
RETURNS INT64 AS (
  SUM((
      FROM
        UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1
      |> AGGREGATE
           SUM(key
             GROUP BY key) AS a_2)
    GROUP BY key)
);
==

# NOT AGGREGATE args can be referenced in the post-grouping context of a
# multi-level aggregation (even if not explicitly grouped by).
CREATE AGGREGATE FUNCTION GroupingConstArg(value INT64, not_agg INT64 NOT AGGREGATE) AS (
  SUM(not_agg GROUP BY value)
);
--
CreateFunctionStmt
+-name_path=GroupingConstArg
+-return_type=INT64
+-argument_name_list=[value, not_agg]
+-signature=(INT64 value, INT64 {is_not_aggregate: true} not_agg) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(not_agg GROUP BY value)"
+-aggregate_expression_list=
| +-$agg1#2 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-ArgumentRef(type=INT64, name="not_agg", argument_kind=NOT_AGGREGATE)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=113-118, type=INT64, name="value", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#2)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstArg(value INT64, not_agg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM(not_agg
    GROUP BY value)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION GroupingConstArg(value INT64, not_agg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM(not_agg
    GROUP BY value)
);
==

SELECT
  ARRAY_TRANSFORM(
    [x],
    e ->
      (
        SELECT
          SUM(
            (SELECT MAX(t2.key) FROM KeyValue t2 WHERE t2.key < e GROUP BY value)
          )
        FROM UNNEST([1,2,3]) AS y
      )
  )
FROM UNNEST([1,2,3]) AS x
--
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-FunctionCall(ZetaSQL:array_transform(ARRAY<INT64> array_to_transform, FUNCTION<INT64->INT64> transformation) -> ARRAY<INT64>)
    |     +-FunctionArgument
    |     | +-expr=
    |     |   +-FunctionCall(ZetaSQL:$make_array(repeated(1) INT64) -> ARRAY<INT64>)
    |     |     +-ColumnRef(type=INT64, column=$array.x#1)
    |     +-FunctionArgument
    |       +-inline_lambda=
    |         +-InlineLambda
    |           +-argument_list=[$lambda_arg.e#2]
    |           +-body=
    |             +-SubqueryExpr
    |               +-type=INT64
    |               +-subquery_type=SCALAR
    |               +-parameter_list=
    |               | +-ColumnRef(type=INT64, column=$lambda_arg.e#2)
    |               +-subquery=
    |                 +-ProjectScan
    |                   +-column_list=[$aggregate.$agg1#8]
    |                   +-input_scan=
    |                     +-AggregateScan
    |                       +-column_list=[$aggregate.$agg1#8]
    |                       +-input_scan=
    |                       | +-ArrayScan
    |                       |   +-array_expr_list=
    |                       |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |                       |   +-element_column_list=[$array.y#3]
    |                       +-aggregate_list=
    |                         +-$agg1#8 :=
    |                           +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |                             +-SubqueryExpr
    |                               +-type=INT64
    |                               +-subquery_type=SCALAR
    |                               +-parameter_list=
    |                               | +-ColumnRef(type=INT64, column=$lambda_arg.e#2, is_correlated=TRUE)
    |                               +-subquery=
    |                                 +-ProjectScan
    |                                   +-column_list=[$aggregate.$agg1#6]
    |                                   +-input_scan=
    |                                     +-AggregateScan
    |                                       +-column_list=[$aggregate.$agg1#6]
    |                                       +-input_scan=
    |                                       | +-FilterScan
    |                                       |   +-column_list=KeyValue.[Key#4, Value#5]
    |                                       |   +-input_scan=
    |                                       |   | +-TableScan(column_list=KeyValue.[Key#4, Value#5], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |                                       |   +-filter_expr=
    |                                       |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |                                       |       +-ColumnRef(type=INT64, column=KeyValue.Key#4)
    |                                       |       +-ColumnRef(type=INT64, column=$lambda_arg.e#2, is_correlated=TRUE)
    |                                       +-group_by_list=
    |                                       | +-value#7 := ColumnRef(type=STRING, column=KeyValue.Value#5)
    |                                       +-aggregate_list=
    |                                         +-$agg1#6 :=
    |                                           +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |                                             +-ColumnRef(type=INT64, column=KeyValue.Key#4)
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.x#1]
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        +-element_column_list=[$array.x#1]

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  ARRAY_TRANSFORM(ARRAY< INT64 >[a_1], (a_3) -> (
      SELECT
        SUM((
            SELECT
              MAX(KeyValue.Key) AS a_7
            FROM
              KeyValue
            WHERE
              (KeyValue.Key) < a_3
            GROUP BY KeyValue.Value
          )) AS a_8
      FROM
        UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_4
    )) AS a_2
FROM
  UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1
|> SELECT
     ARRAY_TRANSFORM(ARRAY< INT64 >[a_1], (a_3) -> (
         FROM
           UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_4
         |> AGGREGATE
              SUM((
                  SELECT
                    MAX(KeyValue.Key) AS a_7
                  FROM
                    KeyValue
                  WHERE
                    (KeyValue.Key) < a_3
                  GROUP BY KeyValue.Value
                  |> AS aggregatescan_8
                  |> SELECT
                       aggregatescan_8.a_7 AS a_7
                )) AS a_9)) AS a_2;

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$query.$col1#9 AS `$col1` [ARRAY<INT64>]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#9]
    +-expr_list=
    | +-$col1#9 :=
    |   +-SubqueryExpr
    |     +-type=ARRAY<INT64>
    |     +-subquery_type=SCALAR
    |     +-parameter_list=
    |     | +-ColumnRef(type=INT64, column=$array.x#1)
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#14]
    |         +-expr_list=
    |         | +-$col1#14 :=
    |         |   +-FunctionCall(ZetaSQL:if(BOOL, ARRAY<INT64>, ARRAY<INT64>) -> ARRAY<INT64>)
    |         |     +-FunctionCall(ZetaSQL:$is_null(ARRAY<INT64>) -> BOOL)
    |         |     | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_transform#10)
    |         |     +-Literal(type=ARRAY<INT64>, value=NULL)
    |         |     +-SubqueryExpr
    |         |       +-type=ARRAY<INT64>
    |         |       +-subquery_type=ARRAY
    |         |       +-parameter_list=
    |         |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_transform#10)
    |         |       +-subquery=
    |         |         +-OrderByScan
    |         |           +-column_list=[$expr_subquery.$col1#13]
    |         |           +-is_ordered=TRUE
    |         |           +-input_scan=
    |         |           | +-ProjectScan
    |         |           |   +-column_list=[$array.element#11, $array_offset.off#12, $expr_subquery.$col1#13]
    |         |           |   +-expr_list=
    |         |           |   | +-$col1#13 :=
    |         |           |   |   +-SubqueryExpr
    |         |           |   |     +-type=INT64
    |         |           |   |     +-subquery_type=SCALAR
    |         |           |   |     +-parameter_list=
    |         |           |   |     | +-ColumnRef(type=INT64, column=$array.element#11)
    |         |           |   |     +-subquery=
    |         |           |   |       +-ProjectScan
    |         |           |   |         +-column_list=[$aggregate.$agg1#15]
    |         |           |   |         +-input_scan=
    |         |           |   |           +-AggregateScan
    |         |           |   |             +-column_list=[$aggregate.$agg1#15]
    |         |           |   |             +-input_scan=
    |         |           |   |             | +-ArrayScan
    |         |           |   |             |   +-array_expr_list=
    |         |           |   |             |   | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
    |         |           |   |             |   +-element_column_list=[$array.y#16]
    |         |           |   |             +-aggregate_list=
    |         |           |   |               +-$agg1#15 :=
    |         |           |   |                 +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
    |         |           |   |                   +-SubqueryExpr
    |         |           |   |                     +-type=INT64
    |         |           |   |                     +-subquery_type=SCALAR
    |         |           |   |                     +-parameter_list=
    |         |           |   |                     | +-ColumnRef(type=INT64, column=$array.element#11, is_correlated=TRUE)
    |         |           |   |                     +-subquery=
    |         |           |   |                       +-ProjectScan
    |         |           |   |                         +-column_list=[$aggregate.$agg1#17]
    |         |           |   |                         +-input_scan=
    |         |           |   |                           +-AggregateScan
    |         |           |   |                             +-column_list=[$aggregate.$agg1#17]
    |         |           |   |                             +-input_scan=
    |         |           |   |                             | +-FilterScan
    |         |           |   |                             |   +-column_list=KeyValue.[Key#18, Value#19]
    |         |           |   |                             |   +-input_scan=
    |         |           |   |                             |   | +-TableScan(column_list=KeyValue.[Key#18, Value#19], table=KeyValue, column_index_list=[0, 1], alias="t2")
    |         |           |   |                             |   +-filter_expr=
    |         |           |   |                             |     +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    |         |           |   |                             |       +-ColumnRef(type=INT64, column=KeyValue.Key#18)
    |         |           |   |                             |       +-ColumnRef(type=INT64, column=$array.element#11, is_correlated=TRUE)
    |         |           |   |                             +-group_by_list=
    |         |           |   |                             | +-value#20 := ColumnRef(type=STRING, column=KeyValue.Value#19)
    |         |           |   |                             +-aggregate_list=
    |         |           |   |                               +-$agg1#17 :=
    |         |           |   |                                 +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
    |         |           |   |                                   +-ColumnRef(type=INT64, column=KeyValue.Key#18)
    |         |           |   +-input_scan=
    |         |           |     +-ArrayScan
    |         |           |       +-column_list=[$array.element#11, $array_offset.off#12]
    |         |           |       +-array_expr_list=
    |         |           |       | +-ColumnRef(type=ARRAY<INT64>, column=$subquery1.array_to_transform#10, is_correlated=TRUE)
    |         |           |       +-element_column_list=[$array.element#11]
    |         |           |       +-array_offset_column=
    |         |           |         +-ColumnHolder(column=$array_offset.off#12)
    |         |           +-order_by_item_list=
    |         |             +-OrderByItem
    |         |               +-column_ref=
    |         |                 +-ColumnRef(type=INT64, column=$array_offset.off#12)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$subquery1.array_to_transform#10]
    |             +-expr_list=
    |             | +-array_to_transform#10 :=
    |             |   +-FunctionCall(ZetaSQL:$make_array(repeated(1) INT64) -> ARRAY<INT64>)
    |             |     +-ColumnRef(type=INT64, column=$array.x#1, is_correlated=TRUE)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-ArrayScan
        +-column_list=[$array.x#1]
        +-array_expr_list=
        | +-Literal(type=ARRAY<INT64>, value=[1, 2, 3])
        +-element_column_list=[$array.x#1]
[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  (
    SELECT
      `IF`((projectscan_4.a_3) IS NULL, CAST(NULL AS ARRAY< INT64 >), ARRAY(
          SELECT
            projectscan_14.a_8 AS a_8
          FROM
            (
              SELECT
                a_6 AS a_6,
                a_7 AS a_7,
                (
                  SELECT
                    SUM((
                        SELECT
                          MAX(KeyValue.Key) AS a_12
                        FROM
                          KeyValue
                        WHERE
                          (KeyValue.Key) < a_6
                        GROUP BY KeyValue.Value
                      )) AS a_13
                  FROM
                    UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_9
                ) AS a_8
              FROM
                UNNEST(projectscan_4.a_3) AS a_6 WITH OFFSET AS a_7
            ) AS projectscan_14
          ORDER BY projectscan_14.a_7)) AS a_5
    FROM
      (
        SELECT
          ARRAY< INT64 >[a_1] AS a_3
      ) AS projectscan_4
  ) AS a_2
FROM
  UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1;

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_1
|> SELECT
     (
       SELECT
         ARRAY< INT64 >[a_1] AS a_3
       |> AS projectscan_4
       |> SELECT
            `IF`((projectscan_4.a_3) IS NULL, CAST(NULL AS ARRAY< INT64 >), ARRAY(
                FROM
                  UNNEST(projectscan_4.a_3) AS a_6 WITH OFFSET AS a_7
                |> SELECT
                     a_6 AS a_6,
                     a_7 AS a_7,
                     (
                       FROM
                         UNNEST(ARRAY< INT64 >[1, 2, 3]) AS a_9
                       |> AGGREGATE
                            SUM((
                                SELECT
                                  MAX(KeyValue.Key) AS a_12
                                FROM
                                  KeyValue
                                WHERE
                                  (KeyValue.Key) < a_6
                                GROUP BY KeyValue.Value
                                |> AS aggregatescan_13
                                |> SELECT
                                     aggregatescan_13.a_12 AS a_12
                              )) AS a_14) AS a_8
                |> AS projectscan_15
                |> ORDER BY projectscan_15.a_7
                |> SELECT
                     projectscan_15.a_8 AS a_8
              )) AS a_5
     ) AS a_2;
==

#
CREATE FUNCTION GroupingConstantFromUnnest(arr ARRAY<INT64>, int64_arg INT64)
RETURNS INT64 AS (
  (SELECT SUM(X GROUP BY X) FROM UNNEST(arr) AS X)
);
--
CreateFunctionStmt
+-name_path=GroupingConstantFromUnnest
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[arr, int64_arg]
+-signature=(ARRAY<INT64> arr, INT64 int64_arg) -> INT64
+-language="SQL"
+-code="(SELECT SUM(X GROUP BY X) FROM UNNEST(arr) AS X)"
+-function_expression=
  +-SubqueryExpr
    +-type=INT64
    +-subquery_type=SCALAR
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-ArrayScan
            |   +-column_list=[$array.X#1]
            |   +-array_expr_list=
            |   | +-ArgumentRef(type=ARRAY<INT64>, name="arr")
            |   +-element_column_list=[$array.X#1]
            +-aggregate_list=
              +-$agg1#3 :=
                +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#2)
                  +-group_by_list=
                    +-$groupbymod#2 := ColumnRef(type=INT64, column=$array.X#1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE FUNCTION GroupingConstantFromUnnest(arr ARRAY< INT64 >, int64_arg INT64)
RETURNS INT64 AS (
  (
    SELECT
      SUM(a_1
        GROUP BY a_1) AS a_2
    FROM
      UNNEST(arr) AS a_1
  )
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE FUNCTION GroupingConstantFromUnnest(arr ARRAY< INT64 >, int64_arg INT64)
RETURNS INT64 AS (
  (
    FROM
      UNNEST(arr) AS a_1
    |> AGGREGATE
         SUM(a_1
           GROUP BY a_1) AS a_2)
);
==

CREATE FUNCTION GroupingConstantFromArg(arr ARRAY<INT64>, int64_arg INT64)
RETURNS INT64 AS (
  (SELECT SUM(int64_arg GROUP BY X) FROM UNNEST(arr) AS X)
);
--
CreateFunctionStmt
+-name_path=GroupingConstantFromArg
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[arr, int64_arg]
+-signature=(ARRAY<INT64> arr, INT64 int64_arg) -> INT64
+-language="SQL"
+-code="(SELECT SUM(int64_arg GROUP BY X) FROM UNNEST(arr) AS X)"
+-function_expression=
  +-SubqueryExpr
    +-type=INT64
    +-subquery_type=SCALAR
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#3]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.$agg1#3]
            +-input_scan=
            | +-ArrayScan
            |   +-column_list=[$array.X#1]
            |   +-array_expr_list=
            |   | +-ArgumentRef(type=ARRAY<INT64>, name="arr")
            |   +-element_column_list=[$array.X#1]
            +-aggregate_list=
              +-$agg1#3 :=
                +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
                  +-ArgumentRef(type=INT64, name="int64_arg")
                  +-group_by_list=
                    +-$groupbymod#2 := ColumnRef(type=INT64, column=$array.X#1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE FUNCTION GroupingConstantFromArg(arr ARRAY< INT64 >, int64_arg INT64)
RETURNS INT64 AS (
  (
    SELECT
      SUM(int64_arg
        GROUP BY a_1) AS a_2
    FROM
      UNNEST(arr) AS a_1
  )
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE FUNCTION GroupingConstantFromArg(arr ARRAY< INT64 >, int64_arg INT64)
RETURNS INT64 AS (
  (
    FROM
      UNNEST(arr) AS a_1
    |> AGGREGATE
         SUM(int64_arg
           GROUP BY a_1) AS a_2)
);
==

CREATE AGGREGATE FUNCTION WithExprAccessingGroupingConstAndArg(key INT64, not_aggregate_arg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM(
    WITH(key_times_two AS key * 2, key_times_two + not_aggregate_arg)
    GROUP BY key
  )
);
--
CreateFunctionStmt
+-name_path=WithExprAccessingGroupingConstAndArg
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[key, not_aggregate_arg]
+-signature=(INT64 key, INT64 {is_not_aggregate: true} not_aggregate_arg) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(\n    WITH(key_times_two AS key * 2, key_times_two + not_aggregate_arg)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-WithExpr
|       +-type=INT64
|       +-assignment_list=
|       | +-key_times_two#2 :=
|       |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
|       |     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|       |     +-Literal(type=INT64, value=2)
|       +-expr=
|         +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|           +-ColumnRef(type=INT64, column=$with_expr.key_times_two#2)
|           +-ArgumentRef(type=INT64, name="not_aggregate_arg", argument_kind=NOT_AGGREGATE)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=222-225, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION WithExprAccessingGroupingConstAndArg(key INT64, not_aggregate_arg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM(WITH(a_1 AS key * 2, a_1 + not_aggregate_arg)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION WithExprAccessingGroupingConstAndArg(key INT64, not_aggregate_arg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM(WITH(a_1 AS key * 2, a_1 + not_aggregate_arg)
    GROUP BY key)
);

[REWRITTEN AST]
CreateFunctionStmt
+-name_path=WithExprAccessingGroupingConstAndArg
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[key, not_aggregate_arg]
+-signature=(INT64 key, INT64 {is_not_aggregate: true} not_aggregate_arg) -> INT64
+-is_aggregate=TRUE
+-language="SQL"
+-code="SUM(\n    WITH(key_times_two AS key * 2, key_times_two + not_aggregate_arg)\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#3 :=
|   +-AggregateFunctionCall(ZetaSQL:sum(INT64) -> INT64)
|     +-SubqueryExpr
|       +-type=INT64
|       +-subquery_type=SCALAR
|       +-parameter_list=
|       | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|       +-subquery=
|         +-ProjectScan
|           +-column_list=[$with_expr.injected#4]
|           +-expr_list=
|           | +-injected#4 :=
|           |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
|           |     +-ColumnRef(type=INT64, column=$with_expr.key_times_two#2)
|           |     +-ArgumentRef(type=INT64, name="not_aggregate_arg", argument_kind=NOT_AGGREGATE)
|           +-input_scan=
|             +-ProjectScan
|               +-column_list=[$with_expr.key_times_two#2]
|               +-expr_list=
|               | +-key_times_two#2 :=
|               |   +-FunctionCall(ZetaSQL:$multiply(INT64, INT64) -> INT64)
|               |     +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|               |     +-Literal(type=INT64, value=2)
|               +-input_scan=
|                 +-SingleRowScan
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=222-225, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=INT64, column=$aggregate.$agg1#3)
[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION WithExprAccessingGroupingConstAndArg(key INT64, not_aggregate_arg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM((
      SELECT
        (projectscan_2.a_1) + not_aggregate_arg AS a_3
      FROM
        (
          SELECT
            key * 2 AS a_1
        ) AS projectscan_2
    )
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION WithExprAccessingGroupingConstAndArg(key INT64, not_aggregate_arg INT64 NOT AGGREGATE)
RETURNS INT64 AS (
  SUM((
      SELECT
        key * 2 AS a_1
      |> AS projectscan_2
      |> SELECT
           (projectscan_2.a_1) + not_aggregate_arg AS a_3
    )
    GROUP BY key)
);
==

[language_features=NONE,+MULTILEVEL_AGGREGATION,+CREATE_AGGREGATE_FUNCTION]
CREATE AGGREGATE FUNCTION MLAWithSubqueryArgumentContainingMLA(key INT64, arr1 ARRAY<INT64> NOT AGGREGATE) AS (
  CORR(
    key,
    (SELECT MAX(key GROUP BY key) FROM UNNEST(arr1))
    GROUP BY key
  )
);
--
CreateFunctionStmt
+-name_path=MLAWithSubqueryArgumentContainingMLA
+-return_type=DOUBLE
+-argument_name_list=[key, arr1]
+-signature=(INT64 key, ARRAY<INT64> {is_not_aggregate: true} arr1) -> DOUBLE
+-is_aggregate=TRUE
+-language="SQL"
+-code="CORR(\n    key,\n    (SELECT MAX(key GROUP BY key) FROM UNNEST(arr1))\n    GROUP BY key\n  )"
+-aggregate_expression_list=
| +-$agg1#5 :=
|   +-AggregateFunctionCall(ZetaSQL:corr(DOUBLE, DOUBLE) -> DOUBLE)
|     +-Cast(INT64 -> DOUBLE)
|     | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|     +-Cast(INT64 -> DOUBLE)
|       +-SubqueryExpr
|         +-type=INT64
|         +-subquery_type=SCALAR
|         +-parameter_list=
|         | +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1)
|         +-subquery=
|           +-ProjectScan
|             +-column_list=[$aggregate.$agg1#4]
|             +-input_scan=
|               +-AggregateScan
|                 +-column_list=[$aggregate.$agg1#4]
|                 +-input_scan=
|                 | +-ArrayScan
|                 |   +-array_expr_list=
|                 |   | +-ArgumentRef(type=ARRAY<INT64>, name="arr1", argument_kind=NOT_AGGREGATE)
|                 |   +-element_column_list=[$array.$unnest1#2]
|                 +-aggregate_list=
|                   +-$agg1#4 :=
|                     +-AggregateFunctionCall(ZetaSQL:max(INT64) -> INT64)
|                       +-ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|                       +-group_by_list=
|                         +-$groupbymod#3 := ColumnRef(type=INT64, column=$group_by_list.$groupbymod#1, is_correlated=TRUE)
|     +-group_by_list=
|       +-$groupbymod#1 := ArgumentRef(parse_location=195-198, type=INT64, name="key", argument_kind=AGGREGATE)
+-function_expression=
  +-ColumnRef(type=DOUBLE, column=$aggregate.$agg1#5)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION MLAWithSubqueryArgumentContainingMLA(key INT64, arr1 ARRAY< INT64 > NOT AGGREGATE)
RETURNS DOUBLE AS (
  CORR(CAST(key AS DOUBLE), CAST((
      SELECT
        MAX(key
          GROUP BY key) AS a_2
      FROM
        UNNEST(arr1) AS a_1
    ) AS DOUBLE)
    GROUP BY key)
);

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
CREATE AGGREGATE FUNCTION MLAWithSubqueryArgumentContainingMLA(key INT64, arr1 ARRAY< INT64 > NOT AGGREGATE)
RETURNS DOUBLE AS (
  CORR(CAST(key AS DOUBLE), CAST((
      FROM
        UNNEST(arr1) AS a_1
      |> AGGREGATE
           MAX(key
             GROUP BY key) AS a_2) AS DOUBLE)
    GROUP BY key)
);
==

# ORDER BY in UDA is not supported (even in nested multi-level aggregate
# function).
[language_features=NONE,+CREATE_AGGREGATE_FUNCTION,+TEMPLATE_FUNCTIONS,+MULTILEVEL_AGGREGATION,+ORDER_BY_IN_AGGREGATE]
CREATE AGGREGATE FUNCTION InvalidUdaOrderBy(arg INT64, key INT64) AS (
  SUM(ARRAY_AGG(arg ORDER BY arg, key)[OFFSET(0)] GROUP BY key)
);
--
ERROR: Function body with aggregate functions with ORDER BY not currently supported [at 2:3]
  SUM(ARRAY_AGG(arg ORDER BY arg, key)[OFFSET(0)] GROUP BY key)
  ^
