# This file tests the analytic support for non-aggregate analytic functions.

# For RANK and DENSE_RANK, ORDER BY is required and PARTITION BY is optional.
[default language_features=NONE,+ANALYTIC_FUNCTIONS]
select rank() over w1,
       dense_rank() over w1,
       rank() over w2,
       dense_rank() over w2
from keyvalue
window w1 as (partition by value order by key),
       w2 as (order by key)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7 AS `$col1` [INT64]
| +-$analytic.$analytic2#8 AS `$col2` [INT64]
| +-$analytic.$analytic3#9 AS `$col3` [INT64]
| +-$analytic.$analytic4#10 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8, $analytic3#9, $analytic4#10]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9, $analytic.$analytic4#10]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-analytic_function_list=
          |   +-$analytic1#7 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
          |   +-$analytic2#8 := AnalyticFunctionCall(ZetaSQL:dense_rank() -> INT64)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic3#9 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)
              +-$analytic4#10 := AnalyticFunctionCall(ZetaSQL:dense_rank() -> INT64)
==

# ORDER BY is required in RANK and DENSE_RANK.
select {{rank()|dense_rank()}} over () from keyvalue
--
ALTERNATION GROUP: rank()
--
ERROR: Window ORDER BY is required for analytic function rank [at 1:20]
select rank() over () from keyvalue
                   ^
--
ALTERNATION GROUP: dense_rank()
--
ERROR: Window ORDER BY is required for analytic function dense_rank [at 1:26]
select dense_rank() over () from keyvalue
                         ^
==

# Window frame is not allowed in RANK and DENSE_RANK.
select {{rank()|dense_rank()}} over (order by key rows 2 preceding)
from keyvalue
--
ALTERNATION GROUP: rank()
--
ERROR: Window framing clause is not allowed for analytic function rank [at 1:34]
select rank() over (order by key rows 2 preceding)
                                 ^
--
ALTERNATION GROUP: dense_rank()
--
ERROR: Window framing clause is not allowed for analytic function dense_rank [at 1:40]
select dense_rank() over (order by key rows 2 preceding)
                                       ^
==

# For ROW_NUMBER, PARTITION BY and ORDER BY are optional.
select row_number() over (partition by key order by value),
       row_number() over (partition by key),
       row_number() over (order by value),
       row_number() over ()
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#7 AS `$col1` [INT64]
| +-$analytic.$analytic2#8 AS `$col2` [INT64]
| +-$analytic.$analytic3#9 AS `$col3` [INT64]
| +-$analytic.$analytic4#10 AS `$col4` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#7, $analytic2#8, $analytic3#9, $analytic4#10]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#7, $analytic.$analytic2#8, $analytic.$analytic3#9, $analytic.$analytic4#10]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic1#7 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          | +-analytic_function_list=
          |   +-$analytic2#8 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic3#9 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic4#10 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
==

# Window frame is not allowed in ROW_NUMBER.
select row_number() over (rows 2 preceding)
from keyvalue
--
ERROR: Window framing clause is not allowed for analytic function row_number [at 1:27]
select row_number() over (rows 2 preceding)
                          ^
==

# PERCENT_RANK, CUME_DIST, and NTILE allow partition by, ORDER BY is required,
# and the window frame clause is disallowed.  So most tests only test one
# of those functions for a particular OVER clause.

# An OVER clause is required.
select {{percent_rank()|cume_dist()|ntile(2)}} from KeyValue;
--
ALTERNATION GROUP: percent_rank()
--
ERROR: Analytic function PERCENT_RANK cannot be called without an OVER clause [at 1:8]
select percent_rank() from KeyValue;
       ^
--
ALTERNATION GROUP: cume_dist()
--
ERROR: Analytic function CUME_DIST cannot be called without an OVER clause [at 1:8]
select cume_dist() from KeyValue;
       ^
--
ALTERNATION GROUP: ntile(2)
--
ERROR: Analytic function NTILE cannot be called without an OVER clause [at 1:8]
select ntile(2) from KeyValue;
       ^
==

# ORDER BY is required.
select percent_rank() over () from KeyValue
--
ERROR: Window ORDER BY is required for analytic function percent_rank [at 1:28]
select percent_rank() over () from KeyValue
                           ^
==

# FROM clause is required;
select percent_rank() over (ORDER BY (select @test_param_int64))
--
ERROR: Analytic function not allowed in SELECT without FROM clause [at 1:8]
select percent_rank() over (ORDER BY (select @test_param_int64))
       ^
==

select cume_dist() over (order by key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic1#4 := AnalyticFunctionCall(ZetaSQL:cume_dist() -> DOUBLE)
==

select ntile(2) over (partition by value order BY key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:ntile(INT64) -> INT64)
                  +-Literal(type=INT64, value=2)
==

# Window frame not allowed.
select percent_rank() over
  (order BY key rows between unbounded preceding and unbounded following)
from keyvalue;
--
ERROR: Window framing clause is not allowed for analytic function percent_rank [at 2:17]
  (order BY key rows between unbounded preceding and unbounded following)
                ^
==

# NTILE requires a non-NULL integer literal, or parameter.
select ntile(@test_param_int64) over (order by value),
       ntile(1) over (order by value),
       ntile(0) over (order by value)
from keyvalue;
--
ERROR: The argument to NTILE must be at least 1 [at 3:14]
       ntile(0) over (order by value)
             ^
==

select ntile(-1) over (order by value)
from keyvalue;
--
ERROR: The argument to NTILE must be at least 1 [at 1:14]
select ntile(-1) over (order by value)
             ^
==

# UINT64 literals are not allowed as NTILE arguments.
select ntile(99999999999999999999) over (order by value)
from keyvalue
--
ERROR: Invalid integer literal: 99999999999999999999 [at 1:14]
select ntile(99999999999999999999) over (order by value)
             ^
==

select ntile(null) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be non-NULL [at 1:14]
select ntile(null) over (order by value) from keyvalue;
             ^
==

select ntile("1") over (order by value) from keyvalue;
--
ERROR: No matching signature for analytic function NTILE
  Argument types: STRING
  Signature: NTILE(INT64)
    Argument 1: Unable to coerce type STRING to expected type INT64 [at 1:8]
select ntile("1") over (order by value) from keyvalue;
       ^
==

select ntile(true) over (order by value) from keyvalue;
--
ERROR: No matching signature for analytic function NTILE
  Argument types: BOOL
  Signature: NTILE(INT64)
    Argument 1: Unable to coerce type BOOL to expected type INT64 [at 1:8]
select ntile(true) over (order by value) from keyvalue;
       ^
==

select ntile(coalesce(1)) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be a literal or query parameter [at 1:14]
select ntile(coalesce(1)) over (order by value) from keyvalue;
             ^
==

select ntile(cast(1 as int32)) over (order by value) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:ntile(INT64) -> INT64)
                  +-Literal(type=INT64, value=1, has_explicit_type=TRUE)
==

select ntile(key) over (order by value) from keyvalue;
--
ERROR: The argument to NTILE must be a literal or query parameter [at 1:14]
select ntile(key) over (order by value) from keyvalue;
             ^
==

# For lead and lag, ORDER BY is required and window frames are not allowed.
# The argument must be a non-NULL constant integer expression.  The second
# two arguments are optional.

# One argument is required.
select {{lead()|lag()}} over (order by key) from keyvalue
--
ALTERNATION GROUP: lead()
--
ERROR: No matching signature for analytic function LEAD with no arguments
  Signature: LEAD(T1, [INT64], [T1])
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
select lead() over (order by key) from keyvalue
       ^
--
ALTERNATION GROUP: lag()
--
ERROR: No matching signature for analytic function LAG with no arguments
  Signature: LAG(T1, [INT64], [T1])
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
select lag() over (order by key) from keyvalue
       ^
==

# NULL not allowed for offset
select lead(value, NULL) over (order by value)
from keyvalue
--
ERROR: Argument 2 to LEAD must be non-NULL [at 1:20]
select lead(value, NULL) over (order by value)
                   ^
==

# Non-constant not allowed for offset.
select lead(value, key) over (order by value)
from keyvalue
--
ERROR: Argument 2 to LEAD must be a literal or query parameter [at 1:20]
select lead(value, key) over (order by value)
                   ^
==

# TODO: We should populate all of the optional arguments in the
# resolved tree.
select lead(value) over window1,
       lead(value, 1) over window1,
       lag(value, @test_param_int32) over window1,
       lead(value, -1, NULL) over window1,
       lag(value, 0, "string_constant") over window1,
       lag(key, 5000, key+1) over window1
from keyvalue
window window1 as (partition by key+1 order by value)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#9 AS `$col1` [STRING]
| +-$analytic.$analytic2#10 AS `$col2` [STRING]
| +-$analytic.$analytic3#11 AS `$col3` [STRING]
| +-$analytic.$analytic4#12 AS `$col4` [STRING]
| +-$analytic.$analytic5#13 AS `$col5` [STRING]
| +-$analytic.$analytic6#14 AS `$col6` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#9, $analytic2#10, $analytic3#11, $analytic4#12, $analytic5#13, $analytic6#14]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#9, $analytic.$analytic2#10, $analytic.$analytic3#11, $analytic.$analytic4#12, $analytic.$analytic5#13, $analytic.$analytic6#14]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.$partitionbycol1#15]
        |   +-expr_list=
        |   | +-$partitionbycol1#15 :=
        |   |   +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
        |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |   |     +-Literal(type=INT64, value=1)
        |   +-input_scan=
        |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#15)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#9 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(0) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              +-$analytic2#10 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(1) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=1)
              +-$analytic3#11 :=
              | +-AnalyticFunctionCall(ZetaSQL:lag(STRING, optional(1) INT64, optional(0) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Cast(INT32 -> INT64)
              |     +-Parameter(type=INT32, name="test_param_int32")
              +-$analytic4#12 :=
              | +-AnalyticFunctionCall(ZetaSQL:lead(STRING, optional(1) INT64, optional(1) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=-1)
              |   +-Literal(type=STRING, value=NULL)
              +-$analytic5#13 :=
              | +-AnalyticFunctionCall(ZetaSQL:lag(STRING, optional(1) INT64, optional(1) STRING) -> STRING)
              |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
              |   +-Literal(type=INT64, value=0)
              |   +-Literal(type=STRING, value="string_constant")
              +-$analytic6#14 :=
                +-AnalyticFunctionCall(ZetaSQL:lag(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=INT64, value=5000)
                  +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
                    +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                    +-Literal(type=INT64, value=1)
==

# The result type of the lead/lag expression is the supertype of the
# first and third (default) expressions.
select lead(uint32, 1, int32) over (order by int64) from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#21 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#21]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#21]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#21 :=
                +-AnalyticFunctionCall(ZetaSQL:lead(INT64, optional(1) INT64, optional(1) INT64) -> INT64)
                  +-Cast(UINT32 -> INT64)
                  | +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Literal(type=INT64, value=1)
                  +-Cast(INT32 -> INT64)
                    +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
==

# FIRST_VALUE and LAST_VALUE requires one argument.  ORDER BY is required.
# PARTITION BY and window frame are optional.

select {{first_value|last_value}}() over (order by int64)
from simpletypes;
--
ALTERNATION GROUP: first_value
--
ERROR: No matching signature for analytic function FIRST_VALUE with no arguments
  Signature: FIRST_VALUE(T1)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
select first_value() over (order by int64)
       ^
--
ALTERNATION GROUP: last_value
--
ERROR: No matching signature for analytic function LAST_VALUE with no arguments
  Signature: LAST_VALUE(T1)
    Signature requires at least 1 argument, found 0 arguments [at 1:8]
select last_value() over (order by int64)
       ^
==

# Their argument must not be NULL.
select first_value(NULL) over (order by int64)
from simpletypes;
--
ERROR: The argument to FIRST_VALUE must be non-NULL [at 1:20]
select first_value(NULL) over (order by int64)
                   ^
==

# ORDER BY is required.
select last_value(int32) over (partition by int64)
from simpletypes;
--
ERROR: Window ORDER BY is required for analytic function last_value [at 1:31]
select last_value(int32) over (partition by int64)
                              ^
==

# The argument can be any general expression or literal.
select first_value(uint32) over w1,
       first_value(1) over w1,
       first_value(@test_param_int32) over w1
from simpletypes
window w1 as (order by int64);
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#23 AS `$col1` [UINT32]
| +-$analytic.$analytic2#24 AS `$col2` [INT64]
| +-$analytic.$analytic3#25 AS `$col3` [INT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#23, $analytic2#24, $analytic3#25]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#23, $analytic.$analytic2#24, $analytic.$analytic3#25]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int64#2, uint32#3], table=SimpleTypes, column_index_list=[1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#23 :=
              | +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
              |   +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=RANGE)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=CURRENT ROW)
              +-$analytic2#24 :=
              | +-AnalyticFunctionCall(ZetaSQL:first_value(INT64) -> INT64)
              |   +-Literal(type=INT64, value=1)
              |   +-window_frame=
              |     +-WindowFrame(frame_unit=RANGE)
              |       +-start_expr=
              |       | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
              |       +-end_expr=
              |         +-WindowFrameExpr(boundary_type=CURRENT ROW)
              +-$analytic3#25 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(INT32) -> INT32)
                  +-Parameter(type=INT32, name="test_param_int32")
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select first_value(sum(uint32)) over (order by int64)
from simpletypes
group by int64;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#23 AS `$col1` [UINT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#23]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$groupby.int64#22, $aggregate.$agg1#20, $analytic.$analytic1#23]
        +-input_scan=
        | +-AggregateScan
        |   +-column_list=[$groupby.int64#22, $aggregate.$agg1#20]
        |   +-input_scan=
        |   | +-TableScan(column_list=SimpleTypes.[int64#2, uint32#3], table=SimpleTypes, column_index_list=[1, 2])
        |   +-group_by_list=
        |   | +-int64#22 := ColumnRef(type=INT64, column=SimpleTypes.int64#2)
        |   +-aggregate_list=
        |     +-$agg1#20 :=
        |       +-AggregateFunctionCall(ZetaSQL:sum(UINT64) -> UINT64)
        |         +-Cast(UINT32 -> UINT64)
        |           +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=$groupby.int64#22)
            +-analytic_function_list=
              +-$analytic1#23 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(UINT64) -> UINT64)
                  +-ColumnRef(type=UINT64, column=$aggregate.$agg1#20)
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

# Only one argument is allowed.
select first_value(uint32, 1) over (order by int64)
from simpletypes;
--
ERROR: No matching signature for analytic function FIRST_VALUE
  Argument types: UINT32, INT64
  Signature: FIRST_VALUE(T1)
    Signature accepts at most 1 argument, found 2 arguments [at 1:8]
select first_value(uint32, 1) over (order by int64)
       ^
==

# Partition by and window frame are allowed.
select last_value(uint32) over w1
from simpletypes
window w1 as (partition by int32 order by int64
              rows between 1 preceding and 1 following)
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#21 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#21]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#21]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-analytic_function_list=
              +-$analytic1#21 :=
                +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
                      |   +-Literal(type=INT64, value=1)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=OFFSET FOLLOWING)
                          +-Literal(type=INT64, value=1)
==

# Nth value requires two arguments, the second must be a non-null constant
# integer value.  ORDER BY is required.  PARTITION BY and window frame
# are optional.

select nth_value() over (order by int32) from simpletypes;
--
ERROR: No matching signature for analytic function NTH_VALUE with no arguments
  Signature: NTH_VALUE(T1, INT64)
    Signature requires at least 2 arguments, found 0 arguments [at 1:8]
select nth_value() over (order by int32) from simpletypes;
       ^
==

select nth_value(uint32) over (order by int32) from simpletypes;
--
ERROR: No matching signature for analytic function NTH_VALUE
  Argument types: UINT32
  Signature: NTH_VALUE(T1, INT64)
    Signature requires at least 2 arguments, found 1 argument [at 1:8]
select nth_value(uint32) over (order by int32) from simpletypes;
       ^
==

select nth_value(uint32, NULL) over (order by int32) from simpletypes;
--
ERROR: Argument 2 to NTH_VALUE must be non-NULL [at 1:26]
select nth_value(uint32, NULL) over (order by int32) from simpletypes;
                         ^
==

select nth_value(uint32, int64) over (order by int32) from simpletypes;
--
ERROR: Argument 2 to NTH_VALUE must be a literal or query parameter [at 1:26]
select nth_value(uint32, int64) over (order by int32) from simpletypes;
                         ^
==

select nth_value(uint32, @test_param_int64) over (order by int32)
from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#21 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#21]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#21]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic1#21 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Parameter(type=INT64, name="test_param_int64")
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
==

select nth_value(uint32, 5)
         over (partition by int64 order by int32
               rows between 1 preceding and unbounded following)
from simpletypes;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#21 AS `$col1` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#21]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.int64#2, SimpleTypes.uint32#3, $analytic.$analytic1#21]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, int64#2, uint32#3], table=SimpleTypes, column_index_list=[0, 1, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=SimpleTypes.int64#2)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic1#21 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Literal(type=INT64, value=5)
                  +-window_frame=
                    +-WindowFrame(frame_unit=ROWS)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=OFFSET PRECEDING)
                      |   +-Literal(type=INT64, value=1)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# IGNORE NULLS are allowed.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{,+NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select
  first_value(uint32 ignore nulls) over (order by int32),
  last_value(uint32 ignore nulls) over (order by int32),
  nth_value(uint32, @test_param_int64 ignore nulls) over (order by int32)
from simpletypes;
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#23 AS `$col1` [UINT32]
| +-$analytic.$analytic2#24 AS `$col2` [UINT32]
| +-$analytic.$analytic3#25 AS `$col3` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#23, $analytic2#24, $analytic3#25]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#23, $analytic.$analytic2#24, $analytic.$analytic3#25]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic1#23 :=
          |     +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=IGNORE_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic2#24 :=
          |     +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=IGNORE_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic3#25 :=
                +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-Parameter(type=INT64, name="test_param_int64")
                  +-null_handling_modifier=IGNORE_NULLS
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 2:3]
  first_value(uint32 ignore nulls) over (order by int32),
  ^
==

# RESPECT NULLS are allowed.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{,+NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select
  nth_value(uint32, @test_param_int64 respect nulls) over (order by int32),
  last_value(uint32 respect nulls) over (order by int32),
  first_value(uint32 respect nulls) over (order by int32)
from simpletypes;
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#23 AS `$col1` [UINT32]
| +-$analytic.$analytic2#24 AS `$col2` [UINT32]
| +-$analytic.$analytic3#25 AS `$col3` [UINT32]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#23, $analytic2#24, $analytic3#25]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[SimpleTypes.int32#1, SimpleTypes.uint32#3, $analytic.$analytic1#23, $analytic.$analytic2#24, $analytic.$analytic3#25]
        +-input_scan=
        | +-TableScan(column_list=SimpleTypes.[int32#1, uint32#3], table=SimpleTypes, column_index_list=[0, 2])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic1#23 :=
          |     +-AnalyticFunctionCall(ZetaSQL:nth_value(UINT32, INT64) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-Parameter(type=INT64, name="test_param_int64")
          |       +-null_handling_modifier=RESPECT_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
          | +-order_by=
          | | +-WindowOrdering
          | |   +-order_by_item_list=
          | |     +-OrderByItem
          | |       +-column_ref=
          | |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
          | +-analytic_function_list=
          |   +-$analytic2#24 :=
          |     +-AnalyticFunctionCall(ZetaSQL:last_value(UINT32) -> UINT32)
          |       +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
          |       +-null_handling_modifier=RESPECT_NULLS
          |       +-window_frame=
          |         +-WindowFrame(frame_unit=RANGE)
          |           +-start_expr=
          |           | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
          |           +-end_expr=
          |             +-WindowFrameExpr(boundary_type=CURRENT ROW)
          +-AnalyticFunctionGroup
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=INT32, column=SimpleTypes.int32#1)
            +-analytic_function_list=
              +-$analytic3#25 :=
                +-AnalyticFunctionCall(ZetaSQL:first_value(UINT32) -> UINT32)
                  +-ColumnRef(type=UINT32, column=SimpleTypes.uint32#3)
                  +-null_handling_modifier=RESPECT_NULLS
                  +-window_frame=
                    +-WindowFrame(frame_unit=RANGE)
                      +-start_expr=
                      | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                      +-end_expr=
                        +-WindowFrameExpr(boundary_type=CURRENT ROW)
--
ALTERNATION GROUP: <empty>
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 2:3]
  nth_value(uint32, @test_param_int64 respect nulls) over (order by int32),
  ^
==

select percentile_cont(key, 0.5) over () from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5)
==

# Both arguments are NUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+NUMERIC_TYPE}}]
select percentile_cont(cast(key as numeric), numeric "0.5") over () from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 1:36]
select percentile_cont(cast(key as numeric), numeric "0.5") over () from keyv...
                                   ^
--
ALTERNATION GROUP: ,+NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(NUMERIC, NUMERIC) -> NUMERIC)
                  +-Cast(INT64 -> NUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only one argument is NUMERIC and the other is DOUBLE/INT64;
# should not use the NUMERIC signature.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+NUMERIC_TYPE}}]
select
  percentile_cont(cast(key as numeric), 0.5) over (),
  percentile_cont(cast(key as numeric), 1) over (),
  percentile_cont(key, numeric "0.5") over()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 2:31]
  percentile_cont(cast(key as numeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,+NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS `$col1` [DOUBLE]
| +-$analytic.$analytic2#7 AS `$col2` [DOUBLE]
| +-$analytic.$analytic3#8 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#6, $analytic2#7, $analytic3#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#6, $analytic.$analytic2#7, $analytic.$analytic3#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#6 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(NUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> NUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(NUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> NUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=1)
              +-$analytic3#8 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5, has_explicit_type=TRUE)
==

# Both arguments are BIGNUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+BIGNUMERIC_TYPE}}]
select percentile_cont(cast(key as bignumeric), bignumeric "0.5") over () from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 1:36]
select percentile_cont(cast(key as bignumeric), bignumeric "0.5") over () fro...
                                   ^
--
ALTERNATION GROUP: ,+BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only one argument is BIGNUMERIC and the other is DOUBLE/INT64;
# should not use the BIGNUMERIC signature.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+BIGNUMERIC_TYPE}}]
select
  percentile_cont(cast(key as bignumeric), 0.5) over (),
  percentile_cont(cast(key as bignumeric), 1) over (),
  percentile_cont(key, bignumeric "0.5") over()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 2:31]
  percentile_cont(cast(key as bignumeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,+BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#6 AS `$col1` [DOUBLE]
| +-$analytic.$analytic2#7 AS `$col2` [DOUBLE]
| +-$analytic.$analytic3#8 AS `$col3` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#6, $analytic2#7, $analytic3#8]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#6, $analytic.$analytic2#7, $analytic.$analytic3#8]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#6 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(BIGNUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> BIGNUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#7 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
              |   +-Cast(BIGNUMERIC -> DOUBLE)
              |   | +-Cast(INT64 -> BIGNUMERIC)
              |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=1)
              +-$analytic3#8 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0.5, has_explicit_type=TRUE)
==

# One argument is BIGNUMERIC and the other is NUMERIC;
# should use the BIGNUMERIC signature.
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NUMERIC_TYPE,+BIGNUMERIC_TYPE]
select
  percentile_cont(cast(key as bignumeric), numeric "0.5") over (),
  percentile_cont(cast(key as numeric), bignumeric "0.5") over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [BIGNUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
              |   +-Cast(INT64 -> BIGNUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(BIGNUMERIC, BIGNUMERIC) -> BIGNUMERIC)
                  +-Cast(NUMERIC -> BIGNUMERIC)
                  | +-Cast(INT64 -> NUMERIC)
                  |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# PARTITION BY is allowed for percentile_cont.
select percentile_cont(key, 0) over (partition by value) from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=0)
==

select
  percentile_disc(key, 0.5) over (),
  percentile_disc(value, 0.5) over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, DOUBLE) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=DOUBLE, value=0.5)
==

# Only first argument is NUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+NUMERIC_TYPE}}]
select
  percentile_disc(cast(key as numeric), 0.5) over (),
  percentile_disc(cast(key as numeric), 1) over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: numeric [at 2:31]
  percentile_disc(cast(key as numeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,+NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [NUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [NUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, DOUBLE) -> NUMERIC)
              |   +-Cast(INT64 -> NUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, DOUBLE) -> NUMERIC)
                  +-Cast(INT64 -> NUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
==

# Only second argument is NUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+NUMERIC_TYPE}}]
select
  percentile_disc(key, NUMERIC "0.5") over (),
  percentile_disc(value, NUMERIC "0.5") over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: NUMERIC literals are not supported [at 2:24]
  percentile_disc(key, NUMERIC "0.5") over (),
                       ^
--
ALTERNATION GROUP: ,+NUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, NUMERIC) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, NUMERIC) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Only first argument is BIGNUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+BIGNUMERIC_TYPE}}]
select
  percentile_disc(cast(key as bignumeric), 0.5) over (),
  percentile_disc(cast(key as bignumeric), 1) over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: Type not found: bignumeric [at 2:31]
  percentile_disc(cast(key as bignumeric), 0.5) over (),
                              ^
--
ALTERNATION GROUP: ,+BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [BIGNUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, DOUBLE) -> BIGNUMERIC)
              |   +-Cast(INT64 -> BIGNUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=DOUBLE, value=0.5, float_literal_id=2)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, DOUBLE) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
==

# Only second argument is BIGNUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{|,+BIGNUMERIC_TYPE}}]
select
  percentile_disc(key, BIGNUMERIC "0.5") over (),
  percentile_disc(value, BIGNUMERIC "0.5") over ()
from keyvalue;
--
ALTERNATION GROUP: <empty>
--
ERROR: BIGNUMERIC literals are not supported [at 2:24]
  percentile_disc(key, BIGNUMERIC "0.5") over (),
                       ^
--
ALTERNATION GROUP: ,+BIGNUMERIC_TYPE
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, BIGNUMERIC) -> INT64)
              |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, BIGNUMERIC) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
==

# Mix of NUMERIC and BIGNUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NUMERIC_TYPE,+BIGNUMERIC_TYPE]
select
  percentile_disc(CAST(key AS NUMERIC), BIGNUMERIC "0.5") over (),
  percentile_disc(CAST(key AS BIGNUMERIC), NUMERIC "0.5") over ()
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [NUMERIC]
| +-$analytic.$analytic2#6 AS `$col2` [BIGNUMERIC]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:percentile_disc(NUMERIC, BIGNUMERIC) -> NUMERIC)
              |   +-Cast(INT64 -> NUMERIC)
              |   | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              |   +-Literal(type=BIGNUMERIC, value=0.5, has_explicit_type=TRUE)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(BIGNUMERIC, NUMERIC) -> BIGNUMERIC)
                  +-Cast(INT64 -> BIGNUMERIC)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=NUMERIC, value=0.5, has_explicit_type=TRUE)
==

# PARTITION BY is allowed for percentile_disc.

select
  percentile_disc(key, 0.5) over (partition by value),
  percentile_disc(value, 0.5) over (partition by key)
from keyvalue;
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [INT64]
| +-$analytic.$analytic2#6 AS `$col2` [STRING]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#5, $analytic.$analytic2#6]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
          | +-partition_by=
          | | +-WindowPartitioning
          | |   +-partition_by_list=
          | |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
          | +-analytic_function_list=
          |   +-$analytic1#5 :=
          |     +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
          |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
          |       +-Literal(type=DOUBLE, value=0.5)
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-analytic_function_list=
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(STRING, DOUBLE) -> STRING)
                  +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                  +-Literal(type=DOUBLE, value=0.5)
==

# ORDER BY is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(key, 0) over (order by key) from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Window ORDER BY is not allowed for analytic function percentile_cont [at 1:38]
select percentile_cont(key, 0) over (order by key) from keyvalue;
                                     ^
--
ALTERNATION GROUP: disc
--
ERROR: Window ORDER BY is not allowed for analytic function percentile_disc [at 1:38]
select percentile_disc(key, 0) over (order by key) from keyvalue;
                                     ^
==

# Window frame is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(key, 0) over (rows 2 preceding) from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Window framing clause is not allowed for analytic function percentile_cont [at 1:38]
select percentile_cont(key, 0) over (rows 2 preceding) from keyvalue;
                                     ^
--
ALTERNATION GROUP: disc
--
ERROR: Window framing clause is not allowed for analytic function percentile_disc [at 1:38]
select percentile_disc(key, 0) over (rows 2 preceding) from keyvalue;
                                     ^
==

# DISTINCT is disallowed for percentile_cont and percentile_disc.
select percentile_{{cont|disc}}(distinct key, 0) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: DISTINCT is not allowed for analytic function percentile_cont [at 1:8]
select percentile_cont(distinct key, 0) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: DISTINCT is not allowed for analytic function percentile_disc [at 1:8]
select percentile_disc(distinct key, 0) over () from keyvalue;
       ^
==

# IGNORE NULLS and percentile=-0.0 are allowed for percentile_cont and percentile_disc.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{,+NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select percentile_{{cont|disc}}(key, -0.0 ignore nulls) over () from keyvalue;
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC,cont
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=-0)
                  +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC,disc
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=-0)
                  +-null_handling_modifier=IGNORE_NULLS
--
ALTERNATION GROUP: cont
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_cont(key, -0.0 ignore nulls) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_disc(key, -0.0 ignore nulls) over () from keyvalue;
       ^
==

# RESPECT NULLS is allowed for percentile_cont.
[language_features=NONE,+ANALYTIC_FUNCTIONS{{,+NULL_HANDLING_MODIFIER_IN_ANALYTIC|}}]
select percentile_{{cont|disc}}(key, 1 respect nulls) over () from keyvalue;
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC,cont
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_cont(DOUBLE, DOUBLE) -> DOUBLE)
                  +-Cast(INT64 -> DOUBLE)
                  | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
                  +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: ,+NULL_HANDLING_MODIFIER_IN_ANALYTIC,disc
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:percentile_disc(INT64, DOUBLE) -> INT64)
                  +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                  +-Literal(type=DOUBLE, value=1)
                  +-null_handling_modifier=RESPECT_NULLS
--
ALTERNATION GROUP: cont
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_cont(key, 1 respect nulls) over () from keyvalue;
       ^
--
ALTERNATION GROUP: disc
--
ERROR: IGNORE NULLS and RESPECT NULLS in analytic functions are not supported [at 1:8]
select percentile_disc(key, 1 respect nulls) over () from keyvalue;
       ^
==

# Second argument cannot be negative DOUBLE.
select percentile_{{cont|disc}}(key, -0.1) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, -0.1) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, -0.1) over () from keyvalue;
                            ^
==

# Second argument cannot be NaN.
select percentile_{{cont|disc}}(key, cast("nan" as double)) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, cast("nan" as double)) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, cast("nan" as double)) over () from keyvalue;
                            ^
==

# Second argument cannot be infinity.
select percentile_{{cont|disc}}(key, cast("inf" as double)) over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:29]
select percentile_cont(key, cast("inf" as double)) over () from keyvalue;
                            ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:29]
select percentile_disc(key, cast("inf" as double)) over () from keyvalue;
                            ^
==

# Second argument cannot be > 1 (NUMERIC type).
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as numeric), numeric "1.000000001") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:46]
select percentile_cont(cast(key as numeric), numeric "1.000000001") over () f...
                                             ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:46]
select percentile_disc(cast(key as numeric), numeric "1.000000001") over () f...
                                             ^

==

# Second argument cannot be negative NUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as numeric), numeric "-1e-9") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:46]
select percentile_cont(cast(key as numeric), numeric "-1e-9") over () from ke...
                                             ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:46]
select percentile_disc(cast(key as numeric), numeric "-1e-9") over () from ke...
                                             ^
==

# Second argument cannot be > 1 (BIGNUMERIC type).
[language_features=NONE,+ANALYTIC_FUNCTIONS,+BIGNUMERIC_TYPE]
select
  percentile_{{cont|disc}}(cast(key as bignumeric),
                           bignumeric "1.00000000000000000000000000000000000001")
  over ()
from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 3:28]
                           bignumeric "1.000000000000000000000000000000000000...
                           ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 3:28]
                           bignumeric "1.000000000000000000000000000000000000...
                           ^

==

# Second argument cannot be negative BIGNUMERIC.
[language_features=NONE,+ANALYTIC_FUNCTIONS,+BIGNUMERIC_TYPE]
select percentile_{{cont|disc}}(cast(key as bignumeric), bignumeric "-1e-38") over () from keyvalue;
--
ALTERNATION GROUP: cont
--
ERROR: Argument 2 to PERCENTILE_CONT must be between 0 and 1 [at 1:49]
select percentile_cont(cast(key as bignumeric), bignumeric "-1e-38") over () ...
                                                ^
--
ALTERNATION GROUP: disc
--
ERROR: Argument 2 to PERCENTILE_DISC must be between 0 and 1 [at 1:49]
select percentile_disc(cast(key as bignumeric), bignumeric "-1e-38") over () ...
                                                ^
==

# IS_FIRST() and IS_LAST(). Both are numbering functions, so they do not accept
# a window frame.
select {{is_first|is_last}}(2)
  over ({{w1|ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING}})
from keyvalue
window w1 as (partition by value order by key ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
--
ALTERNATION GROUP: is_first,w1
--
ERROR: Window framing clause is not allowed for analytic function is_first [at 4:47]
window w1 as (partition by value order by key ROWS BETWEEN 1 PRECEDING AND 1 ...
                                              ^
--
ALTERNATION GROUP: is_first,ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
--
ERROR: Window framing clause is not allowed for analytic function is_first [at 2:9]
  over (ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
        ^
--
ALTERNATION GROUP: is_last,w1
--
ERROR: Window framing clause is not allowed for analytic function is_last [at 4:47]
window w1 as (partition by value order by key ROWS BETWEEN 1 PRECEDING AND 1 ...
                                              ^
--
ALTERNATION GROUP: is_last,ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING
--
ERROR: Window framing clause is not allowed for analytic function is_last [at 2:9]
  over (ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)
        ^
==

# IS_FIRST() and IS_LAST() make order by clause optional.
select is_first(2) OVER(), is_last(2) over ()
from keyvalue
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#5 AS `$col1` [BOOL]
| +-$analytic.$analytic2#6 AS `$col2` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=$analytic.[$analytic1#5, $analytic2#6]
    +-input_scan=
      +-AnalyticScan
        +-column_list=$analytic.[$analytic1#5, $analytic2#6]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#5 :=
              | +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
              |   +-Literal(type=INT64, value=2)
              +-$analytic2#6 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)
==

# IGNORE NULLS and RESPECT NULLS are not allowed for IS_FIRST() and IS_LAST().
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NULL_HANDLING_MODIFIER_IN_ANALYTIC]
select {{is_first|is_last}}(2
                            respect nulls) over () from keyvalue;
--
ALTERNATION GROUP: is_first
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function IS_FIRST [at 1:8]
select is_first(2
       ^
--
ALTERNATION GROUP: is_last
--
ERROR: IGNORE NULLS and RESPECT NULLS are not allowed for analytic function IS_LAST [at 1:8]
select is_last(2
       ^
==

[enabled_ast_rewrites=DEFAULTS,+IS_FIRST_IS_LAST_FUNCTION]
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NULLS_FIRST_LAST_IN_ORDER_BY]
select is_first(2) over (partition by key order by value{{| DESC}}{{| NULLS FIRST| NULLS LAST}})
from keyvalue
--

ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP:  NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-null_order=NULLS_FIRST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-null_order=NULLS_FIRST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP:  NULLS LAST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-null_order=NULLS_LAST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-null_order=NULLS_LAST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP:  DESC,
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP:  DESC, NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                |       +-null_order=NULLS_FIRST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP:  DESC, NULLS LAST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_LAST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                |       +-null_order=NULLS_LAST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
==

[enabled_ast_rewrites=DEFAULTS,+IS_FIRST_IS_LAST_FUNCTION]
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NULLS_FIRST_LAST_IN_ORDER_BY]
select is_last(2) over (partition by key order by value{{| DESC}}{{| NULLS FIRST| NULLS LAST}})
from keyvalue
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
--
ALTERNATION GROUP:  NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-null_order=NULLS_FIRST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-null_order=NULLS_FIRST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
--
ALTERNATION GROUP:  NULLS LAST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-null_order=NULLS_LAST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-null_order=NULLS_LAST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
--
ALTERNATION GROUP:  DESC,
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
--
ALTERNATION GROUP:  DESC, NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_FIRST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                |       +-null_order=NULLS_FIRST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
--
ALTERNATION GROUP:  DESC, NULLS LAST
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-is_descending=TRUE
            |       +-null_order=NULLS_LAST
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-FunctionCall(ZetaSQL:error(STRING) -> BOOL)
        |     | +-Literal(type=STRING, value="k cannot be null or negative")
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                |       +-is_descending=TRUE
                |       +-null_order=NULLS_LAST
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Test the rewrite with SAFE - Note that the ERROR() call is replaced by a NULL
# literal.
[language_features=NONE,+ANALYTIC_FUNCTIONS,+NULLS_FIRST_LAST_IN_ORDER_BY,+SAFE_FUNCTION_CALL]
[enabled_ast_rewrites=DEFAULTS,+IS_FIRST_IS_LAST_FUNCTION]
select SAFE.{{is_first|is_last}}(2) over (partition by key order by value)
from keyvalue
--
ALTERNATION GROUP: is_first
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall({SAFE_ERROR_MODE} ZetaSQL:is_first(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-Literal(type=BOOL, value=NULL)
        |     +-FunctionCall(ZetaSQL:$less_or_equal(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
--
ALTERNATION GROUP: is_last
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-partition_by=
            | +-WindowPartitioning
            |   +-partition_by_list=
            |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-order_by=
            | +-WindowOrdering
            |   +-order_by_item_list=
            |     +-OrderByItem
            |       +-column_ref=
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall({SAFE_ERROR_MODE} ZetaSQL:is_last(INT64) -> BOOL)
                  +-Literal(type=INT64, value=2)

[REWRITTEN AST]
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-ProjectScan
        +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
        +-expr_list=
        | +-$analytic1#4 :=
        |   +-FunctionCall(ZetaSQL:if(BOOL, BOOL, BOOL) -> BOOL)
        |     +-FunctionCall(ZetaSQL:$or(repeated(2) BOOL) -> BOOL)
        |     | +-FunctionCall(ZetaSQL:$is_null(INT64) -> BOOL)
        |     | | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     | +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
        |     |   +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |     |   +-Literal(type=INT64, value=0)
        |     +-Literal(type=BOOL, value=NULL)
        |     +-FunctionCall(ZetaSQL:$greater(INT64, UINT64) -> BOOL)
        |       +-FunctionCall(ZetaSQL:$add(repeated(2) INT64) -> INT64)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic1#6)
        |       | +-ColumnRef(type=INT64, column=$analytic.$analytic_arg#5)
        |       +-ColumnRef(type=UINT64, column=$analytic.$analytic1#7)
        +-input_scan=
          +-AnalyticScan
            +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#6, $analytic.$analytic1#7, $analytic.$analytic_arg#5]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic_arg#5]
            |   +-expr_list=
            |   | +-$analytic_arg#5 := Literal(type=INT64, value=2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-function_group_list=
              +-AnalyticFunctionGroup
                +-partition_by=
                | +-WindowPartitioning
                |   +-partition_by_list=
                |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
                +-order_by=
                | +-WindowOrdering
                |   +-order_by_item_list=
                |     +-OrderByItem
                |       +-column_ref=
                |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
                +-analytic_function_list=
                  +-$analytic1#6 := AnalyticFunctionCall(ZetaSQL:row_number() -> INT64)
                  +-$analytic1#7 :=
                    +-AnalyticFunctionCall(ZetaSQL:$count_star() -> INT64)
                      +-window_frame=
                        +-WindowFrame(frame_unit=ROWS)
                          +-start_expr=
                          | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
                          +-end_expr=
                            +-WindowFrameExpr(boundary_type=UNBOUNDED FOLLOWING)
==

# Arg must be a constant.
select {{is_first|is_last}}(key) over () from keyvalue;
--
ALTERNATION GROUP: is_first
--
ERROR: The argument to IS_FIRST must be a literal or query parameter [at 1:17]
select is_first(key) over () from keyvalue;
                ^
--
ALTERNATION GROUP: is_last
--
ERROR: The argument to IS_LAST must be a literal or query parameter [at 1:16]
select is_last(key) over () from keyvalue;
               ^
==

# Parameter arg
select {{is_first|is_last}}(@test_param_int64) over () from keyvalue;
--

ALTERNATION GROUP: is_first
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Parameter(type=INT64, name="test_param_int64")
--
ALTERNATION GROUP: is_last
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Parameter(type=INT64, name="test_param_int64")
==

# Parameter arg with coercion.
select {{is_first|is_last}}(@test_param_int32) over () from keyvalue;
--
ALTERNATION GROUP: is_first
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_first(INT64) -> BOOL)
                  +-Cast(INT32 -> INT64)
                    +-Parameter(type=INT32, name="test_param_int32")
--
ALTERNATION GROUP: is_last
--
QueryStmt
+-output_column_list=
| +-$analytic.$analytic1#4 AS `$col1` [BOOL]
+-query=
  +-ProjectScan
    +-column_list=[$analytic.$analytic1#4]
    +-input_scan=
      +-AnalyticScan
        +-column_list=[$analytic.$analytic1#4]
        +-input_scan=
        | +-TableScan(table=KeyValue)
        +-function_group_list=
          +-AnalyticFunctionGroup
            +-analytic_function_list=
              +-$analytic1#4 :=
                +-AnalyticFunctionCall(ZetaSQL:is_last(INT64) -> BOOL)
                  +-Cast(INT32 -> INT64)
                    +-Parameter(type=INT32, name="test_param_int32")
