[default language_features=MAXIMUM,+ANALYTIC_FUNCTIONS,+AGGREGATE_FILTERING,+MULTILEVEL_AGGREGATION,+GROUPING_BUILTIN,+QUALIFY,+GROUP_BY_STRUCT,+ORDER_BY_IN_AGGREGATE]
[default show_sqlbuilder_output]
[default enabled_ast_rewrites=ALL,-WITH_EXPR]

# Error if WHERE contains an aggregate or analytic function.
SELECT
  SUM(int64 WHERE SUM(int64) {{ OVER ()|}} > 0){{ OVER ()|}}
FROM SimpleTypes;
--
ALTERNATION GROUP:  OVER (), OVER ()
--
ERROR: Analytic function not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  OVER () > 0) OVER ()
                  ^
--
ALTERNATION GROUP:  OVER (),
--
ERROR: Analytic function not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  OVER () > 0)
                  ^
--
ALTERNATION GROUP:  OVER ()
--
ERROR: Aggregate function SUM not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  > 0) OVER ()
                  ^
--
ALTERNATION GROUP: <empty>
--
ERROR: Aggregate function SUM not allowed in WHERE modifier [at 3:19]
  SUM(int64 WHERE SUM(int64)  > 0)
                  ^
==

# Error if WHERE is in scalar function calls.
SELECT
  {{CONCAT('a', 'b' WHERE bool IS NOT NULL)|POWER(int64, 2 WHERE bool IS NOT NULL)}}
FROM SimpleTypes;
--

ALTERNATION GROUP: CONCAT('a', 'b' WHERE bool IS NOT NULL)
--
ERROR: WHERE in arguments is not supported on scalar functions [at 2:19]
  CONCAT('a', 'b' WHERE bool IS NOT NULL)
                  ^
--
ALTERNATION GROUP: POWER(int64, 2 WHERE bool IS NOT NULL)
--
ERROR: WHERE in arguments is not supported on scalar functions [at 2:18]
  POWER(int64, 2 WHERE bool IS NOT NULL)
                 ^
==

# Error if WHERE is not a boolean expression.
SELECT
  SUM(int64 WHERE {{int64 + 1|CONCAT('a', 'b')}}){{ OVER ()|}}
FROM SimpleTypes;
--

ALTERNATION GROUP: int64 + 1, OVER ()
--
ERROR: WHERE modifier should return type BOOL, but returns INT64 [at 2:19]
  SUM(int64 WHERE int64 + 1) OVER ()
                  ^
--
ALTERNATION GROUP: int64 + 1,
--
ERROR: WHERE modifier should return type BOOL, but returns INT64 [at 2:19]
  SUM(int64 WHERE int64 + 1)
                  ^
--
ALTERNATION GROUP: CONCAT('a', 'b'), OVER ()
--
ERROR: WHERE modifier should return type BOOL, but returns STRING [at 2:19]
  SUM(int64 WHERE CONCAT('a', 'b')) OVER ()
                  ^
--
ALTERNATION GROUP: CONCAT('a', 'b'),
--
ERROR: WHERE modifier should return type BOOL, but returns STRING [at 2:19]
  SUM(int64 WHERE CONCAT('a', 'b'))
                  ^
==

# Error if WHERE modifier in an analytic function references a column that is
# not grouped.
SELECT
  SUM(doubly_nested_struct.f.c
      WHERE doubly_nested_struct.e = 1) OVER ()
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f;
--
ERROR: WHERE modifier expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 3:13]
      WHERE doubly_nested_struct.e = 1) OVER ()
            ^
==

# Similar to the above, but testing the QUALIFY clause.
SELECT
  SUM(doubly_nested_struct.e)
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f
QUALIFY COUNT(doubly_nested_struct.f WHERE doubly_nested_struct.e = 1) OVER() > 100;
--
ERROR: WHERE modifier expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 5:44]
QUALIFY COUNT(doubly_nested_struct.f WHERE doubly_nested_struct.e = 1) OVER()...
                                           ^
==

# Error without AGGREGATE_FILTERING language feature.
[language_features=NONE,+ANALYTIC_FUNCTIONS]
SELECT
  SUM(int64 WHERE bool IS NOT NULL){{ OVER ()|}}
FROM SimpleTypes;
--

ALTERNATION GROUP:  OVER ()
--
ERROR: WHERE modifier is not supported in function calls [at 2:13]
  SUM(int64 WHERE bool IS NOT NULL) OVER ()
            ^
--
ALTERNATION GROUP: <empty>
--
ERROR: WHERE modifier is not supported in function calls [at 2:13]
  SUM(int64 WHERE bool IS NOT NULL)
            ^
==

# Error with HAVING without AGGREGATE_FILTERING language feature.
[language_features=NONE,+MULTILEVEL_AGGREGATION]
SELECT
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING bool is not null)
FROM SimpleTypes;
--

ERROR: HAVING modifier is not supported in function calls [at 2:39]
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING bool is not null)
                                      ^
==

# Error if HAVING is in scalar function calls. Should fail on GROUP BY.
SELECT
  {{CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)|POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1}}
FROM SimpleTypes;
--

ALTERNATION GROUP: CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)
--
ERROR: GROUP BY in arguments is not supported on scalar functions [at 2:19]
  CONCAT('a', 'b' GROUP BY int64 HAVING COUNT(*) > 1)
                  ^
--
ALTERNATION GROUP: POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1
--
ERROR: GROUP BY in arguments is not supported on scalar functions [at 2:18]
  POWER(int64, 2 GROUP BY int64 HAVING SUM(int64)) > 1
                 ^
==

# Error if HAVING is used without GROUP BY.
SELECT
  SUM(int64 HAVING bool is not null)
FROM SimpleTypes;
--

ERROR: Syntax error: Expected keyword MAX or keyword MIN but got identifier "bool" [at 2:20]
  SUM(int64 HAVING bool is not null)
                   ^
==

# Error if HAVING is not a boolean expression.
SELECT
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING ANY_VALUE(int64) + 1)
FROM SimpleTypes;
--

ERROR: HAVING modifier should return type BOOL, but returns INT64 [at 2:46]
  SUM(ANY_VALUE(int64) GROUP BY int32 HAVING ANY_VALUE(int64) + 1)
                                             ^
==

# Error if HAVING references a column that is not aggregated or grouped.
SELECT
  SUM(ANY_VALUE(double) GROUP BY int32 HAVING bool IS NOT NULL)
FROM SimpleTypes
GROUP BY int64;
--


ERROR: multi-level aggregate expression references column bool which is neither grouped nor aggregated [at 2:47]
  SUM(ANY_VALUE(double) GROUP BY int32 HAVING bool IS NOT NULL)
                                              ^
==

# Error if HAVING modifier references a nested column that is not grouped.
SELECT
  SUM(doubly_nested_struct.f.c GROUP BY doubly_nested_struct.f.d.b HAVING doubly_nested_struct.e > 1)
FROM DoublyNestedStructTable
GROUP BY doubly_nested_struct.f;
--
ERROR: multi-level aggregate expression references doubly_nested_struct.e which is neither grouped nor aggregated [at 2:75]
...f.c GROUP BY doubly_nested_struct.f.d.b HAVING doubly_nested_struct.e > 1)
                                                  ^
==

# GROUPING function disallowed in HAVING modifier.
SELECT
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1{{ ORDER BY string|}})
FROM SimpleTypes
GROUP BY int64
--

ALTERNATION GROUP:  ORDER BY string
--
ERROR: GROUPING function not allowed in HAVING modifier of a multi-level aggregate. [at 2:52]
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1 ORDER ...
                                                   ^
--
ALTERNATION GROUP: <empty>
--
ERROR: GROUPING function not allowed in HAVING modifier of a multi-level aggregate. [at 2:52]
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING GROUPING(int64) = 1)
                                                   ^
==

# GROUPING function disallowed in ORDER BY modifier.
SELECT
  ARRAY_AGG(DISTINCT string GROUP BY string HAVING COUNT(*) > 1 ORDER BY GROUPING(string))
FROM SimpleTypes
GROUP BY int64
--

ERROR: GROUPING function not allowed in ORDER BY modifier of a multi-level aggregate. [at 2:65]
...DISTINCT string GROUP BY string HAVING COUNT(*) > 1 ORDER BY GROUPING(stri...
                                                       ^
==


# Both the HAVING filter modifier and GROUP BY modifiers are disallowed on
# analytic functions (even aggregate analytic functions). Since GROUP BY
# modifiers are checked first, the error message mentions GROUP BY.
SELECT
  SUM(MAX(int64) GROUP BY string HAVING COUNT(bool) > 1) OVER()
FROM SimpleTypes
--
ERROR: GROUP BY modifiers not supported on analytic function calls. [at 2:3]
  SUM(MAX(int64) GROUP BY string HAVING COUNT(bool) > 1) OVER()
  ^
==

# PIVOT rewriter does not support WHERE in aggregate functions.
SELECT *
FROM MultipleColumns
PIVOT(COUNT(* WHERE int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
--
[PRE-REWRITE AST]
QueryStmt
+-output_column_list=
| +-$groupby.string_a#8 AS string_a [STRING]
| +-$groupby.string_b#9 AS string_b [STRING]
| +-$groupby.int_c#10 AS int_c [INT64]
| +-$groupby.int_d#11 AS int_d [INT64]
| +-$pivot.zero#12 AS zero [INT64]
| +-$pivot.one#13 AS one [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$groupby.string_a#8, $groupby.string_b#9, $groupby.int_c#10, $groupby.int_d#11, $pivot.zero#12, $pivot.one#13]
    +-input_scan=
      +-PivotScan
        +-column_list=[$groupby.string_a#8, $groupby.string_b#9, $groupby.int_c#10, $groupby.int_d#11, $pivot.zero#12, $pivot.one#13]
        +-input_scan=
        | +-TableScan(column_list=MultipleColumns.[int_a#1, string_a#2, int_b#3, string_b#4, int_c#5, int_d#6], table=MultipleColumns, column_index_list=[0, 1, 2, 3, 4, 5])
        +-group_by_list=
        | +-string_a#8 := ColumnRef(type=STRING, column=MultipleColumns.string_a#2)
        | +-string_b#9 := ColumnRef(type=STRING, column=MultipleColumns.string_b#4)
        | +-int_c#10 := ColumnRef(type=INT64, column=MultipleColumns.int_c#5)
        | +-int_d#11 := ColumnRef(type=INT64, column=MultipleColumns.int_d#6)
        +-pivot_expr_list=
        | +-AggregateFunctionCall(ZetaSQL:$count_star() -> INT64)
        |   +-parse_location=36-60
        |   +-where_expr=
        |     +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
        |       +-ColumnRef(type=INT64, column=MultipleColumns.int_b#3)
        |       +-Literal(type=INT64, value=5)
        +-for_expr=
        | +-ColumnRef(parse_location=65-70, type=INT64, column=MultipleColumns.int_a#1)
        +-pivot_value_list=
        | +-Literal(type=INT64, value=0)
        | +-Literal(type=INT64, value=1)
        +-pivot_column_list=
          +-PivotColumn(column=$pivot.zero#12, pivot_expr_index=0, pivot_value_index=0)
          +-PivotColumn(column=$pivot.one#13, pivot_expr_index=0, pivot_value_index=1)

[SQLBUILDER_TARGET_SYNTAX_MODE standard]
[SQLBUILDER_OUTPUT]
SELECT
  a_2 AS string_a,
  a_4 AS string_b,
  a_5 AS int_c,
  a_6 AS int_d,
  a_8_a_9 AS zero,
  a_8_a_10 AS one
FROM
  (
    SELECT
      MultipleColumns.int_a AS a_1,
      MultipleColumns.string_a AS a_2,
      MultipleColumns.int_b AS a_3,
      MultipleColumns.string_b AS a_4,
      MultipleColumns.int_c AS a_5,
      MultipleColumns.int_d AS a_6
    FROM
      MultipleColumns
  ) AS multiplecolumns_7 PIVOT(COUNT(*
    WHERE
      (multiplecolumns_7.a_3) > 5) AS a_8 FOR(multiplecolumns_7.a_1) IN (0 AS a_9, 1 AS a_10));

[SQLBUILDER_TARGET_SYNTAX_MODE pipe]
[SQLBUILDER_OUTPUT]
FROM
  MultipleColumns
|> SELECT
     MultipleColumns.int_a AS a_1,
     MultipleColumns.string_a AS a_2,
     MultipleColumns.int_b AS a_3,
     MultipleColumns.string_b AS a_4,
     MultipleColumns.int_c AS a_5,
     MultipleColumns.int_d AS a_6
|> AS multiplecolumns_7
|> PIVOT(COUNT(*
     WHERE
       (multiplecolumns_7.a_3) > 5) AS a_8 FOR(multiplecolumns_7.a_1) IN (0 AS a_9, 1 AS a_10))
|> SELECT
     a_2 AS string_a,
     a_4 AS string_b,
     a_5 AS int_c,
     a_6 AS int_d,
     a_8_a_9 AS zero,
     a_8_a_10 AS one;

Rewrite ERROR: generic::unimplemented: Use of WHERE filter inside an aggregate function used as a PIVOT expression is not supported [at 3:7]
PIVOT(COUNT(* WHERE int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
      ^
==

# PIVOT rewriter does not support HAVING in aggregate functions. The error
# mentions GROUP BY because it checks for GROUP BY first, which is also not
# supported in the PIVOT rewriter.
SELECT *
FROM MultipleColumns
PIVOT(COUNT(* GROUP BY int_b HAVING int_b > 5) FOR int_a IN (0 AS zero, 1 AS one));
--
ERROR: PIVOT expression cannot be a multi-level aggregate function call [at 3:7]
PIVOT(COUNT(* GROUP BY int_b HAVING int_b > 5) FOR int_a IN (0 AS zero, 1 AS ...
      ^
