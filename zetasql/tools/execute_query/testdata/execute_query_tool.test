SELECT 1 x
--
+---+
| x |
+---+
| 1 |
+---+
\
==

[mode={{bad||parse|analyze|execute|explain|unparse|unanalyze|parse,analyze}}]
select 1 x
--
ALTERNATION GROUP: bad
--
ERROR: INVALID_ARGUMENT: Invalid --mode: 'bad'
--
ALTERNATION GROUP: <empty>
--
ERROR: INVALID_ARGUMENT: Invalid --mode: ''
--
ALTERNATION GROUP: parse
--
QueryStatement [0-10]
  Query [0-10]
    Select [0-10]
      SelectList [7-10]
        SelectColumn [7-10]
          IntLiteral(1) [7-8]
          Alias [9-10]
            Identifier(x) [9-10]
\
--
ALTERNATION GROUP: analyze
--
QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: execute
--
+---+
| x |
+---+
| 1 |
+---+
\
--
ALTERNATION GROUP: explain
--
ComputeOp(
+-map: {
| +-$x := ConstExpr(1)},
+-input: EnumerateOp(ConstExpr(1)))
\
--
ALTERNATION GROUP: unparse
--
SELECT
  1 AS x
\
--
ALTERNATION GROUP: unanalyze
--
SELECT
  1 AS x;
\
--
ALTERNATION GROUP: parse,analyze
--
QueryStatement [0-10]
  Query [0-10]
    Select [0-10]
      SelectList [7-10]
        SelectColumn [7-10]
          IntLiteral(1) [7-8]
          Alias [9-10]
            Identifier(x) [9-10]

QueryStmt
+-output_column_list=
| +-$query.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan
\
==

# Make sure ExplainAndOrExecuteSql runs just once, so we get one output
# for each of the two modes.
[mode=explain,execute]
select 1 x, 2 y
--
ComputeOp(
+-map: {
| +-$x := ConstExpr(1),
| +-$y := ConstExpr(2)},
+-input: EnumerateOp(ConstExpr(1)))

+---+---+
| x | y |
+---+---+
| 1 | 2 |
+---+---+
\
==

# Unused column Key gets pruned.
[mode=analyze,unanalyze]
FROM KeyValue
|> SELECT value
--
QueryStmt
+-output_column_list=
| +-KeyValue.Value#2 AS value [STRING]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Value#2]
    +-input_scan=
      +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])

SELECT
  KeyValue.Value AS value
FROM
  KeyValue;
\
==

# Unused column Key gets pruned.
[mode=analyze,unanalyze]
select 1 from KeyValue GROUP BY key, key+1
--
QueryStmt
+-output_column_list=
| +-$query.$col1#5 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#5]
    +-expr_list=
    | +-$col1#5 := Literal(type=INT64, value=1)
    +-input_scan=
      +-AggregateScan
        +-input_scan=
        | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
        +-group_by_list=
          +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
          +-$groupbycol2#4 :=
            +-FunctionCall(ZetaSQL:$add(INT64, INT64) -> INT64)
              +-ColumnRef(type=INT64, column=KeyValue.Key#1)
              +-Literal(type=INT64, value=1)

SELECT
  1 AS a_4
FROM
  (
    SELECT
      NULL
    FROM
      (
        SELECT
          KeyValue.Key AS a_1
        FROM
          KeyValue
      ) AS keyvalue_2
    GROUP BY keyvalue_2.a_1, (keyvalue_2.a_1) + 1
  ) AS aggregatescan_3;
\
==
COMMIT
--
ERROR: INVALID_ARGUMENT: The statement CommitStmt is not supported for execution.
==

DESCRIBE bad_table
--
ERROR: INVALID_ARGUMENT: Object not found
==

DESCRIBE TaBlE bad_table
--
ERROR: NOT_FOUND: Table not found: bad_table not found in catalog<space removed>
==

[mode={{analyze|explain|execute}}]
DESCRIBE TABLE Keyvalue
--
ALTERNATION GROUP: analyze
--
DescribeStmt(object_type="TABLE", name_path=Keyvalue)
\
--
ALTERNATION GROUP: explain
--
ERROR: INVALID_ARGUMENT: The statement DescribeStmt is not supported for explanation.
--
ALTERNATION GROUP: execute
--
Table: KeyValue
Columns:
  Key   INT64
  Value STRING
\
==

[mode={{analyze|explain|execute}}]
EXPLAIN DESCRIBE TABLE Keyvalue
--
ALTERNATION GROUP: analyze
--
ExplainStmt
+-statement=
  +-DescribeStmt(object_type="TABLE", name_path=Keyvalue)
\
--
ALTERNATION GROUP: explain
--
ERROR: INVALID_ARGUMENT: The statement ExplainStmt is not supported for explanation.
--
ALTERNATION GROUP: execute
--
ERROR: INVALID_ARGUMENT: The statement ExplainStmt is not supported for execution.
==

DESCRIBE KeyValue
--
Table: KeyValue
Columns:
  Key   INT64
  Value STRING
\
==

[catalog={{none|bad||sample}}]
DESCRIBE KeyValue
--
ALTERNATION GROUP: none
--
ERROR: INVALID_ARGUMENT: Object not found
--
ALTERNATION GROUP: bad
--
ERROR: INVALID_ARGUMENT: Catalog not found: bad
--
ALTERNATION GROUP: <empty>
--
ERROR: INVALID_ARGUMENT: Catalog not found:<space removed>
--
ALTERNATION GROUP: sample
--
Table: KeyValue
Columns:
  Key   INT64
  Value STRING
\
==

DESCRIBE {{|taBLE}} TestExtraValueTable
--
Table: TestExtraValueTable (value table)
Row type: zetasql_test__.TestExtraPB
Columns:
  Filename STRING (pseudo-column)
  RowId    BYTES (pseudo-column)
\
==

DESCRIBE nested_catalog.NestedKeyValue
--
Table: KeyValue
Columns:
  Key   INT64
  Value STRING
\
==

DESCRIBE {{|fUNCtion}} bad_function
--
ALTERNATION GROUP: <empty>
--
ERROR: INVALID_ARGUMENT: Object not found
--
ALTERNATION GROUP: fUNCtion
--
ERROR: NOT_FOUND: Function not found: bad_function not found in catalog<space removed>
==

DESCRIBE {{|fUNCtion}} sqrt
--
Function SQRT
Signature: SQRT(DOUBLE) -> DOUBLE
Signature: SQRT(NUMERIC) -> NUMERIC
Signature: SQRT(BIGNUMERIC) -> BIGNUMERIC
\
==

DESCRIBE {{|fUNCtion}} conCAT
--
Function CONCAT
Signature: CONCAT(STRING, [STRING, ...]) -> STRING
Signature: CONCAT(BYTES, [BYTES, ...]) -> BYTES
\
==

DESCRIBE array_transform
--
Function ARRAY_TRANSFORM
Signature: ARRAY_TRANSFORM(ARRAY<T1>, FUNCTION<T1->T2>) -> ARRAY<T2>
Signature: ARRAY_TRANSFORM(ARRAY<T1>, FUNCTION<(T1, INT64)->T2>) -> ARRAY<T2>
\
==

DESCRIBE rank
--
Analytic function RANK
Signature: RANK() -> INT64
\
==

[catalog={{none|sample}}]
DESCRIBE sum
--
Aggregate function SUM
Signature: SUM(INT64) -> INT64
Signature: SUM(UINT64) -> UINT64
Signature: SUM(DOUBLE) -> DOUBLE
Signature: SUM(NUMERIC) -> NUMERIC
Signature: SUM(BIGNUMERIC) -> BIGNUMERIC
Signature: SUM(INTERVAL) -> INTERVAL
\
==

DESCRIBE {{|tVf}} bad_tvf
--
ALTERNATION GROUP: <empty>
--
ERROR: INVALID_ARGUMENT: Object not found
--
ALTERNATION GROUP: tVf
--
ERROR: NOT_FOUND: Table function not found: bad_tvf not found in catalog<space removed>
==

describe {{|tvf}} nested_catalog.nested_tvf_one
--
Table-valued function: NESTED_CATALOG.NESTED_TVF_ONE(TABLE<key INT64>) -> TABLE<key INT64>
\
==

describe tvf_optional_named_default_args
--
Table-valued function: TVF_OPTIONAL_NAMED_DEFAULT_ARGS(relation => TABLE, r1 => BOOL, [o0 => STRING], [o1 => DOUBLE], [o2 => UINT32]) -> TABLE
\
==

describe tvf_one_relation_arg_with_fixed_output
--
Table-valued function: TVF_ONE_RELATION_ARG_WITH_FIXED_OUTPUT(TABLE) -> TABLE<column_bool BOOL, column_bytes BYTES>
\
==

describe tvf_no_arg_returning_value_table_with_pseudo_columns
--
Table-valued function: TVF_NO_ARG_RETURNING_VALUE_TABLE_WITH_PSEUDO_COLUMNS() -> TABLE<`zetasql_test__.TestExtraPB`, RowId INT64, PartitionName STRING>
\
==

describe tvf_two_models_with_fixed_output
--
Table-valued function: TVF_TWO_MODELS_WITH_FIXED_OUTPUT(MODEL, MODEL) -> TABLE<label DOUBLE>
\
==

describe tvf_one_relation_arg_output_schema_is_input_schema
--
Table-valued function: TVF_ONE_RELATION_ARG_OUTPUT_SCHEMA_IS_INPUT_SCHEMA(TABLE) -> TABLE
\
==

# Multi-statement script.
[mode={{parse|analyze|execute|parse,execute}}]
select 1;
select 'abc';
select null, null;
--
ALTERNATION GROUP: parse
--
QueryStatement [0-8]
  Query [0-8]
    Select [0-8]
      SelectList [7-8]
        SelectColumn [7-8]
          IntLiteral(1) [7-8]

QueryStatement [10-22]
  Query [10-22]
    Select [10-22]
      SelectList [17-22]
        SelectColumn [17-22]
          StringLiteral [17-22]
            StringLiteralComponent('abc') [17-22]

QueryStatement [24-41]
  Query [24-41]
    Select [24-41]
      SelectList [31-41]
        SelectColumn [31-35]
          NullLiteral(null) [31-35]
        SelectColumn [37-41]
          NullLiteral(null) [37-41]
\
--
ALTERNATION GROUP: analyze
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRING, value="abc")
    +-input_scan=
      +-SingleRowScan

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.$col2#2 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, $col2#2]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=NULL)
    | +-$col2#2 := Literal(type=INT64, value=NULL)
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: execute
--
+---+
|   |
+---+
| 1 |
+---+

+-----+
|     |
+-----+
| abc |
+-----+

+------+------+
|      |      |
+------+------+
| NULL | NULL |
+------+------+
\
--
ALTERNATION GROUP: parse,execute
--
QueryStatement [0-8]
  Query [0-8]
    Select [0-8]
      SelectList [7-8]
        SelectColumn [7-8]
          IntLiteral(1) [7-8]

+---+
|   |
+---+
| 1 |
+---+

QueryStatement [10-22]
  Query [10-22]
    Select [10-22]
      SelectList [17-22]
        SelectColumn [17-22]
          StringLiteral [17-22]
            StringLiteralComponent('abc') [17-22]

+-----+
|     |
+-----+
| abc |
+-----+

QueryStatement [24-41]
  Query [24-41]
    Select [24-41]
      SelectList [31-41]
        SelectColumn [31-35]
          NullLiteral(null) [31-35]
        SelectColumn [37-41]
          NullLiteral(null) [37-41]

+------+------+
|      |      |
+------+------+
| NULL | NULL |
+------+------+
\
==

# Multi-statement script with errors from different phases, with a
# valid query at the end.
# Currently, execution stops after the first error.
# Note that error locations are correct relative to the whole script.
[mode={{parse|analyze|execute|parse,analyze,execute}}]
select error("an execute error");
select an_analyzer_error();
select a parse error;
select 1 AS valid_query
--
ALTERNATION GROUP: parse
--
QueryStatement [0-32]
  Query [0-32]
    Select [0-32]
      SelectList [7-32]
        SelectColumn [7-32]
          FunctionCall [7-32]
            PathExpression [7-12]
              Identifier(error) [7-12]
            StringLiteral [13-31]
              StringLiteralComponent("an execute error") [13-31]

QueryStatement [34-60]
  Query [34-60]
    Select [34-60]
      SelectList [41-60]
        SelectColumn [41-60]
          FunctionCall [41-60]
            PathExpression [41-58]
              Identifier(an_analyzer_error) [41-58]

ERROR: INVALID_ARGUMENT: Syntax error: Expected ";" or end of input but got keyword ERROR [at 3:16]
select a parse error;
               ^
--
ALTERNATION GROUP: analyze
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
    |     +-Literal(type=STRING, value="an execute error")
    +-input_scan=
      +-SingleRowScan

ERROR: INVALID_ARGUMENT: Function not found: an_analyzer_error [at 2:8]
select an_analyzer_error();
       ^
--
ALTERNATION GROUP: execute
--
ERROR: OUT_OF_RANGE: an execute error
--
ALTERNATION GROUP: parse,analyze,execute
--
QueryStatement [0-32]
  Query [0-32]
    Select [0-32]
      SelectList [7-32]
        SelectColumn [7-32]
          FunctionCall [7-32]
            PathExpression [7-12]
              Identifier(error) [7-12]
            StringLiteral [13-31]
              StringLiteralComponent("an execute error") [13-31]

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
    |     +-Literal(type=STRING, value="an execute error")
    +-input_scan=
      +-SingleRowScan

ERROR: OUT_OF_RANGE: an execute error
==

[mode=analyze]
CREATE {{|TEMP}} FUNCTION f(x INT64) AS (sqrt(x)*2);
--
ALTERNATION GROUP: <empty>
--
CreateFunctionStmt
+-name_path=f
+-return_type=DOUBLE
+-argument_name_list=[x]
+-signature=(INT64 x) -> DOUBLE
+-language="SQL"
+-code="sqrt(x)*2"
+-function_expression=
  +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    +-FunctionCall(ZetaSQL:sqrt(DOUBLE) -> DOUBLE)
    | +-Cast(INT64 -> DOUBLE)
    |   +-ArgumentRef(type=INT64, name="x")
    +-Literal(type=DOUBLE, value=2)

Function registered.
--
ALTERNATION GROUP: TEMP
--
CreateFunctionStmt
+-name_path=f
+-create_scope=CREATE_TEMP
+-return_type=DOUBLE
+-argument_name_list=[x]
+-signature=(INT64 x) -> DOUBLE
+-language="SQL"
+-code="sqrt(x)*2"
+-function_expression=
  +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    +-FunctionCall(ZetaSQL:sqrt(DOUBLE) -> DOUBLE)
    | +-Cast(INT64 -> DOUBLE)
    |   +-ArgumentRef(type=INT64, name="x")
    +-Literal(type=DOUBLE, value=2)

Function registered.
==

==
# Script that creates a function and then calls it in the next statement.
[mode={{analyze|execute}}]
CREATE FUNCTION f(x INT64) AS (sqrt(x)*2);
DESCRIBE f;
SELECT f(123);
--
ALTERNATION GROUP: analyze
--
CreateFunctionStmt
+-name_path=f
+-return_type=DOUBLE
+-argument_name_list=[x]
+-signature=(INT64 x) -> DOUBLE
+-language="SQL"
+-code="sqrt(x)*2"
+-function_expression=
  +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    +-FunctionCall(ZetaSQL:sqrt(DOUBLE) -> DOUBLE)
    | +-Cast(INT64 -> DOUBLE)
    |   +-ArgumentRef(type=INT64, name="x")
    +-Literal(type=DOUBLE, value=2)

Function registered.
DescribeStmt(object_type="", name_path=f)

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-SubqueryExpr
    |     +-type=DOUBLE
    |     +-subquery_type=SCALAR
    |     +-subquery=
    |       +-ProjectScan
    |         +-column_list=[$with_expr.injected#3]
    |         +-expr_list=
    |         | +-injected#3 :=
    |         |   +-FunctionCall(ZetaSQL:$multiply(DOUBLE, DOUBLE) -> DOUBLE)
    |         |     +-FunctionCall(ZetaSQL:sqrt(DOUBLE) -> DOUBLE)
    |         |     | +-Cast(INT64 -> DOUBLE)
    |         |     |   +-ColumnRef(type=INT64, column=$inlined_f.x#2)
    |         |     +-Literal(type=DOUBLE, value=2)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$inlined_f.x#2]
    |             +-expr_list=
    |             | +-x#2 := Literal(type=INT64, value=123)
    |             +-input_scan=
    |               +-SingleRowScan
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: execute
--
Function registered.
Function Lazy_resolution_function:f
Signature: f([x=>]INT64) -> DOUBLE

+--------------------+
|                    |
+--------------------+
| 22.181073012818835 |
+--------------------+
\
==

# Statement-at-a-time macro support, i.e. macro invocations have access to
# definitions from statements preceeding them.
[mode={{parse|analyze|execute}}]
DEFINE MACRO foo "foo";
SELECT $foo();
--
ALTERNATION GROUP: parse
--
DefineMacroStatement [0-22]
  Identifier(foo) [13-16]
  MacroBody("foo") [17-22]

Macro registered: foo
QueryStatement [24-37]
  Query [24-37]
    Select [24-37]
      SelectList [31-37]
        SelectColumn [31-37]
          StringLiteral [31-37]
            StringLiteralComponent("foo") [31-37]
\
--
ALTERNATION GROUP: analyze
--
Macro registered: foo
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=STRING, value="foo")
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: execute
--
Macro registered: foo
+-----+
|     |
+-----+
| foo |
+-----+
\
==

# Macros support positional arguments
[mode=execute]
DEFINE MACRO Identity $1;
SELECT $Identity(1);
--
Macro registered: Identity
+---+
|   |
+---+
| 1 |
+---+
\
==

# Implicit token splicing is disallowed
[mode=parse]
DEFINE MACRO MacroA a;
DEFINE MACRO MacroB b;

SELECT $MacroA()$MacroB();
--
DefineMacroStatement [0-21]
  Identifier(MacroA) [13-19]
  MacroBody(a) [20-21]

Macro registered: MacroA
DefineMacroStatement [23-44]
  Identifier(MacroB) [36-42]
  MacroBody(b) [43-44]

Macro registered: MacroB
ERROR: INVALID_ARGUMENT: Splicing tokens (a) and (b) [at 4:17]
SELECT $MacroA()$MacroB();
                ^
==

# Macros can be defined only once
[mode=execute]
DEFINE MACRO m once;
DEFINE MACRO m twice;
--
Macro registered: m
ERROR: ALREADY_EXISTS: Macro m already exists
==

# Macros expand lazily. For example the first macro body references a macro that
# is not known at definition time.
[mode=execute]
DEFINE MACRO foo $bar();
DEFINE MACRO bar "bar";
SELECT $foo();
--
Macro registered: foo
Macro registered: bar
+-----+
|     |
+-----+
| bar |
+-----+
\
==

# Invoking a macro that is not defined is an error.
[mode=execute]
SELECT $UndefinedMacro();
--
ERROR: INVALID_ARGUMENT: Macro 'UndefinedMacro' not found. [at 1:8]
SELECT $UndefinedMacro();
       ^
==

# Extraneous arguments to macro invocations is an error
DEFINE MACRO Identity $1;
SELECT $Identity(1);
SELECT $Identity(1, 2);
--
Macro registered: Identity
+---+
|   |
+---+
| 1 |
+---+

ERROR: INVALID_ARGUMENT: Macro invocation has too many arguments (2) while the definition only references up to 1 arguments [at 3:8]
SELECT $Identity(1, 2);
       ^
==

# All arguments are required, failure to provide them is an error
DEFINE MACRO TakesTwoArgs $1, $2;
SELECT $TakesTwoArgs(1);
--
Macro registered: TakesTwoArgs
ERROR: INVALID_ARGUMENT: Argument index $2 out of range. Invocation was provided only 1 arguments. [at 1:31]
DEFINE MACRO TakesTwoArgs $1, $2;
                              ^
Expanded from macro:TakesTwoArgs [at 2:8]
SELECT $TakesTwoArgs(1);
       ^
==

# Macro invocations must be followed by parentheses
DEFINE MACRO foo "foo";
SELECT $foo;
--
Macro registered: foo
ERROR: INVALID_ARGUMENT: Invocation of macro 'foo' missing argument list. [at 2:12]
SELECT $foo;
           ^
==

# Macros are not expanded within a literal
DEFINE MACRO foo "foo";
SELECT "$foo()bar";
--
Macro registered: foo
+-----------+
|           |
+-----------+
| $foo()bar |
+-----------+
\
==


# Setting a LANGUAGE is required if we don't have a SQL body.
# execute_query just makes a signature for these but can't execute them.
# This is still useful to define functions by writing the full signature.
[mode={{analyze|execute}}]
create function f(x int64) returns double{{| language C}};
DESCRIBE f;
select f(5);
--
ALTERNATION GROUPS:
    analyze,
    execute,
--
ERROR: INVALID_ARGUMENT: Function must specify LANGUAGE or have a SQL body in parentheses [at 1:1]
create function f(x int64) returns double;
^
--
ALTERNATION GROUP: analyze, language C
--
CreateFunctionStmt(name_path=f, has_explicit_return_type=TRUE, return_type=DOUBLE, argument_name_list=[x], signature=(INT64 x) -> DOUBLE, language="C")

Function registered.
DescribeStmt(object_type="", name_path=f)

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(External_function:f(INT64 x) -> DOUBLE)
    |     +-Literal(type=INT64, value=5)
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: execute, language C
--
Function registered.
Function External_function:f
Signature: f([x=>]INT64) -> DOUBLE

ERROR: INVALID_ARGUMENT: User-defined function f has no evaluator. Use FunctionOptions to supply one.
==

create function f(x int64) as (x);
create function f(x int64) as (x+1);
--
Function registered.
ERROR: INVALID_ARGUMENT: Function already exists
==

[mode=analyze]
create {{|TEMP}} table function tvf() as (select 1 x);
--
ALTERNATION GROUP: <empty>
--
CreateTableFunctionStmt
+-name_path=tvf
+-signature=() -> TABLE<x INT64>
+-language="SQL"
+-code="select 1 x"
+-query=
| +-ProjectScan
|   +-column_list=[$query.x#1]
|   +-expr_list=
|   | +-x#1 := Literal(type=INT64, value=1)
|   +-input_scan=
|     +-SingleRowScan
+-output_column_list=
  +-$query.x#1 AS x [INT64]

TVF registered.
--
ALTERNATION GROUP: TEMP
--
CreateTableFunctionStmt
+-name_path=tvf
+-create_scope=CREATE_TEMP
+-signature=() -> TABLE<x INT64>
+-language="SQL"
+-code="select 1 x"
+-query=
| +-ProjectScan
|   +-column_list=[$query.x#1]
|   +-expr_list=
|   | +-x#1 := Literal(type=INT64, value=1)
|   +-input_scan=
|     +-SingleRowScan
+-output_column_list=
  +-$query.x#1 AS x [INT64]

TVF registered.
==

# This test depends on TVFs, which are not supported by the reference
# implementation and execute_query tool, and so it should not execute the query.
# TODO: b/371219410 - Test execution when TVF support is launched.
[mode=analyze]
create table function tvf() as (select 1 x);
select * from tvf() t;
--
CreateTableFunctionStmt
+-name_path=tvf
+-signature=() -> TABLE<x INT64>
+-language="SQL"
+-code="select 1 x"
+-query=
| +-ProjectScan
|   +-column_list=[$query.x#1]
|   +-expr_list=
|   | +-x#1 := Literal(type=INT64, value=1)
|   +-input_scan=
|     +-SingleRowScan
+-output_column_list=
  +-$query.x#1 AS x [INT64]

TVF registered.
QueryStmt
+-output_column_list=
| +-tvf.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf.x#1], tvf=tvf(() -> TABLE<x INT64>), signature=() -> TABLE<x INT64>, column_index_list=[0], alias="t", function_call_signature=() -> TABLE<x INT64>)
\
==

[mode={{analyze|execute}}]
create table function tvf() returns table<x double>;
select * from tvf() t;
--
ALTERNATION GROUP: analyze
--
CreateTableFunctionStmt(name_path=tvf, signature=() -> TABLE<x DOUBLE>, has_explicit_return_schema=TRUE, language="UNDECLARED")

TVF registered.
QueryStmt
+-output_column_list=
| +-tvf.x#1 AS x [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=[tvf.x#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf.x#1], tvf=tvf(() -> TABLE<x DOUBLE>), signature=() -> TABLE<x DOUBLE>, column_index_list=[0], alias="t", function_call_signature=() -> TABLE<x DOUBLE>)
\
--
ALTERNATION GROUP: execute
--
TVF registered.
ERROR: UNIMPLEMENTED: TVF tvf does not support the API in evaluator.h
==

[mode=analyze]
create {{|temp|or replace}} table t1 (
  x int64,
  y double
);
--
ALTERNATION GROUP: <empty>
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=t1.x#1)
  +-ColumnDefinition(name="y", type=DOUBLE, column=t1.y#2)

Table created
--
ALTERNATION GROUP: temp
--
CreateTableStmt
+-name_path=t1
+-create_scope=CREATE_TEMP
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=t1.x#1)
  +-ColumnDefinition(name="y", type=DOUBLE, column=t1.y#2)

Table created
--
ALTERNATION GROUP: or replace
--
CreateTableStmt
+-name_path=t1
+-create_mode=CREATE_OR_REPLACE
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=t1.x#1)
  +-ColumnDefinition(name="y", type=DOUBLE, column=t1.y#2)

Table created or replaced
==

[mode={{analyze|execute}}]
create table t1 (
  x int64,
  y double
);
describe t1;
select * from t1;
create table t1 (z int64);
--
ALTERNATION GROUP: analyze
--
CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=t1.x#1)
  +-ColumnDefinition(name="y", type=DOUBLE, column=t1.y#2)

Table created
DescribeStmt(object_type="", name_path=t1)

QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
| +-t1.y#2 AS y [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=t1.[x#1, y#2]
    +-input_scan=
      +-TableScan(column_list=t1.[x#1, y#2], table=t1, column_index_list=[0, 1])

CreateTableStmt
+-name_path=t1
+-column_definition_list=
  +-ColumnDefinition(name="z", type=INT64, column=t1.z#1)

ERROR: INVALID_ARGUMENT: Table already exists: t1
--
ALTERNATION GROUP: execute
--
Table created
Table: t1
Columns:
  x INT64
  y DOUBLE

+---+---+
| x | y |
+---+---+
+---+---+

ERROR: INVALID_ARGUMENT: Table already exists: t1
==

[mode=analyze]
create {{|temp}} table t1 AS (
  SELECT 123 x
);
--
ALTERNATION GROUP: <empty>
--
CreateTableAsSelectStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=t1.x#2)
+-output_column_list=
| +-$create_as.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$create_as.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=123)
    +-input_scan=
      +-SingleRowScan

Table created
--
ALTERNATION GROUP: temp
--
CreateTableAsSelectStmt
+-name_path=t1
+-create_scope=CREATE_TEMP
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=t1.x#2)
+-output_column_list=
| +-$create_as.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$create_as.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=123)
    +-input_scan=
      +-SingleRowScan

Table created
==

# We can analyze CTAS to get the output schema and execute it in execute mode.
[mode={{analyze|execute}}]
create table t1 AS (
  SELECT 123 x
);
select * from t1;
create table t1 as (select 1 z);
--
ALTERNATION GROUP: analyze
--
CreateTableAsSelectStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="x", type=INT64, column=t1.x#2)
+-output_column_list=
| +-$create_as.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$create_as.x#1]
    +-expr_list=
    | +-x#1 := Literal(type=INT64, value=123)
    +-input_scan=
      +-SingleRowScan

Table created
QueryStmt
+-output_column_list=
| +-t1.x#1 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=[t1.x#1]
    +-input_scan=
      +-TableScan(column_list=[t1.x#1], table=t1, column_index_list=[0])

CreateTableAsSelectStmt
+-name_path=t1
+-column_definition_list=
| +-ColumnDefinition(name="z", type=INT64, column=t1.z#2)
+-output_column_list=
| +-$create_as.z#1 AS z [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$create_as.z#1]
    +-expr_list=
    | +-z#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan

ERROR: INVALID_ARGUMENT: Table already exists: t1
--
ALTERNATION GROUP: execute
--
Table created
+-----+
| x   |
+-----+
| 123 |
+-----+

Error: Table already exists: t1
==

# Create table is rejected if it the statement has unhandled syntax.
[mode={{analyze|execute}}]
create table t (x int64)
OPTIONS (bad_option=123)
--
ALTERNATION GROUP: analyze
--
CreateTableStmt
+-name_path=t
+-option_list=
| +-bad_option := Literal(type=INT64, value=123)
+-column_definition_list=
  +-ColumnDefinition(name="x", type=INT64, column=t.x#1)

Table created
--
ALTERNATION GROUP: execute
--
Table created
==

# The catalog allows multiple objects of different types with the
# same name.  DESCRIBE can show all of them, or distinguish.
# The weird Lazy_resolution_function: prefix comes from a TODO in sql_function.cc.
[mode=execute]
create function multi() AS (5);
create table function multi() AS (select 1 x);
create table multi (y int64);
DESCRIBE multi;
DESCRIBE table multi;
DESCRIBE TVF multi;
SELECT * FROM multi;   # The table.
# This test depends on TVFs, which are not supported by the reference
# implementation and execute_query tool, and so the query which references a TVF
# produces an error when executed.
SELECT * FROM multi(); # The TVF.
--
Function registered.
TVF registered.
Table created
Table: multi
Columns:
  y INT64

Function Lazy_resolution_function:multi
Signature: multi() -> INT64

Table-valued function: MULTI() -> TABLE<x INT64>

Table: multi
Columns:
  y INT64

Table-valued function: MULTI() -> TABLE<x INT64>

+---+
| y |
+---+
+---+

+---+
| x |
+---+
| 1 |
+---+
\
==

# This case with stacked DDL objects that trigger rewriters exercises code that
# keeps parser and analyzer state objects alive. It crashed without that.
# This test depends on TVFs, which are not supported by the reference
# implementation and execute_query tool, and so it should not execute the query.
# TODO: b/371219410 - Test execution when TVF support is launched.
[mode=analyze]
create table t (y int64);
create table function tvf() AS (select 5 mm from t, unnest([1,2]) uu);
SELECT * FROM tvf();
--
CreateTableStmt
+-name_path=t
+-column_definition_list=
  +-ColumnDefinition(name="y", type=INT64, column=t.y#1)

Table created
CreateTableFunctionStmt
+-name_path=tvf
+-signature=() -> TABLE<mm INT64>
+-language="SQL"
+-code="select 5 mm from t, unnest([1,2]) uu"
+-query=
| +-ProjectScan
|   +-column_list=[$query.mm#3]
|   +-expr_list=
|   | +-mm#3 := Literal(type=INT64, value=5)
|   +-input_scan=
|     +-ArrayScan
|       +-input_scan=
|       | +-TableScan(table=t)
|       +-array_expr_list=
|       | +-Literal(type=ARRAY<INT64>, value=[1, 2])
|       +-element_column_list=[$array.uu#2]
+-output_column_list=
  +-$query.mm#3 AS mm [INT64]

TVF registered.
QueryStmt
+-output_column_list=
| +-tvf.mm#1 AS mm [INT64]
+-query=
  +-ProjectScan
    +-column_list=[tvf.mm#1]
    +-input_scan=
      +-TVFScan(column_list=[tvf.mm#1], tvf=tvf(() -> TABLE<mm INT64>), signature=() -> TABLE<mm INT64>, column_index_list=[0], function_call_signature=() -> TABLE<mm INT64>)
\
==

[mode=analyze,execute]
insert into KeyValue values (null, null)
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-ProjectScan
|   +-column_list=KeyValue.[$col#3, $col#4]
|   +-expr_list=
|   | +-$col#3 := Literal(type=INT64, value=NULL)
|   | +-$col#4 := Literal(type=STRING, value=NULL)
|   +-input_scan=
|     +-SingleRowScan
+-query_output_column_list=KeyValue.[$col#3, $col#4]
+-column_access_list=WRITE,WRITE

Error: DML statements can only be applied to temporary tables created in the current session
==

[mode=analyze,execute]
insert into KeyValue
select * from KeyValue where value is not null
--
InsertStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-insert_column_list=KeyValue.[Key#1, Value#2]
+-query=
| +-ProjectScan
|   +-column_list=KeyValue.[Key#3, Value#4]
|   +-input_scan=
|     +-FilterScan
|       +-column_list=KeyValue.[Key#3, Value#4]
|       +-input_scan=
|       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1])
|       +-filter_expr=
|         +-FunctionCall(ZetaSQL:$not(BOOL) -> BOOL)
|           +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
|             +-ColumnRef(type=STRING, column=KeyValue.Value#4)
+-query_output_column_list=KeyValue.[Key#3, Value#4]
+-column_access_list=WRITE,WRITE

Error: DML statements can only be applied to temporary tables created in the current session
==

[mode=analyze,execute]
delete from KeyValue
where value is null
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(ZetaSQL:$is_null(STRING) -> BOOL)
    +-ColumnRef(type=STRING, column=KeyValue.Value#2)

Error: Only INSERT statements are supported in multi-statement queries
==

# An empty statement is not allowed.
--
ERROR: INVALID_ARGUMENT: Syntax error: Unexpected end of statement [at 1:1]

^
==

# A statement that is just a comment is not allowed.
/* comment */
--
ERROR: INVALID_ARGUMENT: Syntax error: Unexpected end of statement [at 1:14]
/* comment */
             ^
==

# A statement that is just a semicolon is not allowed.
;
--
ERROR: INVALID_ARGUMENT: Syntax error: Unexpected ";" [at 1:1]
;
^
==

# Empty statements from double-semicolons are not allowed.
select 1;;
select 2;
--
+---+
|   |
+---+
| 1 |
+---+

ERROR: INVALID_ARGUMENT: Syntax error: Unexpected ";" [at 1:10]
select 1;;
         ^
==

# Trailing comments are allowed.
/* comment */
select 1;
/* comment */
--
+---+
|   |
+---+
| 1 |
+---+
\

==

SHOW bad_object
--
ERROR: INVALID_ARGUMENT: Unsupported object type: bad_object
==

[catalog=tpch]
SHOW TABLES
--
Customer
LineItem
Nation
Orders
Part
PartSupp
Region
Supplier
==

[catalog=tpch]
SHOW TABLES LIKE 'rEgIoN'
--
Region
==

[catalog=tpch]
SHOW tables like 'pArT%'
--
Part
PartSupp
==

[catalog=tpch]
SHOW Tables like '%T%'
--
Customer
LineItem
Nation
Part
PartSupp
==

SHOW tables like '%foo%'
--
\
No matching tables found
==

# Don't show internal functions
SHOW functions like '$a%'
--
\
No matching functions found
==

show FuNcTiOnS like '%floor%'
--
floor
FloorDiv
==

# Check that the full function name is shown
show functions like '%host%';
--
net.host
==

SHOW TVFs like '%TableArg%'
--
BinaryAbTableArg
BinaryTableArg
CallsUnaryAbTableArgWithScalarArgsTempl
JoinsTableArgToScannedTable
UnaryAbTableArg
UnaryAbTableArgScannedInCTE
UnaryAbTableArgSelfJoin
UnaryAbTableArgWithScalarArgs
UnaryAbTableArgWithScalarArgsTempl
UnaryTableArg
UnaryTableArgAggregatedWithOrderBy
UnaryTableArgColumnsUnused
==

SHOW tvfs like '%foo%'
--
\
No matching tvfs found
==

# Unknown function
SHOW Functions like 'NewSquare'
--
\
No matching functions found
==

# Newly defined function is found
CREATE TEMP FUNCTION NewSquare(x INT64)
RETURNS DOUBLE
AS (
  (x *x )
  );

SHOW Functions like 'NewS%'
--
Function registered.
NewSquare

==

# Parse Procedural script.
[mode=parse]
[sql_mode=script]
for i in (select 1) do select 1; end for;
--
Script [0-41]
  StatementList [0-41]
    ForInStatement [0-40]
      Identifier(i) [4-5]
      Query [10-18]
        Select [10-18]
          SelectList [17-18]
            SelectColumn [17-18]
              IntLiteral(1) [17-18]
      StatementList [23-32]
        QueryStatement [23-31]
          Query [23-31]
            Select [23-31]
              SelectList [30-31]
                SelectColumn [30-31]
                  IntLiteral(1) [30-31]
\
==

# Unparse a procedural script.
[mode=unparse]
[sql_mode=script]
for i in (select 1) do select 1; end for;
--

FOR i IN (
SELECT
  1
)
DO
  SELECT
    1
  ;
END FOR ;
\

==

# Execute a procedural script.
[mode=execute]
[sql_mode=script]
for i in (select 1) do select 1; end for;
--
+--------+
| $col_1 |
+--------+
| 1      |
+--------+

+--------+
| $col_1 |
+--------+
| 1      |
+--------+
\
==

# Multi mode for procedural script.
[mode={{parse|unparse|analyze,execute}}]
[sql_mode=script]
DECLARE x INT64 DEFAULT 2;
for i in (select 1) do select 1, x; end for;
--
ALTERNATION GROUP: parse
--
Script [0-71]
  StatementList [0-71]
    VariableDeclaration [0-25]
      IdentifierList [8-9]
        Identifier(x) [8-9]
      SimpleType [10-15]
        PathExpression [10-15]
          Identifier(INT64) [10-15]
      IntLiteral(2) [24-25]
    ForInStatement [27-70]
      Identifier(i) [31-32]
      Query [37-45]
        Select [37-45]
          SelectList [44-45]
            SelectColumn [44-45]
              IntLiteral(1) [44-45]
      StatementList [50-62]
        QueryStatement [50-61]
          Query [50-61]
            Select [50-61]
              SelectList [57-61]
                SelectColumn [57-58]
                  IntLiteral(1) [57-58]
                SelectColumn [60-61]
                  PathExpression [60-61]
                    Identifier(x) [60-61]
\
--
ALTERNATION GROUP: unparse
--
DECLARE x INT64 DEFAULT 2 ;
FOR i IN (
SELECT
  1
)
DO
  SELECT
    1,
    x
  ;
END FOR ;
\
--
ALTERNATION GROUP: analyze,execute
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan

+--------+
| $col_1 |
+--------+
| 1      |
+--------+

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
| +-$query.x#2 AS x [INT64]
+-query=
  +-ProjectScan
    +-column_list=$query.[$col1#1, x#2]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=1)
    | +-x#2 := Constant(x, type=INT64, value=2)
    +-input_scan=
      +-SingleRowScan

+--------+---+
| $col_1 | x |
+--------+---+
| 1      | 2 |
+--------+---+
\
==

# Unsupported modes for procedural script.
[mode={{analyze|unanalyze|explain}}]
[sql_mode=script]
for i in (select 1) do select 1; end for;
--
ALTERNATION GROUPS:
    analyze
    unanalyze
--
ERROR: UNAVAILABLE: Analysis is not supported for scripts. Individual statements can be analyzed while they are executed if both "execute" and "analyze" are specified.
--
ALTERNATION GROUP: explain
--
ERROR: UNAVAILABLE: Explanation is not supported for scripts.
==

# Unsupported and supported modes for procedural script.
[mode={{analyze|unanalyze|explain|execute}}]
[sql_mode=script]
for i in (select 1) do select 1; end for;
--
ALTERNATION GROUPS:
    analyze
    unanalyze
--
ERROR: UNAVAILABLE: Analysis is not supported for scripts. Individual statements can be analyzed while they are executed if both "execute" and "analyze" are specified.
--
ALTERNATION GROUP: explain
--
ERROR: UNAVAILABLE: Explanation is not supported for scripts.
--
ALTERNATION GROUP: execute
--
+--------+
| $col_1 |
+--------+
| 1      |
+--------+

+--------+
| $col_1 |
+--------+
| 1      |
+--------+
\
==

# Infinite loop in procedural script.
[mode=execute]
[sql_mode=script]
[max_statements_to_execute=20]
DECLARE x INT64 DEFAULT 0;
WHILE x < 10
DO
  SELECT x;
END WHILE;
SELECT x;
--
+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

+---+
| x |
+---+
| 0 |
+---+

ERROR: INVALID_ARGUMENT: Potential infinite loop in the script. Script has reached maximum execution limit: 20
==

# Test reading some SimpleConstants from the sample catalog.
[mode=analyze,execute]
[catalog=sample]
select TestConstantTrue, TestConstantInt64, TestConstantProto;
--
QueryStmt
+-output_column_list=
| +-$query.TestConstantTrue#1 AS TestConstantTrue [BOOL]
| +-$query.TestConstantInt64#2 AS TestConstantInt64 [INT64]
| +-$query.TestConstantProto#3 AS TestConstantProto [PROTO<zetasql_test__.KitchenSinkPB>]
+-query=
  +-ProjectScan
    +-column_list=$query.[TestConstantTrue#1, TestConstantInt64#2, TestConstantProto#3]
    +-expr_list=
    | +-TestConstantTrue#1 := Constant(TestConstantTrue, type=BOOL, value=true)
    | +-TestConstantInt64#2 := Constant(TestConstantInt64, type=INT64, value=1)
    | +-TestConstantProto#3 := Constant(TestConstantProto, type=PROTO<zetasql_test__.KitchenSinkPB>, value={int64_key_1: 1 int64_key_2: -999})
    +-input_scan=
      +-SingleRowScan

+------------------+-------------------+------------------------------------+
| TestConstantTrue | TestConstantInt64 | TestConstantProto                  |
+------------------+-------------------+------------------------------------+
| true             | 1                 | {int64_key_1: 1 int64_key_2: -999} |
+------------------+-------------------+------------------------------------+
\
==

# In analyze mode, we don't evaluate the constant expressions, so we can
# continue past the error.  The SELECT shows the types.
# In execute mode, we stop on the error.
[mode=analyze{{|,execute}}]
create constant c1 = 'abc' || 'def';
create constant c2 = error("abc") > 0;
create constant c3 = c1 || 'ghi';
select c1, c2, c3;
--
ALTERNATION GROUP: <empty>
--
CreateConstantStmt
+-name_path=c1
+-expr=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-Literal(type=STRING, value="abc")
    +-Literal(type=STRING, value="def")

Constant registered.
CreateConstantStmt
+-name_path=c2
+-expr=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
    | +-Literal(type=STRING, value="abc")
    +-Literal(type=INT64, value=0)

Constant registered.
CreateConstantStmt
+-name_path=c3
+-expr=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-Constant(c1, type=STRING, value=Uninitialized value)
    +-Literal(type=STRING, value="ghi")

Constant registered.
QueryStmt
+-output_column_list=
| +-$query.c1#1 AS c1 [STRING]
| +-$query.c2#2 AS c2 [BOOL]
| +-$query.c3#3 AS c3 [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[c1#1, c2#2, c3#3]
    +-expr_list=
    | +-c1#1 := Constant(c1, type=STRING, value=Uninitialized value)
    | +-c2#2 := Constant(c2, type=BOOL, value=Uninitialized value)
    | +-c3#3 := Constant(c3, type=STRING, value=Uninitialized value)
    +-input_scan=
      +-SingleRowScan
\
--
ALTERNATION GROUP: ,execute
--
CreateConstantStmt
+-name_path=c1
+-expr=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-Literal(type=STRING, value="abc")
    +-Literal(type=STRING, value="def")

Constant registered.
Constant evaluated.
CreateConstantStmt
+-name_path=c2
+-expr=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-FunctionCall(ZetaSQL:error(STRING) -> INT64)
    | +-Literal(type=STRING, value="abc")
    +-Literal(type=INT64, value=0)

Constant registered.
ERROR: OUT_OF_RANGE: abc
==

# The reference implementation can get values from SQLConstants.
[mode=analyze,execute]
create constant c1 = 'abc' || 'def';
create constant c2 = c1 || '!';
select c1, c2;
--
CreateConstantStmt
+-name_path=c1
+-expr=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-Literal(type=STRING, value="abc")
    +-Literal(type=STRING, value="def")

Constant registered.
Constant evaluated.
CreateConstantStmt
+-name_path=c2
+-expr=
  +-FunctionCall(ZetaSQL:concat(STRING, repeated(1) STRING) -> STRING)
    +-Constant(c1, type=STRING, value="abcdef")
    +-Literal(type=STRING, value="!")

Constant registered.
Constant evaluated.
QueryStmt
+-output_column_list=
| +-$query.c1#1 AS c1 [STRING]
| +-$query.c2#2 AS c2 [STRING]
+-query=
  +-ProjectScan
    +-column_list=$query.[c1#1, c2#2]
    +-expr_list=
    | +-c1#1 := Constant(c1, type=STRING, value="abcdef")
    | +-c2#2 := Constant(c2, type=STRING, value="abcdef!")
    +-input_scan=
      +-SingleRowScan

+--------+---------+
| c1     | c2      |
+--------+---------+
| abcdef | abcdef! |
+--------+---------+
\
==

# Constant evaluation in pipe IF can handle SQLConstants.
[mode=analyze,execute]
[enabled_language_features=MAXIMUM,+PIPE_IF]
create constant c1 = 1 < 2;
create constant c2 = 1 > 2;
from KeyValue
|> IF c1 THEN ( |> EXTEND 55 )
|> IF c2 THEN ( |> EXTEND 66 )
--
CreateConstantStmt
+-name_path=c1
+-expr=
  +-FunctionCall(ZetaSQL:$less(INT64, INT64) -> BOOL)
    +-Literal(type=INT64, value=1)
    +-Literal(type=INT64, value=2)

Constant registered.
Constant evaluated.
CreateConstantStmt
+-name_path=c2
+-expr=
  +-FunctionCall(ZetaSQL:$greater(INT64, INT64) -> BOOL)
    +-Literal(type=INT64, value=1)
    +-Literal(type=INT64, value=2)

Constant registered.
Constant evaluated.
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$pipe_extend.$col1#3 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $pipe_extend.$col1#3]
    +-expr_list=
    | +-$col1#3 := Literal(type=INT64, value=55)
    +-input_scan=
      +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])

+-----+-------+----+
| Key | Value |    |
+-----+-------+----+
| 1   | a     | 55 |
| 2   | b     | 55 |
+-----+-------+----+
\
==

# In script mode, variables act like constants and are available to
# analysis and evaluation.
[mode=execute]
[sql_mode=script]
declare x bool default true;
select x AS xx |> IF x THEN ( |> EXTEND 55 );
set x = 1 > 2;
select x AS xx |> IF x THEN ( |> EXTEND 66 );
--
+------+--------+
| xx   | $col_2 |
+------+--------+
| true | 55     |
+------+--------+

+-------+
| xx    |
+-------+
| false |
+-------+
\
==

SELECT (JSON "{}")[0];
--
+------+
|      |
+------+
| NULL |
+------+
\
==

# Subscript access on MAP types using
[catalog=none]
[mode=analyze,execute]
[enabled_language_features=DEV,+BARE_ARRAY_ACCESS]

SELECT MAP_FROM_ARRAY([('a', 1)])['a']
--
QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 :=
    |   +-FunctionCall(ZetaSQL:$subscript(MAP<STRING, INT64>, STRING) -> INT64)
    |     +-FunctionCall(ZetaSQL:map_from_array(ARRAY<STRUCT<STRING, INT64>>) -> MAP<STRING, INT64>)
    |     | +-Literal(type=ARRAY<STRUCT<STRING, INT64>>, value=[{"a", 1}])
    |     +-Literal(type=STRING, value="a")
    +-input_scan=
      +-SingleRowScan

+---+
|   |
+---+
| 1 |
+---+
\
==

# Deprecation warnings
[catalog=sample]
[mode=analyze]

FROM KeyValue
|> WINDOW RANK() OVER (order by key)
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS Key [INT64]
| +-KeyValue.Value#2 AS Value [STRING]
| +-$analytic.$analytic1#4 AS `$col1` [INT64]
+-query=
  +-AnalyticScan
    +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $analytic.$analytic1#4]
    +-input_scan=
    | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
    +-function_group_list=
      +-AnalyticFunctionGroup
        +-order_by=
        | +-WindowOrdering
        |   +-order_by_item_list=
        |     +-OrderByItem
        |       +-column_ref=
        |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        +-analytic_function_list=
          +-$analytic1#4 := AnalyticFunctionCall(ZetaSQL:rank() -> INT64)

Deprecation warnings:
The pipe WINDOW operator is deprecated; Use EXTEND instead [at 2:1]
|> WINDOW RANK() OVER (order by key)
^
==

# STATIC_DESCRIBE can analyze and execute.
# The static logging output current doesn't go anywhere in execute mode.
[catalog=sample]
[mode=analyze,execute]
FROM KeyValue
|> STATIC_DESCRIBE
|> SELECT key
--
QueryStmt
+-output_column_list=
| +-KeyValue.Key#1 AS key [INT64]
+-query=
  +-ProjectScan
    +-column_list=[KeyValue.Key#1]
    +-input_scan=
      +-StaticDescribeScan
        +-column_list=[KeyValue.Key#1]
        +-describe_text=
        |   """
        |   NameList:
        |     Key INT64 KeyValue.Key#1
        |     Value STRING KeyValue.Value#2
        |   NameScope:
        |     Names:
        |       Key -> INT64 (KeyValue.Key#1) (implicit)
        |       Value -> STRING (KeyValue.Value#2) (implicit)
        |     Range variables:
        |       KeyValue -> RANGE_VARIABLE<Key,Value>
        |   """
        +-input_scan=
          +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])

+-----+
| key |
+-----+
| 1   |
| 2   |
+-----+
\
==

# Test core functionalities of multi-statements
[mode=execute]
select 1 as col
|> fork (
  |> select 1
), (
  |> select 2
)
--
+---+
|   |
+---+
| 1 |
+---+

+---+
|   |
+---+
| 2 |
+---+
\
==

# With empty results
[mode=execute]
select 1 as col
|> fork (
  |> where false
), (
  |> select 2
)
--
+-----+
| col |
+-----+
+-----+

+---+
|   |
+---+
| 2 |
+---+
\
==

# With DMLs
[mode=execute]
select 1 as key, 'a' as value
|> fork (
  |> select *
), (
  |> insert into KeyValue (Key, Value)
)
--
+-----+-------+
| key | value |
+-----+-------+
| 1   | a     |
+-----+-------+

Error: DML statements can only be applied to temporary tables created in the current session
==

# With DDLs.
[mode=execute]
select 1 as col
|> fork (
  |> select *
), (
  |> create table t
)
--
Table created
+-----+
| col |
+-----+
| 1   |
+-----+
\
==

# With errors
[mode=execute]
select error("an error")
|> fork (
  |> select error("this won't be executed")
), (
  |> select error("neither will this")
)
--
Error: Prerequisite CreateWithEntryStmt failed, statement index: 0 error: an error
Error: Prerequisite CreateWithEntryStmt failed, statement index: 0 error: an error
==

[mode=execute]
select 1
|> fork (
  |> select error("this error does not prevent the other statement from executing")
), (
  |> select *
)
--
Error: this error does not prevent the other statement from executing
+---+
|   |
+---+
| 1 |
+---+
\
==

[mode=explain]
select 1
|> fork (
  |> select 1
), (
  |> select 2
)
--
MultiStmtExpr(
+-$fork_cte_1 := ArrayNestExpr(is_with_table=0
| +-element: NewStructExpr(
| | +-type: STRUCT<INT64>,
| | +-0 : $col1),
| +-input: ComputeOp(
|   +-map: {
|   | +-$col1 := ConstExpr(1)},
|   +-input: EnumerateOp(ConstExpr(1)))),
+-ArrayNestExpr(is_with_table=0
| +-element: NewStructExpr(
| | +-type: STRUCT<INT64>,
| | +-0 : $col1.2),
| +-input: ComputeOp(
|   +-map: {
|   | +-$col1.2 := ConstExpr(1)},
|   +-input: ArrayScanOp(
|     +-$col1 := field[0]:,
|     +-array: $fork_cte_1))),
+-ArrayNestExpr(is_with_table=0
| +-element: NewStructExpr(
| | +-type: STRUCT<INT64>,
| | +-0 : $col1.3),
| +-input: ComputeOp(
|   +-map: {
|   | +-$col1.3 := ConstExpr(2)},
|   +-input: ArrayScanOp(
|     +-$col1 := field[0]:,
|     +-array: $fork_cte_1))))
\
==

# Test CREATE OR REPLACE TABLE on an existing table
[enabled_language_features=DEV,+BARE_ARRAY_ACCESS]
[mode=execute]
select 1 as col
|> fork (
  |> create table t
), (
  |> create or replace table t
)
--
Table created
Table created or replaced
==

# Test CREATE OR REPLACE TABLE on a non-existing table
[mode=execute]
select 1 as col
|> fork (
  |> create or replace table t
)
--
Table created or replaced
==

# Test CREATE TABLE IF NOT EXISTS on an existing table
[mode=execute]
select 1 as col
|> fork (
  |> create table t
), (
  |> create table if not exists t
)
--
Table created
Table creation skipped
==

# Test CREATE TABLE IF NOT EXISTS on a non-existing table
[mode=execute]
select 1 as col
|> fork (
  |> create table if not exists t
)
--
Table created
==

# Test CREATE TABLE on an existing table.
[mode=execute]
select 1 as col
|> fork (
  |> create table t
), (
  |> create table t
)
--
Table created
Error: Table already exists: t
==

# Test CREATE TABLE on a non-existing table.
[mode=execute]
select 1 as col
|> fork (
  |> create table t
)
--
Table created
==

# Test standalone CREATE TABLE AS SELECT has the correct data populated.
[mode=execute]
create table t as (
  select 1 as col
);

from t;
--
Table created
+-----+
| col |
+-----+
| 1   |
+-----+
\
==

# Test CREATE TABLE AS SELECT inside a multi-statement has the correct data
# populated.
[mode=execute]
select 1 as col
|> fork (
  |> create table t
);
from t;
--
Table created
+-----+
| col |
+-----+
| 1   |
+-----+
\
==

# Conflicting DDLs. Only one succeeds.
[mode=execute]
select 1 as col
|> fork (
  |> create table t
), (
  |> create table t
)
--
Table created
Error: Table already exists: t
==

# Test CREATE TABLE with primary key.
[mode=execute]
create table t (col int64, PRIMARY KEY (col));
describe table t;
--
Table created
Table: t
Columns:
  col INT64
Primary key: (col)
\
==

# Test CREATE TABLE with primary key with multiple columns.
[mode=execute]
create table t (col1 int64, col2 int64, PRIMARY KEY (col1, col2));
describe table t;
--
Table created
Table: t
Columns:
  col1 INT64
  col2 INT64
Primary key: (col1, col2)
\
==

# Test CREATE TABLE with primary key no columns.
[mode=execute]
create table t (col1 int64, col2 int64, PRIMARY KEY ());
describe table t;
--
Table created
Table: t
Columns:
  col1 INT64
  col2 INT64
Primary key: ()
\
==

# Test CREATE TABLE without primary key.
[mode=execute]
create table t (col1 int64);
describe table t;
--
Table created
Table: t
Columns:
  col1 INT64
\
==

# Standalone INSERT.
[mode=execute]
CREATE TABLE t (key INT64, value STRING, PRIMARY KEY(key))
AS
SELECT 1 AS key, 'one' AS value;

INSERT INTO t (key, value) VALUES (11, 'eleven');

FROM t;
--
Table created
+---------------+
| rows_modified |
+---------------+
| 1             |
+---------------+

+-----+--------+
| key | value  |
+-----+--------+
| 1   | one    |
| 11  | eleven |
+-----+--------+
\
==

# Inserting into a non-session table is not allowed.
[mode=execute]
INSERT INTO KeyValueWithPrimaryKey (key, value) VALUES (11, 'eleven');
\
--
Error: DML statements can only be applied to temporary tables created in the current session
==

# DELETE is not supported
[mode=execute]
DELETE FROM KeyValueWithPrimaryKey WHERE key = 2
\
--
Error: Only INSERT statements are supported in multi-statement queries
==

# UPDATE is not supported
[mode=execute]
UPDATE KeyValueWithPrimaryKey SET value = 'one-updated' WHERE key = 1
\
--
Error: Only INSERT statements are supported in multi-statement queries
==

# Test successful INSERT in a multi-stmt. The insertion does not affect the
# other fork branch. The newly created table shadows the existing table
# KeyValueWithPrimaryKey.
[mode=execute]
CREATE TABLE KeyValueWithPrimaryKey (key INT64, value STRING, PRIMARY KEY(key));

INSERT INTO KeyValueWithPrimaryKey (key, value) VALUES (1, 'one');

SELECT 11 AS key, 'eleven' AS value
|> FORK (
  |> INSERT INTO KeyValueWithPrimaryKey
), (
  |> SELECT 1
);

FROM KeyValueWithPrimaryKey;
--
Table created
+---------------+
| rows_modified |
+---------------+
| 1             |
+---------------+

+---------------+
| rows_modified |
+---------------+
| 1             |
+---------------+

+---+
|   |
+---+
| 1 |
+---+

+-----+--------+
| key | value  |
+-----+--------+
| 1   | one    |
| 11  | eleven |
+-----+--------+
\
==

# Two conflicting INSERTs, only one will succeed.
[mode=execute]
CREATE TABLE t (key INT64, value STRING, PRIMARY KEY(key))
AS
SELECT 1 AS key, 'one' AS value;

SELECT 11 AS key, 'eleven' AS value
|> FORK (
  |> INSERT INTO t
), (
  |> INSERT INTO t
);

FROM t;
--
Table created
+---------------+
| rows_modified |
+---------------+
| 1             |
+---------------+

Error: Key already exists for INSERT operation
+-----+--------+
| key | value  |
+-----+--------+
| 1   | one    |
| 11  | eleven |
+-----+--------+
\
==

# Test DML on table without primary key
[mode=execute]
CREATE TABLE t
AS
SELECT 1 AS key, 'one' AS value;

SELECT 1 AS key, 'a' AS value
|> FORK (
  |> INSERT INTO t
);
\
--
Table created
Error: DML statements require the table to have a primary key.
==

# Test DML with THEN RETURN clause (unsupported)
[mode=execute]
SELECT 1 AS key, 'a' AS value
|> FORK (
  |> INSERT INTO KeyValue THEN RETURN *
);
\
--
ERROR: INVALID_ARGUMENT: Pipe INSERT does not support THEN RETURN [at 3:27]
  |> INSERT INTO KeyValue THEN RETURN *
                          ^

==

# Test multi-statement with simple queries in a script.
[mode=execute,analyze]
[sql_mode=script]
SELECT 1 AS a, 'x' AS b
|> FORK (
  |> SELECT a
), (
  |> SELECT b
);

SELECT 1;
--
MultiStmt
+-statement_list=
  +-CreateWithEntryStmt
  | +-with_entry=
  |   +-WithEntry
  |     +-with_query_name="$fork_cte_1"
  |     +-with_subquery=
  |       +-ProjectScan
  |         +-column_list=$query.[a#1, b#2]
  |         +-expr_list=
  |         | +-a#1 := Literal(type=INT64, value=1)
  |         | +-b#2 := Literal(type=STRING, value="x")
  |         +-input_scan=
  |           +-SingleRowScan
  +-QueryStmt
  | +-output_column_list=
  | | +-$query.a#1 AS a [INT64]
  | +-query=
  |   +-ProjectScan
  |     +-column_list=[$query.a#1]
  |     +-input_scan=
  |       +-WithRefScan(column_list=$query.[a#1, b#2], with_query_name="$fork_cte_1")
  +-QueryStmt
    +-output_column_list=
    | +-$query.b#2 AS b [STRING]
    +-query=
      +-ProjectScan
        +-column_list=[$query.b#2]
        +-input_scan=
          +-WithRefScan(column_list=$query.[a#1, b#2], with_query_name="$fork_cte_1")

+---+
| a |
+---+
| 1 |
+---+

+---+
| b |
+---+
| x |
+---+

QueryStmt
+-output_column_list=
| +-$query.$col1#1 AS `$col1` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$query.$col1#1]
    +-expr_list=
    | +-$col1#1 := Literal(type=INT64, value=1)
    +-input_scan=
      +-SingleRowScan

+--------+
| $col_1 |
+--------+
| 1      |
+--------+
\
==

# Test multi-statement where one branch produces no rows in a script.
[mode=execute]
[sql_mode=script]
SELECT "foo";

SELECT 1 AS x
|> FORK (
  |> SELECT x
  |> WHERE x > 1
), (
  |> SELECT x AS y
);
--

+--------+
| $col_1 |
+--------+
| foo    |
+--------+

+---+
| x |
+---+
+---+

+---+
| y |
+---+
| 1 |
+---+
\
==

# Test multi-statement with a CTAS branch in a script.
# Also tests that the created table is available after the multi-stmt.
[mode=execute]
[sql_mode=script]
SELECT 1 AS a, 'x' AS b
|> FORK (
  |> CREATE TEMP TABLE NewTable1
), (
  |> SELECT b
);

SELECT * FROM NewTable1;
--

+---------------------+---------------------+
| created_object_type | created_object_name |
+---------------------+---------------------+
| Temp Table          | NewTable1           |
+---------------------+---------------------+

+---+
| b |
+---+
| x |
+---+

+---+---+
| a | b |
+---+---+
| 1 | x |
+---+---+
\
==

# Test multi-statement with an INSERT statement in a script.
[mode=execute]
[sql_mode=script]
CREATE TEMP TABLE TestTable(key INT64, value STRING, PRIMARY KEY(key))
AS
SELECT 1 AS key, 'one' AS value;

SELECT 11 AS key, 'eleven' AS value
|> FORK (
  |> INSERT INTO TestTable
), (
  |> SELECT key + 1
);

FROM TestTable;
--

+-------------------+----------------------------------------------+
| num_rows_modified | all_rows                                     |
+-------------------+----------------------------------------------+
| 1                 | [{1 key, one value}, {11 key, eleven value}] |
+-------------------+----------------------------------------------+

+--------+
| $col_1 |
+--------+
| 12     |
+--------+

+-----+--------+
| key | value  |
+-----+--------+
| 1   | one    |
| 11  | eleven |
+-----+--------+
\
==

# Test multi-statement with a single failure in a TRY-CATCH block in a script.
[mode=execute]
[sql_mode=script]
BEGIN
  SELECT 1
  |> FORK (
    |> SELECT ERROR("this is an error")
  ), (
    |> SELECT 2
  );
EXCEPTION WHEN ERROR THEN
  SELECT 'caught', @@error.message AS error_message;
END;
--

Error: this is an error
+--------+
| $col_1 |
+--------+
| 2      |
+--------+

+--------+------------------+
| $col_1 | error_message    |
+--------+------------------+
| caught | this is an error |
+--------+------------------+
\
==
