<!--
  parse_ast.md generated from template:
    https://github.com/google/zetasql/blob/master/zetasql/parser/parse_tree_generated.md.template

  Generated by target:
    //zetasql/parser:gen_parse_tree_md

-->
# ZetaSQL Parse AST

The ZetaSQL Parser produces an abstract syntax tree (AST). The nodes of this
tree are generated by
//zetasql/parser/gen_parse_tree.py.
This document provides a summary of the nodes.

This AST shows the syntactic structure and does not capture the
semantics.
See //zetasql/docs/resolved_ast.md to see the AST produced by the ZetaSQL analyzer.

### Node Hierarchy

This is the hierarchy of the AST node types.

<pre><code>
{%- set root_nodes = root_child_nodes.values() -%}
{{- root_node_name|linkify_node_names}}
{% for node in root_nodes|sort_by_name recursive %}
{{"%*s" | format(loop.depth * 2, "")}} {{node.name|linkify_node_names}}
{{loop(node.subclasses.values()|sort_by_name) -}}
{% endfor %}
</code></pre>

## Node Details

This documentation includes only the public field accessors. It excludes
constructors, setters, and boilerplate implementation of virtual methods from
the base class.

### {{root_node_name}}

The base class `{{root_node_name}}` is defined in
//zetasql/parser/ast_node.h

{% for node in nodes|sort_by_name %}

### {{node.name}}{ #{{node.name}} }

<pre><code class="lang-c++">
 {%- if node.comment %}
{{ node.comment|linkify_node_names}}
 {% endif %}
class {{node.name}} {{node.class_final}}: public {{node.parent|linkify_node_names}} {
 {% if not node.is_abstract %}
  static constexpr ASTNodeKind kConcreteNodeKind = {{node.node_kind}};
 {% endif %}

 {% for enum_def in node.enum_defs %}
  {{enum_def}}
 {% endfor %}

 {# getters for primitives and enums #}
 {% set ns = namespace(section_blank_line=true) %}
 {% for field in node.fields %}
  {% if field.gen_setters_and_getters and not field.is_node_ptr and not field.is_vector %}
   {% if ns.section_blank_line %}
{{blank_line}}
   {% set ns.section_blank_line = false %}
   {% endif %}
   {% if field.comment %}
{{blank_line}}
{{field.comment|linkify_node_names}}
   {% set ns.section_blank_line = true %}
   {% endif %}
  {{field.member_type|linkify_node_names}} {{field.name}}() const;
  {% endif %}
 {% endfor %}

 {# getters for non-primitives scalars. #}
 {% set ns = namespace(section_blank_line=true) %}
 {% for field in node.fields %}
  {% if field.gen_setters_and_getters and field.is_node_ptr and not field.is_vector %}
   {% if ns.section_blank_line %}
{{blank_line}}
   {% set ns.section_blank_line = false %}
   {% endif %}
   {% if field.comment %}
{{blank_line}}
{{field.comment|linkify_node_names}}
   {% set ns.section_blank_line = true %}
   {% endif %}
  {{field.member_type|linkify_node_names}} {{field.name}}() const;
  {% endif %}
 {% endfor -%}

{# getters for non-primitive vectors.. #}
 {% set ns = namespace(section_blank_line=true) %}
 {% for field in node.fields %}
  {% if field.gen_setters_and_getters and field.is_vector %}
   {% if ns.section_blank_line %}
{{blank_line}}
   {% set ns.section_blank_line = false %}
   {% endif %}
   {% if field.comment %}
{{blank_line}}
{{field.comment|linkify_node_names}}
   {% set ns.section_blank_line = true %}
   {% endif %}
  const {{field.member_type|linkify_node_names}}& {{field.name}}() const;
  {{field.element_storage_type|linkify_node_names}} {{field.name}}(int i) const;
  {% endif %}
 {% endfor -%}

 {% if node.extra_public_defs %}
{{blank_line}}
{{node.extra_public_defs|linkify_node_names}}
 {% endif %}
};
</code></pre>

{% endfor %}
{{blank_line}}
